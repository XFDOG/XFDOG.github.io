<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAVA | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="JAVA | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="代码">
<meta property="og:url" content="http://example.com/%E4%BB%A3%E7%A0%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-28T07:26:32.000Z">
<meta property="article:modified_time" content="2024-03-28T07:55:53.731Z">
<meta property="article:author" content="花开人无在">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>花开人无在</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(7)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="代码">
            
            代码
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="操作系统">
            
            操作系统
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        <a 
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="7">
<input type="hidden" id="yelog_site_word_count" value="71.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 代码 "
           href="/2024/04/01/JavaScript/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JavaScript">JavaScript</span>
            <span class="post-date" title="2024-04-01 21:55:05">2024/04/01</span>
        </a>
        
        
        <a  class="全部文章 操作系统 "
           href="/2024/04/01/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-04-01 20:05:45">2024/04/01</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/03/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="博客搭建">博客搭建</span>
            <span class="post-date" title="2024-03-27 19:48:23">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 代码 "
           href="/2024/03/27/JAVA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JAVA">JAVA</span>
            <span class="post-date" title="2024-03-27 19:33:34">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 代码 "
           href="/2024/03/27/Python/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python">Python</span>
            <span class="post-date" title="2024-03-27 19:33:34">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 代码 "
           href="/2024/03/27/php-0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PHP">PHP</span>
            <span class="post-date" title="2024-03-27 19:33:34">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/03/27/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2024-03-27 19:10:14">2024/03/27</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-JAVA" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">JAVA</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="代码">代码</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-04-12 15:19:17'>2024-03-27 19:33</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:15.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">java基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2"><span class="toc-text">整形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-text">布尔型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">表达式的自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AC%A6"><span class="toc-text">连接符+</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F"><span class="toc-text">自增与自减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%B5%8B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">扩展赋运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-text">Scanner接收键盘输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IF%E5%88%86%E6%94%AF"><span class="toc-text">IF分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch"><span class="toc-text">switch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E7%A9%BF%E9%80%8F%E6%80%A7%E5%9C%A8%E7%89%B9%E5%AE%9A%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-text">switch穿透性在特定情况下可以简化代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FOR%E5%BE%AA%E7%8E%AF"><span class="toc-text">FOR循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">do while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0random"><span class="toc-text">生成随机数random</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8C%9C%E6%95%B0%E5%AD%97"><span class="toc-text">猜数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-text">静态初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="toc-text">访问数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">动态数组初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86"><span class="toc-text">案例-评委打分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">取最大值，最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%8D%E8%BD%AC"><span class="toc-text">数组反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">随机排序数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%971-n%E7%9A%84%E5%92%8C"><span class="toc-text">计算1-n的和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E5%81%B6%E6%95%B0"><span class="toc-text">判断一个整数是奇数还是偶数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-text">java的参数传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">引用类型的参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0int%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9"><span class="toc-text">打印int类型的数组内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%80%E6%A0%B7"><span class="toc-text">比较两个数组是否一样</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E5%BC%80%E5%8F%91%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">案例-开发武器系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">return关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E7%B3%BB"><span class="toc-text">联系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E9%A3%9E%E6%9C%BA%E7%A5%A8"><span class="toc-text">买飞机票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-text">开发验证码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-text">访问控制符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93Javabean"><span class="toc-text">实体Javabean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%85%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用包的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2String"><span class="toc-text">字符串String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8String%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">常用String构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">String常用的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81"><span class="toc-text">用户登录验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88ArrayList"><span class="toc-text">集合ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-text">常用方法名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-text">循环遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#foreach"><span class="toc-text">foreach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Iterator"><span class="toc-text">Iterator</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%83%BD%E4%B8%8D%E6%94%AF%E6%8C%81%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">集合和泛型都不支持引用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%9C%89%E6%97%A0static%E4%BF%AE%E9%A5%B0"><span class="toc-text">成员变量有无static修饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E6%9C%89%E6%97%A0static%E4%BF%AE%E9%A5%B0"><span class="toc-text">成员方法有无static修饰</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">实例代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super()关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">子类构造器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E8%B0%83%E7%94%A8%E5%85%84%E5%BC%9F%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">this()调用兄弟构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">多态的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">多态的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E5%90%8E%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%8A%A0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-text">JDK8后接口增加的三种形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用接口的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9E%9A%E4%B8%BE"><span class="toc-text">抽象枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">泛型的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API-1"><span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-text">Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Objects%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Objects工具类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer"><span class="toc-text">StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringJoiner"><span class="toc-text">StringJoiner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-text">Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System"><span class="toc-text">System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime"><span class="toc-text">Runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal"><span class="toc-text">BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">日期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">JDK8之前的日期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%EF%BC%9A%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">Date：时间日期类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDateFormat%EF%BC%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4"><span class="toc-text">SimpleDateFormat：格式化时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E4%B9%8B%E5%90%8E%E7%9A%84%E6%97%A5%E6%9C%9F"><span class="toc-text">JDK8之后的日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateTimeFormatter"><span class="toc-text">DateTimeFormatter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays"><span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%88%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%AE%80%E5%8C%96Lambda%EF%BC%89"><span class="toc-text">方法引用（进一步简化Lambda）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">静态方法的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">实例方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">特定类型方法的引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">查找算法(二分查找)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GUI%E7%BC%96%E7%A8%8B"><span class="toc-text">GUI编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AA%97%E4%BD%93%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建窗体对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%A4%A7%E5%B0%8F"><span class="toc-text">设置窗口的位置大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6"><span class="toc-text">事件监听机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">按钮对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80"><span class="toc-text">窗口布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E6%9C%AC%E6%A1%86"><span class="toc-text">创建文本框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E6%9C%AC%E5%9F%9F"><span class="toc-text">创建文本域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%A1%86%E4%B8%8E%E6%96%87%E6%9C%AC%E5%9F%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E7%A7%BB"><span class="toc-text">案例-实现文本框与文本域的数据转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%93%8D%E5%BA%94%E7%9A%84%E9%A2%9C%E8%89%B2%E6%8C%89%E9%92%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%A2%9C%E8%89%B2%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">案例-鼠标移动到响应的颜色按钮，实现颜色的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Label%E6%A0%87%E7%AD%BE"><span class="toc-text">Label标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E6%96%87%E6%9C%AC%E6%A1%86%E5%86%85%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5%E6%95%B0%E5%AD%97"><span class="toc-text">案例-文本框内只能输入数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95"><span class="toc-text">菜单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-text">案例-计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95"><span class="toc-text">下拉菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E7%9A%84ICO%E5%9B%BE%E6%A0%87"><span class="toc-text">设置窗口的ICO图标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E4%BD%93%E5%9C%A8%E5%B1%8F%E5%B9%95%E5%B1%85%E4%B8%AD"><span class="toc-text">设置窗体在屏幕居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E4%BD%93%E7%9A%84%E4%B8%BB%E9%A2%98"><span class="toc-text">设置窗体的主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-text">数据校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JOptionPane"><span class="toc-text">JOptionPane</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">反射机制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">类加载的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-text">静态加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-text">动态加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">获取Class的三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructo%E7%B1%BB"><span class="toc-text">Constructo类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%894%E7%A7%8D%EF%BC%8C%E9%83%BD%E6%98%AF%E6%9C%89Class%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8"><span class="toc-text">获取构造方法有4种，都是有Class对象调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Field%E7%B1%BB"><span class="toc-text">Field类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">通过反射来获取注解对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E6%9D%A5%E8%8E%B7%E5%8F%96%E4%BB%BB%E6%84%8F%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">通过注解来获取任意类的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%B5%81"><span class="toc-text">I&#x2F;O流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">字节输出、输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">字符输出、输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">带缓冲的字符输入、输出流</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="java基础语法"><a href="#java基础语法" class="headerlink" title="java基础语法"></a>java基础语法</h2><p>idea快捷输出，sout</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>//单行注释

/* 多行注释*/


/**
 文档注释，文档注释的内容是可以提取到一个程序的说明文档去的*/
</code></pre>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code>字符必须用单引号，一个空格，\n等也算
字符串必须用双引号


特殊字符\n表示换行，\r表示回车,\t表示tab
</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>定义格式：
数据类型 变量名称 = 数据;
</code></pre>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><pre><code>byte：内存占用1个字节  数据范围：-128 ~ 127
</code></pre>
<pre><code>short：内存占用2个字节  数据范围：-32768 ~ 32767
</code></pre>
<pre><code>int（默认）：内存占用4个字节  数据范围：大概21亿
</code></pre>
<pre><code>long：内存占用8个字节    //随便写一个整形字面量默认是int类型，42245454545454545虽然没有超过long的范围，但是超过了int类型的范围，要在后面加l/L
</code></pre>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><pre><code>float：内存占用4个字节
</code></pre>
<pre><code>double（默认）：内存占用8个字节  //随便写小数字面量定义是double类型，需要在数据后加f/F才是float类型
</code></pre>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><pre><code>char：内存占用2个字节   数据范围：0 - 65535
</code></pre>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><pre><code>boolean：内存占用1个字节   数据范围：true，false
</code></pre>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><pre><code>String：定义字符串
</code></pre>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><pre><code>类型范围小的变量，可以直接赋值给类型范围大的变量   //小转大
</code></pre>
<h3 id="表达式的自动类型转换"><a href="#表达式的自动类型转换" class="headerlink" title="表达式的自动类型转换"></a>表达式的自动类型转换</h3><pre><code>在表达式中，小范围类型的变量会自动转换成表达式中较大范围的类型，在参与运算

表达式的最终结果由最高类型决定

byte，short，char是直接转换成int类型参与运算的
</code></pre>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><pre><code>类型范围大的变量直接赋值给类型范围小的变量，会报错   //ALT + 回车键
</code></pre>
<pre><code>数据类型 变量2 = (数据类型)变量1/数据 
浮点型转为整形，只保留整数部分
byte p2 = (byte) 999;
</code></pre>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>加减乘都一样

/运算在java中，两个整数相除还是取整数

两个整数相除取小数的方法：
    最前面×1.0
    将其中一个整数转换为小数
</code></pre>
<h2 id="连接符"><a href="#连接符" class="headerlink" title="连接符+"></a>连接符+</h2><pre><code>输出可以用+将字符串与其他数据类型连接起来输出
</code></pre>
<h2 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减"></a>自增与自减</h2><pre><code>a++是先使用在+1，   ++a是先+1在使用  --同理


int p1 = 10;
int vl = ++p1;
System.out.println(vl); //输出11，如果是p1++的话，输出10
</code></pre>
<h2 id="扩展赋运算符"><a href="#扩展赋运算符" class="headerlink" title="扩展赋运算符"></a>扩展赋运算符</h2><pre><code>+=  
-=
*=
/=
%=


注意：
byte a = 10;
byte b = 20;

a += b   其实际形式为 a = (byte) a+b
</code></pre>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><pre><code>&gt;
&gt;=
&lt;
&lt;=
==
!=

返回值是布尔类型
</code></pre>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><pre><code>&amp;  ----and
| -----or
！-----取反
^----结果相同返回false，不同返回true



&amp;&amp;：短路与，判断结果与&amp;一样，过程不同，左边若为false，右边不会执行
||：短路或，判断结果与|一样，过程不同，左边若为false，右边不会执行	
</code></pre>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><pre><code>格式：
条件表达式?值1:值2

如果表达式返回true，执行值1;返回false，执行值2
</code></pre>
<h2 id="Scanner接收键盘输入"><a href="#Scanner接收键盘输入" class="headerlink" title="Scanner接收键盘输入"></a>Scanner接收键盘输入</h2><pre><code class="java">import java.util.Scanner;  //导包
public class Main &#123;
    public static void main(String[] args) &#123;
        Scanner input = new Scanner(System.in);   //实例化接受对象
        System.out.println(&quot;请输入整数&quot;);
        int age = input.nextInt();  //接收整形
        System.out.println(&quot;请输入字符串&quot;);
        String name = input.next();  //接受字符串型


    &#125;
&#125;
//System、String都是java.lang包下的，lang包是默认包，不需要导入
</code></pre>
<h2 id="IF分支"><a href="#IF分支" class="headerlink" title="IF分支"></a>IF分支</h2><pre><code>if()&#123;
    ###
&#125;
</code></pre>
<pre><code>if()&#123;
    ###
&#125;
else&#123;
    ####
&#125;
</code></pre>
<pre><code>if()&#123;
    ###
&#125;else if()&#123;
    ####
&#125;else if()&#123;
    ####
&#125;...
else&#123;
    ###
&#125;
</code></pre>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><pre><code>//更适合比较值的情况，会直接定位到可以匹配到的值
switch(表达式)&#123;
    case 值1:
        输出;
        break;
    case 值2:
        输出;
        break;
    case 值3:
        输出;
        break;
    ...
    
    default:
        输出;
&#125;
</code></pre>
<pre><code>注意事项：
1、表达式类型是能是byte，short，int，char，jd5开始支持枚举，jdk开始支持String，不支持double，float，long
2、case给出的值不允许重复，且只能是字面量，不能是变量
3、记得写break，不然会出现穿透现象
</code></pre>
<h3 id="switch穿透性在特定情况下可以简化代码"><a href="#switch穿透性在特定情况下可以简化代码" class="headerlink" title="switch穿透性在特定情况下可以简化代码"></a>switch穿透性在特定情况下可以简化代码</h3><pre><code>当存在多个case分支的输出代码相同时，可以保留最后的case代码，其他的case快都通过穿透性穿透到该case执行代码

</code></pre>
<h2 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h2><pre><code>for(i=1;i&lt;3;i++)&#123;
    System.out.println(&quot;hello world&quot;);
&#125;
</code></pre>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code>初始值;
while(循环条件)&#123;
    循环语句;
    条件控制; //自增之类的
&#125;
</code></pre>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><pre><code>int i = 0;
do&#123;
    system.out.print(i);
&#125;while(i&lt;3)  
//先执行，后判断，至少执行一次

//比如刷票软件，先抢在判断
</code></pre>
<h2 id="生成随机数random"><a href="#生成随机数random" class="headerlink" title="生成随机数random"></a>生成随机数random</h2><pre><code>random
作用：生成随机数

import java.util.Random

Random a = new Random();
int number = a.nextInt(10)  //生成的随机数范围0 - 9  ，如果想生成范围2-10   a.nextInt(9) + 2；或者a.nextItn(2,11)
</code></pre>
<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><pre><code class="java">import java.util.Random;
import java.util.Scanner;

public class XunHuan &#123;
    public static void main(String[] args) &#123;

        Scanner a = new Scanner(System.in);
        Random b = new Random();
        int sj = b.nextInt(100) + 1;
        while (true)&#123;
            
            System.out.println(&quot;请输入整数：&quot;);
            int input = a.nextInt();

            if (input==sj)&#123;
                System.out.println(&quot;恭喜您猜中，为&quot;+input);
                break;

            &#125;else if (input &gt; sj)&#123;
                System.out.println(&quot;数值过大&quot;);
                continue;

            &#125;else if (input&lt;sj)&#123;
                System.out.println(&quot;数值过小&quot;);
                continue;
            &#125;
        &#125;


      &#125;

&#125;
</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>多个相同数据类型的变量可以指向同一个数组（引用类型的变量存储的是堆内存的地址）；如果某个数组变量存储的地址为null，那么该变量将不再指向任何数组对象，</p>
<h3 id="静态初始化数组"><a href="#静态初始化数组" class="headerlink" title="静态初始化数组"></a>静态初始化数组</h3><p>什么类型的数组只能存放什么类型的数据</p>
<p>完整格式</p>
<pre><code>数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,...&#125;

例：
int[] age = new int[]&#123;1,2,3&#125;
</code></pre>
<p>简化格式</p>
<pre><code>数据类型[] 数组名 = &#123;元素1,元素2,...&#125;

例：
int[] age = &#123;1,2,3&#125;
</code></pre>
<h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>数组的长度属性length，</p>
<pre><code>System.out.println(age.length)  //查看数组的长度
</code></pre>
<pre><code>访问：
System.out.println(age[1])  //查看数组的长度
</code></pre>
<h3 id="动态数组初始化"><a href="#动态数组初始化" class="headerlink" title="动态数组初始化"></a>动态数组初始化</h3><p>先定义数组，不存入具体的元素值，只确定数组的长度</p>
<pre><code>语法：
数据类型[] 数组名 = new 数据类型[长度]

例：
int[] a = new int[5]
</code></pre>
<p>不同数据类型数组动初始化的值不同</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte、short、char、int、long</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">float、double</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">接口、类、数组、String</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h3 id="案例-评委打分"><a href="#案例-评委打分" class="headerlink" title="案例-评委打分"></a>案例-评委打分</h3><p>某个歌唱比赛需要开发一个系统，可以录入6名评委的打分，录入完毕后可以立即输出选手平均分数</p>
<pre><code class="java">import java.util.Scanner;

public class Array &#123;
    public static void main(String[] args) &#123;
        Scanner input = new Scanner(System.in);
        double[] a = new double[6];
        int sum = 0;
        for(int i=0;i&lt;a.length;i++)&#123;
            System.out.println((i+1)+&quot;号评委打分：&quot;);
            int cj = input.nextInt();
            a[i] = cj;
            sum +=cj;

        &#125;
        System.out.println(&quot;平均分是:&quot;+(sum*1.0/6));



    &#125;



&#125;
</code></pre>
<h3 id="取最大值，最小值"><a href="#取最大值，最小值" class="headerlink" title="取最大值，最小值"></a>取最大值，最小值</h3><pre><code class="java">public class Array &#123;
    public static void main(String[] args) &#123;
       int[] cj = &#123;15,9000,10000,20000,9500,-5&#125;;
        int max = cj[0];
        int min = cj[0];
        for (int i = 1; i &lt;cj.length ; i++) &#123;
            if(max &gt; cj[i])&#123;
                continue;
            &#125;else &#123;
                max = cj[i];
            &#125;

        &#125;

        for (int i = 1; i &lt;cj.length ; i++) &#123;
            if(min &lt; cj[i])&#123;
                continue;
            &#125;else &#123;
                min = cj[i];
            &#125;

        &#125;
        System.out.println(&quot;最大时：&quot;+max);
        System.out.println(&quot;最小是:&quot;+min);



    &#125;
</code></pre>
<p>简化上面两条for循环</p>
<pre><code class="java">          for (int i = 1; i &lt;cj.length ; i++) &#123;
            if(cj[i] &gt; max)&#123;
                 max = cj[i]
                 &#125;

        &#125;

        for (int i = 1; i &lt;cj.length ; i++) &#123;
            if(cj[i] &lt; min)&#123;
                min = cj[i]
            &#125;
        &#125;

     
</code></pre>
<p>或者说直接用三木运算符</p>
<pre><code class="java"> int max = cj[0]
 for (int i = 1; i &lt;cj.length ; i++) &#123;
          max = cj[i]&gt;max?cj[i]:max;

        &#125;
</code></pre>
<h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><p>定义两个变量，一个在数组前面，一个在数组后面，遍历数组的时候前后交换</p>
<pre><code class="java">public class Array &#123;
    public static void main(String[] args) &#123;
       int[] cj = &#123;15,9000,10000,20000,9500,-5&#125;;
       for(int a=0, b=cj.length-1;a&lt;b;a++,b--)&#123;
           int num = cj[a];

           cj[a] = cj[b];

           cj[b] = num;

        &#125;

        for (int i = 0; i &lt; cj.length; i++) &#123;
            System.out.println(cj[i]);
        &#125;




    &#125;
</code></pre>
<h3 id="随机排序数组"><a href="#随机排序数组" class="headerlink" title="随机排序数组"></a>随机排序数组</h3><p>定义一个变量，取随机值，遍历数组的时候与他交换值</p>
<pre><code class="java">public class Array &#123;
    public static void main(String[] args) &#123;
        Random a = new Random();

       int[] cj = &#123;15,9000,10000,20000,9500,-5&#125;;

        for (int i = 0; i &lt; cj.length; i++) &#123;
            int num,sj;
            num = cj[i];
            sj = a.nextInt(0,cj.length);
            cj[i] = cj[sj];
            cj[sj] = num;






        &#125;

        for (int i = 0; i &lt; cj.length; i++) &#123;
            System.out.println(cj[i]);
        &#125;





    &#125;



&#125;
</code></pre>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>就是函数，被调用时，进入到栈内存中运行</p>
<pre><code>语法：

修饰符 返回值类型 方法名(形参列表)&#123;
    具体代码(需要执行的功能代码)
    return 返回值;
&#125;

如果没有返回值，返回值类型换成void，方法内不能使用return
多个形参之间用,隔开；
无返回值的方法只能直接调用，不能输入调用
</code></pre>
<h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1-n的和"></a>计算1-n的和</h3><pre><code class="java">public class Fangfa &#123;
    public static int sum(int a)&#123;
        int he = 0;
        for (int i = 1; i &lt; a+1; i++) &#123;
            he += i;
        &#125;
        return he;
    &#125;
    // 
    public static void main(String[] args) &#123;
        System.out.println(sum(6));
    &#125;
&#125;
</code></pre>
<h3 id="判断一个整数是奇数还是偶数"><a href="#判断一个整数是奇数还是偶数" class="headerlink" title="判断一个整数是奇数还是偶数"></a>判断一个整数是奇数还是偶数</h3><pre><code class="java">public class Fangfa &#123;
    public static String panduan(int a)&#123;
        if((a%2) == 0)&#123;
            return &quot;偶数&quot;;
        &#125;else&#123;
            return &quot;奇数&quot;;
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        System.out.println(panduan(3));
    &#125;
&#125;
</code></pre>
<h2 id="java的参数传递机制"><a href="#java的参数传递机制" class="headerlink" title="java的参数传递机制"></a>java的参数传递机制</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>实参传给方法就是值传递</p>
<h3 id="引用类型的参数传递"><a href="#引用类型的参数传递" class="headerlink" title="引用类型的参数传递"></a>引用类型的参数传递</h3><p>传输的是在堆内存中的地址值</p>
<pre><code class="java">public class Fangfa &#123;
    public static void chage(int [] arrs)&#123;
        System.out.println(&quot;方法内1:&quot;+arrs[1]);
        arrs[1] = 222;
        System.out.println(&quot;方法内2:&quot;+arrs[1]);
    &#125;
    public static void main(String[] args) &#123;
        int[] arrs = new int[]&#123;10,20,30&#125;;
        chage(arrs);
        System.out.println(&quot;main:&quot;+arrs[1]);
    &#125;
&#125;
</code></pre>
<h3 id="打印int类型的数组内容"><a href="#打印int类型的数组内容" class="headerlink" title="打印int类型的数组内容"></a>打印int类型的数组内容</h3><p>需求：输出一个int类型的数组内容，要求输出格式为[1,2,3,4,5]</p>
<pre><code class="java">public class Fangfa &#123;
    
    public static void main(String[] args) &#123;
        int[] a=new int[]&#123;1,2,3,4,5,8,9&#125;;
        shuchu(a);
    &#125;
    //定义方法
    public static void shuchu(int[] arrs)&#123;
        String a = &quot;&quot;;
        for (int i = 0; i &lt; arrs.length; i++) &#123;
            if(i==0)&#123;
                a += arrs[i];
            &#125;else &#123;                                   			
                a += &quot;,&quot;+arrs[i];
            &#125;
        &#125;
        System.out.println(&quot;[&quot;+a+&quot;]&quot;);
    &#125;
&#125;
//简化方法里面的代码
/* for (int i = 0; i &lt; arrs.length; i++) &#123;
            a += i==0?arrs[i]:&quot;,&quot;+arrs[i];
        &#125;*/
</code></pre>
<p>或者</p>
<pre><code class="java">public class Fangfa &#123;
    public static void main(String[] args) &#123;
        int[] a=new int[]&#123;1,2,3,4,5,8,9&#125;;
        shuchu(a);
    &#125;
    public static void shuchu(int[] arrs)&#123;
        System.out.print(&quot;[&quot;);
        for (int i = 0; i &lt; arrs.length; i++) &#123;
            System.out.print(i==0 ? arrs[i] : &quot;,&quot;+arrs[i]);
        &#125;
        System.out.println(&quot;]&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="比较两个数组是否一样"><a href="#比较两个数组是否一样" class="headerlink" title="比较两个数组是否一样"></a>比较两个数组是否一样</h3><p>需求：如果两个int类型的数组，元素个数，对应位置的元素内容都是一样的则认为这两个数组是一摸一样的</p>
<pre><code class="java">public class Fangfa &#123;
    public static void main(String[] args) &#123;
        int[] a=new int[]&#123;1,2,3,4,5,8,9&#125;;
        int[] b =&#123;1,2,3,4,5,8,9&#125;;
        System.out.println(eq(a,b));

    &#125;
    public static boolean eq(int[] arrs1, int[] arrs2)&#123;
        //判断两个数组是否都为空
        if(arrs1 == null &amp;&amp; arrs2 == null)&#123;
            return true;
        &#125;
        //判断一个数组为空的情况
        if(arrs1 ==null || arrs2 == null)&#123;
            return false;
        &#125;
        //判断数组长度是否一致
        if(arrs1.length != arrs2.length)&#123;
            return false;
        &#125;

        for (int i = 0; i &lt; arrs1.length; i++) &#123;
            if(arrs1[i] != arrs2[i])&#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;

&#125;
</code></pre>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>一个类中，出现多个方法的名称相同，但是他们的形参列表是不同的，那么这些方法就称方法重载了；</p>
<p>形参列表不同指的是：形参的个数，类型，顺序不同</p>
<h3 id="案例-开发武器系统"><a href="#案例-开发武器系统" class="headerlink" title="案例-开发武器系统"></a>案例-开发武器系统</h3><ul>
<li>默认发射一枚导弹</li>
<li>指定地区发射一枚导弹</li>
<li>指定地区发射多枚导弹</li>
</ul>
<pre><code class="java">public class Fangfa &#123;
    public static void main(String[] args) &#123;
        fire();
        fire(&quot;岛国&quot;);
        fire(&quot;岛国&quot;,10);
    &#125;


    public static void fire()&#123;
        System.out.println(&quot;发射一枚导弹&quot;);
    &#125;
    public  static void fire(String contr)&#123;
        System.out.println(&quot;向&quot;+contr+&quot;发射一枚导弹&quot;);
    &#125;

    public static void fire(String contr, int num)&#123;
        System.out.println(&quot;向&quot;+contr+&quot;发射&quot;+num+&quot;枚导弹&quot;);
    &#125;

&#125;
</code></pre>
<h2 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h2><p>可以在无返回值的方法中使用，作用是：立即跳出并结束当前方法的执行</p>
<pre><code class="java">public class Fangfa &#123;
    public static void main(String[] args) &#123;
       chufa(5,2);
    &#125;
    public static void chufa(int a, int b)&#123;
        
        //防止除数为0
        if(b == 0)&#123;
            return;
        &#125;
        System.out.println(a / b);
    &#125;
&#125;
</code></pre>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><h3 id="买飞机票"><a href="#买飞机票" class="headerlink" title="买飞机票"></a>买飞机票</h3><p><img src="/java/maifeijipiao.png" alt="image-20231010084635101"></p>
<p>方法一，switch</p>
<pre><code class="java">
import java.util.Scanner;

public class Buy &#123;
    public static void buy()&#123;
        System.out.println(&quot;请输入您所在的月份&quot;);
        Scanner input = new Scanner(System.in);
        int  mon = input.nextInt();

        switch (mon)&#123;
            case 5:
                ;
            case 6:
                ;
            case 7:
                ;
            case 8:
                ;
            case 9:
                ;
            case 10:
                System.out.println(&quot;头等舱请按1，经济舱请按2&quot;);
//                Scanner input1 = new Scanner(System.in);
                int num = input.nextInt();
                if(num == 1)&#123;
                    System.out.println(&quot;打九折&quot;);
                &#125;

                if(num == 2)&#123;
                    System.out.println(&quot;打8.5折&quot;);
                &#125;
                break;

            case 11:
                ;
            case 1:
                ;
            case 2:
                ;
            case 3:
                ;
            case 4:
                System.out.println(&quot;头等舱请按1，经济舱请按2&quot;);
//                Scanner input1 = new Scanner(System.in);
                int num2 = input.nextInt();
                if(num2 == 1)&#123;
                    System.out.println(&quot;打7折&quot;);
                &#125;

                if(num2 == 2)&#123;
                    System.out.println(&quot;打6.5折&quot;);
                &#125;
                break;
        &#125;

    &#125;
    public static void main(String[] args) &#123;
        buy();


    &#125;
&#125;
</code></pre>
<p>方法二，if</p>
<pre><code class="java">import java.util.Scanner;
public class Buy &#123;
    public static void buy()&#123;
        System.out.println(&quot;请输入您所在的月份:&quot;);
        Scanner input = new Scanner(System.in);
        int  mon = input.nextInt();

        if(5&lt;=mon &amp; mon &lt;= 10)&#123;
            System.out.println(&quot;头等舱请按1，经济舱请按2&quot;);
//                Scanner input1 = new Scanner(System.in);
            int num = input.nextInt();
            if(num == 1)&#123;
                System.out.println(&quot;打九折&quot;);
            &#125;

            if(num == 2)&#123;
                System.out.println(&quot;打8.5折&quot;);
            &#125;
        &#125;else &#123;
            System.out.println(&quot;头等舱请按1，经济舱请按2&quot;);
//                Scanner input1 = new Scanner(System.in);
            int num2 = input.nextInt();
            if(num2 == 1)&#123;
                System.out.println(&quot;打7折&quot;);
            &#125;

            if(num2 == 2)&#123;
                System.out.println(&quot;打6.5折&quot;);
            &#125;
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        buy();
    &#125;
&#125;
</code></pre>
<p>方法三</p>
<pre><code class="java">import java.util.Scanner;
//定义购买方法
public class Buy &#123;
    public static void buy()&#123;
        System.out.println(&quot;请输入您所在的月份:&quot;);
        Scanner input = new Scanner(System.in);
        int  mon = input.nextInt();

        if(5&lt;=mon &amp; mon &lt;= 10)&#123;
            js(1,input);
        &#125;else &#123;
            js(2,input);
        &#125;
    &#125;
    
    public static void js(int a,Scanner input)&#123;
        if(a == 1)&#123;
            System.out.println(&quot;头等舱请按1，经济舱请按2&quot;);
//                Scanner input1 = new Scanner(System.in);
            int num = input.nextInt();
            if(num == 1)&#123;
                System.out.println(&quot;打9折&quot;);
                System.out.println(&quot;求输入原票价：&quot;);
                int num1 = input.nextInt();         //每让用户输入一次，重新设置一个变量接受
                System.out.println(num1*0.9);
            &#125;
            if(num == 2)&#123;
                System.out.println(&quot;打8.5折&quot;);
                System.out.println(&quot;求输入原票价：&quot;);
                int num2 = input.nextInt();
                System.out.println(num2*0.85);
            &#125;
        &#125;
        if(a == 2)&#123;
            System.out.println(&quot;头等舱请按1，经济舱请按2&quot;);
//                Scanner input1 = new Scanner(System.in);
            int num = input.nextInt();
            if(num == 1)&#123;
                System.out.println(&quot;打7折&quot;);
                System.out.println(&quot;求输入原票价：&quot;);
                int num1 = input.nextInt();
                System.out.println(num1*0.7);
            &#125;
            if(num == 2)&#123;
                System.out.println(&quot;打6.5折&quot;);
                System.out.println(&quot;求输入原票价：&quot;);
                int num2 = input.nextInt();
                System.out.println(num2*0.65);

            &#125;
        &#125;
    &#125;


    //主函数运行
    public static void main(String[] args) &#123;
        buy();
    &#125;
&#125;
</code></pre>
<h3 id="开发验证码"><a href="#开发验证码" class="headerlink" title="开发验证码"></a>开发验证码</h3><p><img src="/java/%E9%AA%8C%E8%AF%81%E7%A0%81.png"></p>
<p>提示：大小写字母可以用ASCII，通过数字，使用类型转换为字母</p>
<pre><code class="java">import java.util.Random;
public class Yanzhengma &#123;
    public static String sj(int c)&#123;
        Random num = new Random();
        String yzm = &quot;&quot;;
        for (int i = 1; i &lt;= c; i++) &#123;
            int num1 = num.nextInt(3);
            switch (num1)&#123;
                case 0:
                    int num2 = num.nextInt(0,10);
                    yzm += num2;

                    break;
                case 1:
                    int num3 =  num.nextInt(65,91);     //随机一个大写字母
                    char dx = (char)num3;
                    yzm += dx;
                    break;
                case 2:
                    int num4 = num.nextInt(97,123);
                    char xx = (char)num4;
                    yzm += xx;
                    break;
            &#125;
        &#125;
        return yzm;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(sj(4));

    &#125;
&#125;
</code></pre>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol>
<li>类中成员变量本身存在默认值</li>
<li>一个代码文件中可以写多个class类，但只能一个用public修饰；且public修的类名必须成为代码文件名</li>
<li>当堆内存中的对象没有被任何比变量引用时（s1 &#x3D; null；），就会被判为垃圾对象，java存在自动垃圾回收机制，会自动清除垃圾对象。</li>
</ol>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this就是一个变量，可以在当前方法中，来拿到当前对象。</p>
<p>用来解决对象的成员变量 与方法内部的的变量名称相同时，导致访问冲突问题的</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>定义一个类时，可以定义与类名相同名字的方法,里面的形参不一样就可以，定义的方法就叫构造方法</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Student new1 = new Student();   //现在就是使用的无参构造方法
        Student new2 = new Student(&quot;123&quot;);  //有参数构造方法
    &#125;
&#125;
</code></pre>
<ol>
<li>类在设计时，如果不写构造器，java是会为类自动生成一个无参构造器；</li>
<li>一旦定义了一个有参数构造器，java就不会再帮我们的类自动生成无参构造器了，此时就建议自己手写一个无参构造器出来了</li>
</ol>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>合理暴露，合理隐藏</p>
<table>
<thead>
<tr>
<th>访问控制符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程（项目）</th>
</tr>
</thead>
<tbody><tr>
<td>privvate</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>可以设置private属性的成员变量，对象不能直接调用某些成员变量，保证变量的私有性</p>
<pre><code class="java">package com.xuexi;

public class Test&#123;
    private int sorce;
    //  定义一个方法给sorce赋值
    public void setSorce(int sc)&#123;
        if(sc&gt;=0 &amp; sc &lt;= 100)&#123;
            this.sorce = sc;
        &#125;else&#123;
            System.out.println(&quot;数据错误&quot;);
        &#125;
    &#125;
    //  定义方法获取sorce的值
    public int getSorce()&#123;
        return this.sorce;
    &#125;

    public static void main(String[] args) &#123;
        Test num = new Test();
        num.setSorce(80);
        System.out.println(num.getSorce());
    &#125;
&#125;
</code></pre>
<h3 id="实体Javabean"><a href="#实体Javabean" class="headerlink" title="实体Javabean"></a>实体Javabean</h3><p>什么是实体类（保存数据）</p>
<ol>
<li>这个类中的成员变量都要私有，并且要对外提供相应的getXXX，setXXX方法</li>
<li>类中必须要有一个公共的无参构造器</li>
</ol>
<p>实体类，存储数据</p>
<pre><code class="java">package com.xuexi;

public class Student &#123;
  private String name;
  private int age;

    public Student() &#123;
    &#125;
    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;

&#125;
</code></pre>
<p>处理数据类</p>
<pre><code class="java">package com.xuexi;
public class Studentopration &#123;
    private Student st;

    public Studentopration() &#123;
    &#125;

    public Studentopration(Student st)&#123;
        this.st = st;
    &#125;
    public void ff()&#123;
        System.out.println(&quot;这个人是&quot;+st.getName()+&quot;，他&quot;+st.getAge()+&quot;岁了&quot;);
    &#125;
&#125;
</code></pre>
<p>使用</p>
<pre><code class="java">package com.xuexi;

public class Test&#123;
    public static void main(String[] args) &#123;
        Student n1 = new Student(&quot;小美&quot;,20);
        Studentopration n2 = new Studentopration(n1);
        n2.ff();

    &#125;
&#125;
</code></pre>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="使用包的注意事项"><a href="#使用包的注意事项" class="headerlink" title="使用包的注意事项"></a>使用包的注意事项</h3><ol>
<li>调用自己所在包下的其他程序，可以直接调用</li>
<li>调用其他包下的程序，必须在当前程序中导包，才可以访问（import 包名.类名）</li>
<li>java.lang下的包可以直接使用</li>
<li>要调用多个不同包下的程序，而且这些程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包访问</li>
</ol>
<h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>两种定义方式</p>
<pre><code>String str = &quot;abc&quot;;
</code></pre>
<pre><code>char[] data = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
String str = new String(data);
</code></pre>
<h4 id="常用String构造器"><a href="#常用String构造器" class="headerlink" title="常用String构造器"></a>常用String构造器</h4><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String(string original)</td>
<td>根据传入的字符串内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chars)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] bytes)</td>
<td>根据字节数组的内容 来创建字符串对象</td>
</tr>
</tbody></table>
<h4 id="String常用的方法"><a href="#String常用的方法" class="headerlink" title="String常用的方法"></a>String常用的方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int length()</td>
<td>获取字符串的长度返回</td>
</tr>
<tr>
<td>public char charAt(int index)</td>
<td>获取某个索引位置处的字符返回</td>
</tr>
<tr>
<td>public char[] toCharArray()</td>
<td>将当前字符串转换成字符数组返回</td>
</tr>
<tr>
<td>public boolean equals(Object anObject)</td>
<td>判断当前字符串与另一个字符串的内容一样，一样返回true</td>
</tr>
<tr>
<td>public boolean  equalsIgnoreCase(String anotherString)</td>
<td>判断房钱字符串与另一个字符串的内容是否一样，忽略大小写</td>
</tr>
<tr>
<td>public String substring(int beginIndex, int endIndex)</td>
<td>根据开始和结束索引进行截取，得到新的字符串（左闭右开）</td>
</tr>
<tr>
<td>public String substring(int beginindex)</td>
<td>从传入的索引处截取，截取到末尾，得到新的字符串</td>
</tr>
<tr>
<td>public String replace(CharSequence target, CharSequence replacement)</td>
<td>使用新值，将字符串中的旧值替换，得到新的字符串；（旧，新）</td>
</tr>
<tr>
<td>public boolean contains(CharSequence s)</td>
<td>判断字符串中是否包含了某个字符串</td>
</tr>
<tr>
<td>public boolean startWith(String prefix)</td>
<td>判断字符串是否按照某个字符串内容开头，正确返回true</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td>把字符串按照某个指定内容分割，返回字符串数组</td>
</tr>
</tbody></table>
<h3 id="用户登录验证"><a href="#用户登录验证" class="headerlink" title="用户登录验证"></a>用户登录验证</h3><pre><code class="java">public class Test&#123;
    public static void main(String[] args) &#123;

        String uname = &quot;cuijian&quot;;
        String passwd = &quot;cjwl123...&quot;;
        yanzheng(uname,passwd);
    &#125;
    public static void yanzheng(String na, String pd)&#123;
        int num = 1; ///计数，登陆三次失败退出
        Scanner input = new Scanner(System.in);
        while (true)&#123;
            System.out.println(&quot;输入用户名：&quot;);
            String uname = input.next();
            System.out.println(&quot;请输入密码:&quot;);
            String passwd = input.next();
            if(na.equals(uname) &amp;&amp; pd.equals(passwd))&#123;
                System.out.println(&quot;登陆成功...&quot;);
                break;
            &#125;else &#123;
                if (num == 3)&#123;
                    System.out.println(&quot;失败次数过多，强制推出&quot;);
                    break;
                &#125;
                System.out.println(&quot;账号或密码错误,请重新登录&quot;);
                num++;
                continue;
            &#125;
        &#125;

    &#125;
&#125;
</code></pre>
<h3 id="集合ArrayList"><a href="#集合ArrayList" class="headerlink" title="集合ArrayList"></a>集合ArrayList</h3><p>集合容器中存储的是每个对象在堆内存中的地址</p>
<p>类似于数组，可变长度，可以选择限制数据类型</p>
<p>定义</p>
<pre><code>使用无参构造器：
ArrayList 变量 = new ArrayList();   //允许存储各种类型的数据
定义一个只允许存储整形的集合
ArrayList&lt;int&gt; num = new ArrayList&lt;int&gt;();
</code></pre>
<h4 id="常用方法名"><a href="#常用方法名" class="headerlink" title="常用方法名"></a>常用方法名</h4><table>
<thead>
<tr>
<th>常用方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean add(E e)</td>
<td>将指定的元素添加到此集合的末尾</td>
</tr>
<tr>
<td>public void add(int index, E element)</td>
<td>将指定的元素添加到指定的位置</td>
</tr>
<tr>
<td>public E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中元素的个数</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>public boolean remove(Object o)</td>
<td>删除指定的元素，返回删除是否成功（删除索引值最靠前的）</td>
</tr>
<tr>
<td>public E set(int index, E element)</td>
<td>修改指定索引处的元素值</td>
</tr>
</tbody></table>
<h4 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h4><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><pre><code class="java">        ArrayList&lt;String&gt; arrayList = new ArrayList();
        Collections.addAll(arrayList,&quot;A&quot;,&quot;2&quot;,&quot;&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;);
        Collections.shuffle(arrayList);

        //foreach循环遍历
        for (String arr: arrayList) &#123;
            System.out.print(arr+&quot;\t&quot;);
        &#125;



    &#125;
</code></pre>
<h5 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h5><pre><code class="java">        //Iterator循环遍历
        Iterator iterator =arrayList.iterator();
        while (iterator.hasNext())&#123; //hasNext()判断当前指针是否有数据
            System.out.print(iterator.next()+&quot;\t&quot;); //iterator.next()指针下移
        &#125;
</code></pre>
<h2 id="集合和泛型都不支持引用数据类型"><a href="#集合和泛型都不支持引用数据类型" class="headerlink" title="集合和泛型都不支持引用数据类型"></a>集合和泛型都不支持引用数据类型</h2><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态，可修饰成员变量、方法</p>
<h3 id="成员变量有无static修饰"><a href="#成员变量有无static修饰" class="headerlink" title="成员变量有无static修饰"></a>成员变量有无static修饰</h3><ol>
<li><p>类变量：有static修饰，属于类，会被类的全部对象共享     &#x2F;&#x2F;类名.类变量（访问）</p>
</li>
<li><p>实例变量：无static修饰，属于实例化的每个对象</p>
<pre><code>public static String name;
</code></pre>
</li>
</ol>
<h3 id="成员方法有无static修饰"><a href="#成员方法有无static修饰" class="headerlink" title="成员方法有无static修饰"></a>成员方法有无static修饰</h3><p>同成员变量</p>
<p>类方法多用来做工具，也称工具类</p>
<p>工具类么有创建对象的需求，建议将工具类的构造器进行私有</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块是类的5大成分之一（成员变量，构造器，方法，代码块，内部类）</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul>
<li>格式：static{}</li>
<li>特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次</li>
<li>作用：完成类的初始化，例如：对类变量的初始化赋值</li>
</ul>
<pre><code class="java">public class Test&#123;
    static String name = &quot;对象&quot;;
   static &#123;
       System.out.println(&quot;我最先被加载&quot;);
   &#125;

    public static void main(String[] args) &#123;
        System.out.println(Test.name);
    &#125;

&#125;
</code></pre>
<h3 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h3><ul>
<li>格式：{}</li>
<li>特点：每次创建对象时，执行实例代码块，并在构造器之前执行</li>
<li>作用：和构造器一样，都是用来完成对象的初始化，例如：对实例变量进行初始化赋值</li>
</ul>
<pre><code class="java">public class Test&#123;
   Test()&#123;
       System.out.println(&quot;无参构造器&quot;);
   &#125;

    &#123;
        System.out.println(&quot;实例代码块&quot;);
    &#125;
    
    public static void main(String[] args) &#123;
        Test s1 = new Test();
    &#125;
&#125;
</code></pre>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul>
<li>把类的构造器私有</li>
<li>定义一个类变量记住类的一个对象</li>
<li>定义一个类方法，返回对象</li>
</ul>
<p>饿汉式单例：调用之前就创建好的</p>
<pre><code class="java">public class Test&#123;
    //私有构造器
    private Test()&#123;

    &#125;
//    类变量记住类的一个对象
    private static  Test test = new Test();
//  类方法，返回对象
    public static Test  getTest()&#123;
        return test;
    &#125;

&#125;
</code></pre>
<p>饱汉式单例：调用时，才创建对象</p>
<pre><code class="java">public class Test&#123;
    //私有构造器
    private Test()&#123;

    &#125;
    //    类变量记住类的一个对象
    private static  Test test;
    //  定义一个类方法，创建和返回对象
    public static Test  getTest()&#123;
        if (test == null)&#123;
            test = new Test();
        &#125;
        return test;
    &#125;

&#125;
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>子类能继承父类的非私有成员（成员变量、成员方法）</li>
<li>子类的对象是由子类、父类共同完成</li>
</ul>
<pre><code>public class B extends A&#123;
    
&#125;

B是子类
A是父类
</code></pre>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super()关键字"></a>super()关键字</h3><p>在子类中可以使用super()关键字访问父类的变量和方法</p>
<h3 id="子类构造器的特点"><a href="#子类构造器的特点" class="headerlink" title="子类构造器的特点"></a>子类构造器的特点</h3><p>子类的全部构造器，都会先调用父类的构造器，在执行自己的</p>
<p>原因：子类的构造器，都默认有super()（如果父类没有无参构造器，必须在子类中的构造器中手写super()）;</p>
<pre><code class="java">class St1&#123;
    public St1()&#123;
    &#125;
    public St1(String s)&#123;
    &#125;
&#125;

class St2 extends St1&#123;
   public St2()&#123;

   &#125;
&#125;
</code></pre>
<pre><code class="java">class St1&#123;
 /*   public St1()&#123;
    &#125;*/
    public St1(String s)&#123;
    &#125;
&#125;

class St2 extends St1&#123;
   public St2(String s)&#123;
       super(s);

   &#125;
&#125;
</code></pre>
<h3 id="this-调用兄弟构造器"><a href="#this-调用兄弟构造器" class="headerlink" title="this()调用兄弟构造器"></a>this()调用兄弟构造器</h3><pre><code class="java">    public S1(String name,int age,String sex)&#123;
        this.name = name;
        this.age = age;
        this.sex = sex;
    &#125;
    public S1(String name,int age)&#123;    
        this(name,age,&quot;男&quot;); //this()调用兄弟构造器
    &#125;
</code></pre>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>在本类中</th>
<th>在同一个包的其他类里</th>
<th>任意包下的子类里</th>
<th>任意包下的任意类里</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类继承父类后，子类可以重写一个方法名称，参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写；</p>
<p>重写后，方法的访问遵循就近原则</p>
<ul>
<li>使用@Override注解，检查我们的格式是否正确，代码的可读性也会更好</li>
<li>子类重写父类方法时，访问权限必须大于或等于该父类的访问权限</li>
<li>重写方法的返回值类型，必须与被重写方法的返回值类型一样，或者范围更小</li>
<li>私有方法、静态方法不能被重写</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态实在继承&#x2F;实现情况下的一种现象，表现为对象多态、行为多态。</p>
<p>子类继承父类就是对象多态；</p>
<p>子类重写父类方法就是方法多态。</p>
<pre><code>方法有多态，变量没有
S1 s  = new S2();
s.run(); //编译看左边，运行看右边---行为多态
s.name; //编译、运行都看左边---变量没有多态
</code></pre>
<h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol>
<li>在多态形势下，右边对象是解耦合的，更利于维护和扩展</li>
<li>定义方法时，使用父类类型的形参，可以接受一切子类对象</li>
</ol>
<h3 id="多态的缺点"><a href="#多态的缺点" class="headerlink" title="多态的缺点"></a>多态的缺点</h3><ul>
<li>多态下不能使用子类特有的功能（方法）</li>
</ul>
<pre><code>可以通过强制类型转换，实现特有方法
People p = new Student();
Student stu2 = (Student)p;  //进行类型转换，只能是相同类型的子类进行转换

可以使用instanceof关键字进行判断,在进行强制类型转换
p instanceof Student
if(p instanceof Student)&#123;
    代码;
&#125;
</code></pre>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul>
<li><p>修饰类：该类被称为最终类，不能被继承</p>
<pre><code>static final同时修饰一个变量，就称为常量，且必须赋值

public static final String name = &quot;名字&quot;
</code></pre>
<pre><code>final修饰的是基本类型的变量时，内容不能被改变
final修饰的是引用类型的变量时，地址不能改变，内容可以改变
</code></pre>
</li>
<li><p>修饰方法：该方法被称为最终方法，不能被重写</p>
</li>
<li><p>修饰变量：该变量只能被赋值一次</p>
</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法（不能有方法体）</p>
<ul>
<li>抽象类中不一定有抽象方法、有抽象方法的类一定是抽象类</li>
<li>类该有的成员（成员变量、方法、构造器）抽象类都可以有</li>
<li>抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。</li>
<li>一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义为抽象类</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code class="java">public interface 接口名&#123;
    成员变量;//常量
    成员方法;// 抽象方法
&#125;
</code></pre>
<p>注意：接口不能创建对象；接口是用来实现的，关键字implements，实现接口的类称为实现类</p>
<pre><code class="java">修饰符 class 实现类 implements 接口1,接口2,...&#123;
    
&#125;
</code></pre>
<h3 id="JDK8后接口增加的三种形式"><a href="#JDK8后接口增加的三种形式" class="headerlink" title="JDK8后接口增加的三种形式"></a>JDK8后接口增加的三种形式</h3><pre><code class="java"> default void test1()&#123;
        /*使用default修饰，默认会被加上public修饰，只能使用接口的实现类对象调用
        * */
        System.out.println(&quot;方法体&quot;);
    &#125;
</code></pre>
<pre><code class="java">  /*私有方法：必须使用private修饰，JDK9才开始支持，只能在接口内调用
    * */
    private  void  test3()&#123;

    &#125;
</code></pre>
<pre><code class="java">   /*类方法（静态方法）使用static修饰，默认会被加上public修饰，只能使用接口名来调用
    * */
    static void test4()&#123;

    &#125;
</code></pre>
<h3 id="使用接口的注意事项"><a href="#使用接口的注意事项" class="headerlink" title="使用接口的注意事项"></a>使用接口的注意事项</h3><p>一个接口可以继承多个接口</p>
<pre><code class="java">interface B&#123;&#125;
interface C&#123;&#125;

interface D extends B,C&#123;
    
&#125;
</code></pre>
<ol>
<li>一个接口继承多个接口，如果多个接口中存在方法签名冲突，则不支持多继承</li>
<li>一个类实现多个接口，如果多个接口中存在方法签名冲突，则不支持多实现</li>
<li>一个类继承了父类，又同时实现了接口，父类中和接口中有同名方法，类会优先用父类的</li>
<li>一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可</li>
</ol>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类中可以定义静态成员（JDK16后才支持）</p>
<pre><code class="java">public class Student &#123;
    public  class A&#123;

    &#125;
&#125;
</code></pre>
<p>调用</p>
<pre><code class="java"> public static void main(String[] args) &#123;
        Student.A a = new Student().new A();
    &#125;
</code></pre>
<p>访问内部类的成员变量</p>
<pre><code class="java">public class Student &#123;
    private int age = 99;
    public  class A&#123;
        private int age = 66;

        public void test()&#123;
            int age = 33;
            System.out.println(age);            //33
            System.out.println(this.age);          //66
            System.out.println(Student.this.age);   //外部类访问：99
        &#125;

    &#125;
&#125;
</code></pre>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="java">public  class Student &#123;
    private int age = 99; //实例成员
    public  void t()&#123;
        System.out.println();
    &#125;
    public static class A&#123;
        private int age = 66;

        public  void test()&#123;
            int age = 33;
            System.out.println(age);            //33
            System.out.println(this.age);          //66
            //静态成员无法访问实例成员
        &#125;

    &#125;
&#125;
</code></pre>
<p>调用（与静态成员的调用方法一致）</p>
<pre><code class="java">   public static void main(String[] args) &#123;
        Student.A a = new Student.A();
    &#125;
</code></pre>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>就是一种特殊的局部内部类：所谓匿名，指的是程序员不需要为这个类声明名字</p>
<pre><code class="java">public class Test&#123;
    public static void main(String[] args) &#123;
        A a = new A() &#123;   //匿名内部类，实际上就是把这个匿名内部类编译成了一个子类
            @Override
            public void cry() &#123;
                System.out.println(&quot;子类实现&quot;);
            &#125;
        &#125;;
        a.cry();
    &#125;


&#125;

interface A&#123;
    void cry();
&#125;
</code></pre>
<p>匿名内部类在开发中的使用场景：通常作为一个参数传递给方法</p>
<pre><code class="java">public class Test&#123;
    public static void main(String[] args) &#123;
        Swim dog = new Swim() &#123;
            @Override
            public void swim() &#123;
                System.out.println(&quot;狗游泳&quot;);
            &#125;
        &#125;;
        go(dog);
        //等同于
        go(new Swim() &#123;
            @Override
            public void swim() &#123;
                System.out.println(&quot;狗游泳&quot;);

            &#125;
        &#125;);
    &#125;
    public static void go(Swim s)&#123;
        s.swim();
    &#125;
&#125;
interface Swim&#123;
    void swim();
&#125;
</code></pre>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>一种特殊的类</p>
<pre><code>格式：
修饰符 enum 枚举类名&#123;
    名称1,名称2...;
    其他成员
&#125;

注意：枚举类第一行必须罗列的是枚举对象的名字，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象。
</code></pre>
<pre><code class="java">public enum Class &#123;
    X,Y,Z;
    
&#125;

//实际上的X,Y,Z

/*
public static final A X = new A();
public static final A Y = new A();
public static final A Z = new A();
*/
</code></pre>
<ol>
<li>枚举类第一行必须罗列的是枚举对象的名字，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象。</li>
<li>枚举类的构造器都是私有的，因此枚举类对外不能够创建对象</li>
<li>枚举类都是最终类，不能被继承</li>
<li>枚举类中，从第二行开始，可以定义类的其他各种成员</li>
<li>编译器为枚举新增了几个方法，并且枚举都是继承：java.lang.Enum类，从enum类也会继承到一些方法</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        Class x = Class.X;
        Class[] values = Class.values();  //拿到枚举类的全部对象，返回一个数组
        for (Class value : values) &#123;
            System.out.println(value);
        &#125;

    &#125;
</code></pre>
<h3 id="抽象枚举"><a href="#抽象枚举" class="headerlink" title="抽象枚举"></a>抽象枚举</h3><pre><code>枚举类中定义一个抽象方法，在第一行罗列的对象中重写抽象方法
</code></pre>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code>修饰符 class 类名&lt;类型变量,类型变量,...&gt;&#123;
    
&#125;
</code></pre>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code>修饰符 interfce 接口名&lt;类型变量,类型变量,...&gt;&#123;
    
&#125;
</code></pre>
<pre><code class="java">public interface A&lt;E&gt;&#123;
    
&#125;
</code></pre>
<pre><code class="java">//定义一个泛型接口，添加不同的数据
interface A&lt;E&gt;&#123;
    void add(E d); 
    ArrayList&lt;E&gt; getName(String name);   
    
&#125;
//教师类实现接口
class TeacherDate implements A&lt;TeacherDate&gt;&#123;

    @Override
    public void add(TeacherDate d) &#123;
        
    &#125;

    @Override
    public ArrayList&lt;TeacherDate&gt; getName(String name) &#123;
        return null;
    &#125;
&#125;

//学生类实现接口
class StudentDate implements A&lt;StudentDate&gt;&#123;

    @Override
    public void add(StudentDate d) &#123;
        
    &#125;

    @Override
    public ArrayList&lt;StudentDate&gt; getName(String name) &#123;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code>修饰符&lt;类型变量,类型变量,...&gt; 返回值类型 方法名(形参列表)&#123;
    
&#125;
</code></pre>
<pre><code class="java">public static &lt;T&gt; T test(T t)&#123;
    return t;
&#125;
</code></pre>
<p>注意</p>
<pre><code class="java">//这种不是泛型方法，这是泛型类给的数据类型
public E getIndex(int n)&#123;
    return (E)n;
&#125;
</code></pre>
<pre><code class="java">//? 是通配符，在使用泛型的时候代表一切类型  ? extends Car:代表上限，必须是Car或者Car的子类
//									 ? super Car:代表下限，必须是Car或者Car的父类
public static void go(ArrayList&lt;? extends Car&gt; cars)&#123;
    
&#125;


/*
上面代码等同于下面
public static &lt;T extends Car&gt; void go(ArrayList&lt;T&gt; cars)&#123;	
&#125;
*/
</code></pre>
<h3 id="泛型的注意事项"><a href="#泛型的注意事项" class="headerlink" title="泛型的注意事项"></a>泛型的注意事项</h3><ol>
<li>泛型是工作在编译阶段的，一旦编译为class文件，class中就不存在泛型了，这就是泛型擦除</li>
<li>泛型不支持基本数据类型，只支持对象类型（引用数据类型）</li>
</ol>
<h2 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>是一切类的父类</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code class="java">public String toString():返回对象的字符串表示形式
     @Override
     public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
</code></pre>
<pre><code class="java">public boolean equals(Object o): //判断两个对象是否相等，会先判断变量是否为空
     @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age &amp;&amp; Objects.equals(name, student.name);
    &#125;
</code></pre>
<pre><code class="java">protected Object clone():对象克隆
//默认拷贝的都是地址，是浅拷贝
想要克隆，被克隆的类的对象要先实现一个接口：Cloneable
    public  class Student implements Cloneable
在重写clone()方法
  protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
</code></pre>
<pre><code>对象中基本类型的数据直接拷贝
对象中字符串数据拷贝的还是地址
对象中还包含的其他对象，不会拷贝地址，会创建新对象


//深克隆的方法，就是在原有重写的基础上，把引用类型的变量重新拷贝一份，重新赋值
</code></pre>
<pre><code class="java">   //深克隆
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Student clone = (Student) super.clone();
        clone.abl = clone.abl.clone();
        return clone;

    &#125;
</code></pre>
<h3 id="Objects工具类的常用方法"><a href="#Objects工具类的常用方法" class="headerlink" title="Objects工具类的常用方法"></a>Objects工具类的常用方法</h3><pre><code class="java">//public static boolean equals(object a, Object b):先做判断，在比较两个对象

public static boolean equals(Object a, Object b) &#123;
        return (a == b) || (a != null &amp;&amp; a.equals(b));
    &#125;
</code></pre>
<pre><code>public static boolean isNull(Object obj):判断对象是否为null，为null返回true
</code></pre>
<pre><code>public staticc boolean nonNull(Object obj):判断对象是否不为Null，不为Null返回true
</code></pre>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<pre><code class="java">Integer i = Integer.valueOf(12);//包装类的有参构造器都过时了，用他们的静态方法来创建对象；

//java的包装类都有自动装箱机制，自动把基本类型的数据转为对象
Integer i = 12;//等同于上面代码
</code></pre>
<pre><code class="java">//自动拆箱，自动把包装类型的对象转换成基本数据类型
int a = i;
</code></pre>
<p>包装类的常用操作</p>
<ol>
<li><p>可以把基本类型的数据转换为字符串类型</p>
<pre><code>静态方法：
    public static String tiString(基本数据类型)
实例方法：
    public String toString()
</code></pre>
</li>
<li><p>可以把字符串类型的数值转换成数值本身对应的数据类型</p>
<pre><code class="java">public static int parsenlnt(String s)
public static Integer valueOf(String s) //包装类通用
</code></pre>
</li>
</ol>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>操作字符串的容器，比String更适合做字符串修改，效率更高</p>
<p>构造器</p>
<pre><code>StringBuilder():创建一个空白的可变的字符串对象，不包含任何内容
</code></pre>
<pre><code>StringBuilder(String str)：创建一个指定字符串内容的可变字符串对象
</code></pre>
<p>方法</p>
<pre><code>StringBuilder append():追加各种的数据类型到字符串中
</code></pre>
<pre><code class="java">StringBuilder reverse():将对象的内容反转
</code></pre>
<pre><code class="java">int length():返回对象的内容长度
</code></pre>
<pre><code>String toString():通过toString()方法将StringBuilder对象转为字符串
</code></pre>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>用法与StringBuilder一样，但是Buffer是线程安全的。</p>
<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><p>JDK8之后才有的，拼接字符串更加简洁高校</p>
<p>常用构造器</p>
<pre><code>StringJoiner(间隔符)：创建一个Stringjoiner对象 ，指定拼接时的间隔符
</code></pre>
<pre><code>StringJoiner(间隔符,开始符号,结束符号):指定开始，结束，间隔符
</code></pre>
<p>常用方法</p>
<pre><code>Stringjoiner add(添加的内容)：添加数据,返回对象本身
</code></pre>
<pre><code>int length():返回长度
</code></pre>
<pre><code>String toString():将结果以字符串形式返回
</code></pre>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>工具类，常用的静态方法</p>
<pre><code>public static int abs(int a):获取参数的绝对值
</code></pre>
<pre><code>public static double ceil(double a):向上取整
</code></pre>
<pre><code>public static double floor(double a):向下取整
</code></pre>
<pre><code>public static int round(float a):四舍五入
</code></pre>
<pre><code>public static int max(int a ,int b):获取两个int值中的最大值
</code></pre>
<pre><code>public static int min(int a, int b):获取两个int值中的最小值
</code></pre>
<pre><code>public static double pow(double a,double b):返回a的b次幂
</code></pre>
<pre><code>public static double random():返回double的随机值[0.0,1.0&#125;
</code></pre>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>代表程序所在的系统，也是一个工具类</p>
<p>常用方法</p>
<pre><code>public static void exit(int status):终止当前运行的虚拟机
</code></pre>
<pre><code>public static long currenTimeMillis():返回当前系统时间的毫秒值形式
</code></pre>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>是一个单例类，具体方法可在API文档中查看</p>
<p>常用方法</p>
<pre><code>public static Runtime getRuntime():返回当前java程序关联的运行时对象
</code></pre>
<pre><code>public void exit(int status):终止当前运行的虚拟机，按照惯例，非零状态码表示异常终止
</code></pre>
<pre><code>public int availableProcessors():返回java虚拟机可用的处理出数
</code></pre>
<pre><code>public long totalMemory(): 返回java虚拟机中的内存总量
</code></pre>
<pre><code>public long freeMemory():返回java虚拟机中的可用内存量
</code></pre>
<pre><code>public Process exec(String command)：启动某个程序，并返回代表该程序的对象
</code></pre>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>解决浮点型运算时，结果出现失真的问题</p>
<p>常用构造器</p>
<pre><code>public BigDecimal(double val)：将double转换为BigDecimal//不推荐
</code></pre>
<pre><code>public BigDecimal(String):把String转换为BigDecimal
</code></pre>
<p>常用方法</p>
<pre><code>public static BigDecimal valueOf(double val) :将double转换为BigDecimal
</code></pre>
<pre><code>public BigDecimal add(BigDecimal b):加法
</code></pre>
<pre><code>public BigDecimal subtract(BigDecimal b):减法
</code></pre>
<pre><code>public BigDecimal multiply(BigDecimal b):乘法
</code></pre>
<pre><code>public BigDecimal divide(BigDecimal b):除法
</code></pre>
<pre><code>public BigDecimal divide(另一个BigDecimal对象,精确几位,舍入模式):除法，可以精确控制到小数几位
</code></pre>
<pre><code>public double doubleValue():返回一个double
</code></pre>
<h2 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h2><h3 id="JDK8之前的日期时间"><a href="#JDK8之前的日期时间" class="headerlink" title="JDK8之前的日期时间"></a>JDK8之前的日期时间</h3><h3 id="Date：时间日期类"><a href="#Date：时间日期类" class="headerlink" title="Date：时间日期类"></a>Date：时间日期类</h3><pre><code class="java">Date time = new Date();//无参构造器
Date time = new Date(long time);//有参构造器，时间戳
</code></pre>
<h3 id="SimpleDateFormat：格式化时间"><a href="#SimpleDateFormat：格式化时间" class="headerlink" title="SimpleDateFormat：格式化时间"></a>SimpleDateFormat：格式化时间</h3><p>构造器</p>
<pre><code>public SimpleDateFormat(String pattern)：创建简单日期格式化对象，并封装时间的格式
</code></pre>
<p>格式化时间的方法</p>
<pre><code>public final String format(Date date):将日期格式化成日期/时间字符串

public final String format(Object time)：将时间戳格式化成日期/时间字符串
</code></pre>
<pre><code>SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E a&quot;);
String s = simpleDateFormat.format(time);
System.out.println(s);


输出：
2024年01月30日 16:09:07 周二 下午
</code></pre>
<p>解析字符串对象成为日期对象，指定的时间格式必须与被解析的时间格式一样</p>
<pre><code class="java">        String dateStr = &quot;2024-01-30 16:16:16&quot;;
        SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date parse = sf.parse(dateStr);
        System.out.println(parse);
</code></pre>
<h3 id="JDK8之后的日期"><a href="#JDK8之后的日期" class="headerlink" title="JDK8之后的日期"></a>JDK8之后的日期</h3><pre><code>LocalDate：年月日
LocalTime：时，分，秒
LocalDateTime：年月日，时分秒

修改：with
增加：puls
减：minus

.now():获取当前时间
.of():获取指定时间
</code></pre>
<pre><code>ZoneId:时区
    ZoneId.systemDefalult():获取系统的默认时区
ZoneDateTime：带时区的时间
    ZoneDateTime.now(Clock.systemUTC()):世界标准时间，零时区的时间
</code></pre>
<pre><code>Instant：时间戳
</code></pre>
<pre><code>DateTimeFormatter：用于时间的格式化和解析
</code></pre>
<pre><code>Period：时间间隔（年月日）
    

Duration：时间间隔（时分秒，纳秒）
</code></pre>
<h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><pre><code class="java">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);//定义格式

        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);

        String format = dateTimeFormatter.format(now);//格式化相应的时间
        System.out.println(format);
</code></pre>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>用于操作数组的工具类</p>
<p>常用方法</p>
<blockquote>
<p>public static String toString(类型[] arr):返回数组的内容</p>
</blockquote>
<blockquote>
<p>public static int[] copyOfRange(类型[] arr,起始索引,结束索引):拷贝数组（指定范围）</p>
</blockquote>
<blockquote>
<p>public static copyOf(类型[] arr,int newLength):拷贝数组，指定新数组的长度</p>
</blockquote>
<blockquote>
<p>public static setAll(double[] array,intToDoubleFunction generator):把数组中的原数据改为新数据</p>
</blockquote>
<blockquote>
<p>public static setAll(double[] array,intToDoubleFunction generator):把数组中的原数据改为新数据</p>
</blockquote>
<blockquote>
<p>Arrays.asList()：将数组转换为集合(List)，实际返回的是<code>java.util.Arrays.ArrayList</code>，通常作为一个参数配合ArrayList的构造方法或者addALL ()方法使用</p>
</blockquote>
<p>两种方式实现sort的自定义排序</p>
<p>方法一</p>
<pre><code>让该对象的类实现Comparable(比较规则)接口，然后重写comparableTo方法，自己定义比较规则
</code></pre>
<pre><code class="java">//默认是升序
public  class Student implements Comparable&lt;Student&gt;&#123;
    @Override
    public int compareTo(Student o) &#123;
        /*if (this.age &gt; o.age)&#123;
            return 1;
        &#125; else if (this.age&lt;o.age) &#123;
            return -1;
        &#125;
        return 0;
        默认是升序排序，排序规则如下：
        1：左边大于右边，返回整数
        2：左边小于右边，返回负数
        3：左边等于右边，返回0
        
        */
        
        return this.age - o.this;
        
    &#125;
&#125;
</code></pre>
<p>方法二</p>
<pre><code>使用下面这个sort方法，创建Comparabletor比较器接口的匿名内部类对象，然后自己指定排序规则
public static &lt;T&gt; void sort(T[] arr,Comparabletor&lt;?super T&gt;c)
</code></pre>
<pre><code class="java">Arrays.sort(st, new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                /*如果数据类型是浮点型，则不适合用减法进行比较
                if(o1.getHeight &gt; o2.getHeight)&#123;
                    return 1;
                &#125;else if(o1.getHeight &lt; o2.getHeight)&#123;
                    return -1;
                &#125;
                return 0;*/
                //简化代码，下面方法与上面代码一样
                return Double.compare(o1.Height(),o2.Height());
                
            &#125;
       &#125;);
</code></pre>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>简化匿名内部类的写法，只能简化函数式接口的匿名内部类。</p>
<p>函数式接口：首先是接口，其次只能由一个抽象方法</p>
<p>有@FunctionalInterface的注解的接口，就是函数式接口</p>
<pre><code>(被重写方法的形参列表) - &gt; &#123;
    被重写方法的方法体代码
&#125;
</code></pre>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>简化一</p>
<pre><code class="java">public class LambdaTest1 &#123;
    public static void main(String[] args) &#123;
        /*
        Animal animal = new Animal() &#123;
            @Override
            public void run() &#123;
            &#125;
        &#125;;
        */
        Animal animal = () -&gt; &#123;
            System.out.println(&quot;跑~~~~&quot;);
        &#125;;
        animal.run();
    &#125;
&#125;
interface Animal&#123;
    void run();
&#125;
</code></pre>
<p>简化二</p>
<pre><code class="java">/*
        Arrays.sort(st, new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return 0;
            &#125;
        &#125;);
*/

Arrays.sort(st,(Student o1, Student o2) -&gt; &#123;return 0;&#125;);
</code></pre>
<p>Lambda表达式的进一步简化规则</p>
<ol>
<li>参数类型可以不写</li>
<li>如果只有一个参数，参数类型可以省略，同时()也可以省略</li>
<li>如果Lambda表达式中的方法体代码只有一行，可以省略大括号不写，同时要省略分号！此时，如果这行代码是return语句，也必须省略return不写</li>
</ol>
<pre><code class="java">/*Arrays.sort(st,(Student o1, Student o2) -&gt; &#123;return 0;&#125;);
可以进一步省略*/

Arrays.sort(st,(o1,o2) -&gt;  0);
</code></pre>
<h2 id="方法引用（进一步简化Lambda）"><a href="#方法引用（进一步简化Lambda）" class="headerlink" title="方法引用（进一步简化Lambda）"></a>方法引用（进一步简化Lambda）</h2><h3 id="静态方法的引用"><a href="#静态方法的引用" class="headerlink" title="静态方法的引用"></a>静态方法的引用</h3><pre><code>类名::静态方法

如果某个Lambda表达式只是调用一个静态方法，并且前后参数一致，就可以使用静态方法引用
</code></pre>
<pre><code class="java">// Arrays.sort(st, (o1,o2) -&gt; o1.getAge() - o2.getAge());
// Arrays.sort(st, (o1,o2) -&gt; CompareByDate.compareByDateAge(o1,o2));
   Arrays.sort(st, CompareByDate::compareByDateAge);




class CompareByDate&#123;
    public static int compareByDateAge(Student o1, Student o2)&#123;
        return o1.getAge() - o2.getAge();
    &#125;
&#125;
</code></pre>
<h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><pre><code>对象名::实例方法
如果某个Lambda表达式只是调用一个实例方法，并且前后参数的形式一致，就可以使用实例方法引用
</code></pre>
<pre><code class="java"> CompareByDate compareByDate = new CompareByDate();
//Arrays.sort(st, (o2,o1) -&gt; o2.getAge() - o1.getAge());
//Arrays.sort(st, (o2,o1) -&gt; compareByDate.compareByDateAgeDesc(o2,o1));
Arrays.sort(st, compareByDate::compareByDateAgeDesc);

class CompareByDate&#123;
    public static int compareByDateAge(Student o1, Student o2)&#123;
        return o1.getAge() - o2.getAge();
    &#125;
    public  int compareByDateAgeDesc(Student o1, Student o2)&#123;
        return o2.getAge() - o1.getAge();
    &#125;
&#125;
</code></pre>
<h3 id="特定类型方法的引用"><a href="#特定类型方法的引用" class="headerlink" title="特定类型方法的引用"></a>特定类型方法的引用</h3><pre><code>类型::方法
如果某个Lambda表达式里只是调用一个实例方法，并且前面的参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用
</code></pre>
<pre><code class="java">        String[] str = &#123;&quot;apple&quot;, &quot;connect&quot;,&quot;Distory&quot;,&quot;Abond&quot;,&quot;bnond&quot;,&quot;Bccccd&quot;&#125;;
    /*        Arrays.sort(str, new Comparator&lt;String&gt;() &#123;
            @Override
            public int compare(String o1, String o2) &#123;
                return o1.compareToIgnoreCase(o2);
            &#125;
        &#125;);*/

        Arrays.sort(str, String::compareToIgnoreCase);//Lambda简化后
        System.out.println(Arrays.toString(str));





</code></pre>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre><code class="java">        int[]  num = &#123;5,6,4,3,2,1&#125;;
        int n;

 /*
        for (int i = 0; i &lt;= num.length-2; i++) &#123;
            for (int j = i+1;  j&lt; num.length; j++) &#123;
                if (num[i] &gt; num[j])&#123;
                    n = num[i];
                    num[i] = num[j];
                    num[j] = n;
                &#125;

            &#125;


        &#125;*/
        //第一轮for循环控制排序次数
        for (int i = 0; i &lt; num.length-1; i++) &#123;
            for (int i1 = 0; i1 &lt; num.length-i-1; i1++) &#123;
                if (num[i1] &gt; num[i1+1])&#123;
                    n = num[i1];
                    num[i1] = num[i1+1];
                    num[i1+1] = n;
                &#125;

            &#125;

        &#125;


        System.out.println(Arrays.toString(num));
</code></pre>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><pre><code class="java">        int[]  num = &#123;5,6,4,3,2,1&#125;;
        int n;


        for (int i = 0; i &lt;= num.length-2; i++) &#123;
            for (int j = i+1;  j&lt; num.length; j++) &#123;
                if (num[i] &gt; num[j])&#123;
                    n = num[i];
                    num[i] = num[j];
                    num[j] = n;
                &#125;

            &#125;

            //优化性能，记录最小值的索引，值交换一次数据
</code></pre>
<h3 id="查找算法-二分查找"><a href="#查找算法-二分查找" class="headerlink" title="查找算法(二分查找)"></a>查找算法(二分查找)</h3><pre><code class="java">    public static void main(String[] args) &#123;

        int[]  num = &#123;5,6,4,3,2,1&#125;;

        Arrays.sort(num);
        System.out.println(Arrays.toString(num));
        System.out.println(sort(num, 5));


    &#125;
    public  static int sort(int[] num, int n) &#123;

        int firnum = 0;
        int endnum = num.length - 1;

        while (firnum &lt;= endnum) &#123;
            int minnun = (firnum + endnum) / 2;
            if (n &lt; num[minnun]) &#123;
                endnum = minnun - 1;
            &#125; else if (n &gt; num[minnun]) &#123;
                firnum = minnun + 1;
            &#125; else &#123;
                return minnun;
            &#125;
        &#125;
        return -1;


    &#125;
</code></pre>
<hr>
<h2 id="GUI编程"><a href="#GUI编程" class="headerlink" title="GUI编程"></a>GUI编程</h2><h3 id="创建窗体对象"><a href="#创建窗体对象" class="headerlink" title="创建窗体对象"></a>创建窗体对象</h3><pre><code class="java">Frame f = new Frame();
f.setTitle(&quot;主题&quot;);   //这里可以省略，创建Frame时直接调用有参构造方法Frame(&quot;主题&quot;)
f.setVisible(true);  //显示创建的窗体，放在最后面
</code></pre>
<h3 id="设置窗口的位置大小"><a href="#设置窗口的位置大小" class="headerlink" title="设置窗口的位置大小"></a>设置窗口的位置大小</h3><pre><code class="java">f.setSize(400,300); //窗口大小，也可以创建Dimension对象，将此对象传递给setSize();
f.setLocation(400,300);//窗口位置,同上可以创建一个Point对象，
</code></pre>
<pre><code class="java">f.setBounds(400,300,400,300); //setSize(),setLocation()方法的和
</code></pre>
<h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><p>关闭窗口</p>
<pre><code class="java">//所需要的参数是接口，所以定义一个匿名内部类，重写方法
f.addWindowListener(new WindowListener() &#123;
            @Override
            public void windowOpened(WindowEvent e) &#123;

            &#125;

            @Override
            public void windowClosing(WindowEvent e) &#123;
                System.exit(0);

            &#125;

            @Override
            public void windowClosed(WindowEvent e) &#123;

            &#125;

            @Override
            public void windowIconified(WindowEvent e) &#123;

            &#125;

            @Override
            public void windowDeiconified(WindowEvent e) &#123;

            &#125;

            @Override
            public void windowActivated(WindowEvent e) &#123;

            &#125;

            @Override
            public void windowDeactivated(WindowEvent e) &#123;

            &#125;
        &#125;);
</code></pre>
<p>可以看到，我们实际只需要重写一个方法，但是却把接口中的所有方法都重写了。</p>
<p>我们可以定义一个抽象类，作为接口的实现类，这种类叫做适配器类</p>
<pre><code class="java">public abstract class GUIDemo2 implements WindowListener &#123;
    @Override
    public void windowOpened(WindowEvent e) &#123;

    &#125;

    @Override
    public void windowClosing(WindowEvent e) &#123;

    &#125;

    @Override
    public void windowClosed(WindowEvent e) &#123;

    &#125;

    @Override
    public void windowIconified(WindowEvent e) &#123;

    &#125;

    @Override
    public void windowDeiconified(WindowEvent e) &#123;

    &#125;

    @Override
    public void windowActivated(WindowEvent e) &#123;

    &#125;

    @Override
    public void windowDeactivated(WindowEvent e) &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">//只需要实现这种适配器类  
f.addWindowListener(new GUIDemo2() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
                System.exit(0);
            &#125;
        &#125;);
</code></pre>
<p>JDK中已经定义好了这种适配器类WindowAdapter</p>
<pre><code class="java"> f.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
               System.exit(0);
            &#125;
        &#125;);
</code></pre>
<h3 id="按钮对象"><a href="#按钮对象" class="headerlink" title="按钮对象"></a>按钮对象</h3><pre><code class="java">Button bt = new Button(&quot;anniu&quot;);
f.add(bt); //将按钮组件，添加进窗口
</code></pre>
<p>为按钮创建一个活动事件</p>
<pre><code class="java"> bt.addActionListener(new ActionListener() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                System.out.println(&quot;你再点一个试试&quot;);
            &#125;
        &#125;);
</code></pre>
<h3 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h3><p>默认是边界布局，一共有五种布局方案</p>
<pre><code class="java">//设置为流式布局:FlowLayout为流式布局的实现类
f.setLayout(new FlowLayout());
</code></pre>
<h3 id="创建文本框"><a href="#创建文本框" class="headerlink" title="创建文本框"></a>创建文本框</h3><pre><code class="java">TextField tf = new TextField(20);  //20表示占用20个字符
</code></pre>
<h3 id="创建文本域"><a href="#创建文本域" class="headerlink" title="创建文本域"></a>创建文本域</h3><pre><code class="java">TextArea ta = new TextArea(20,20); //20行，20列
</code></pre>
<h2 id="案例-实现文本框与文本域的数据转移"><a href="#案例-实现文本框与文本域的数据转移" class="headerlink" title="案例-实现文本框与文本域的数据转移"></a>案例-实现文本框与文本域的数据转移</h2><pre><code class="java">public static void main(String[] args) &#123;
        Frame f = new Frame(&quot;数据转移&quot;);
//        f.setTitle(&quot;主题&quot;);

        f.setBounds(400,300,400,300);
        f.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
               System.exit(0);
            &#125;
        &#125;);
        f.setLayout(new FlowLayout());
        //文本框
        TextField tf = new TextField(20);
        f.add(tf);
        //按钮
        Button bt = new Button(&quot;数据转移&quot;);
        f.add(bt);
        //文本域
        TextArea ta = new TextArea(10,20);
        f.add(ta);

        //为按钮添加事件
        bt.addActionListener(new ActionListener() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                //获取文本框的值
                String tf_str = tf.getText().trim();
                //清空文本框的值
                tf.setText(&quot;&quot;);
                //将值赋值给文本域,
                ta.append(tf_str+&quot;\r\n&quot;);
                //每次转移数据后，自动获取光标
                tf.requestFocus();

            &#125;
        &#125;);

        f.setVisible(true);
    &#125;
</code></pre>
<h2 id="案例-鼠标移动到响应的颜色按钮，实现颜色的切换"><a href="#案例-鼠标移动到响应的颜色按钮，实现颜色的切换" class="headerlink" title="案例-鼠标移动到响应的颜色按钮，实现颜色的切换"></a>案例-鼠标移动到响应的颜色按钮，实现颜色的切换</h2><pre><code class="java">public static void main(String[] args) &#123;
        Frame f = new Frame(&quot;颜色切换&quot;);
//        f.setTitle(&quot;主题&quot;);

        f.setBounds(400,300,400,300);
        f.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
               System.exit(0);
            &#125;
        &#125;);
        //设置布局方式
        f.setLayout(new FlowLayout());

        Button redButton = new Button(&quot;redButton&quot;);
        Button buleButton = new Button(&quot;buleButton&quot;);
        Button greenButton = new Button(&quot;greenButton&quot;);
        //添加到窗口
        f.add(redButton);
        f.add(buleButton);
        f.add(greenButton);

        //添加事件
        redButton.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseEntered(MouseEvent e) &#123;
                f.setBackground(Color.RED);
            &#125;
        &#125;);
        redButton.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseExited(MouseEvent e) &#123;
                f.setBackground(Color.WHITE);
            &#125;
        &#125;);

        buleButton.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseEntered(MouseEvent e) &#123;
                f.setBackground(Color.BLUE);
            &#125;
        &#125;);
        buleButton.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseExited(MouseEvent e) &#123;
                f.setBackground(Color.WHITE);
            &#125;
        &#125;);

        greenButton.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseEntered(MouseEvent e) &#123;
                f.setBackground(Color.GREEN);
            &#125;
        &#125;);
        greenButton.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseExited(MouseEvent e) &#123;
                f.setBackground(Color.WHITE);
            &#125;
        &#125;);

        f.setVisible(true);
    &#125;
</code></pre>
<pre><code class="java">//上面代码冗余，可以用一个方法封装起来
class Sx&#123;
    public Sx()&#123;

    &#125;
    public static void text(Frame f,Button bt, Color c)&#123;
        bt.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseEntered(MouseEvent e) &#123;
                f.setBackground(c);
            &#125;
        &#125;);
        bt.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseExited(MouseEvent e) &#123;
                f.setBackground(Color.WHITE);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><pre><code class="java">Label label = new Label(&quot;Label标签&quot;);
</code></pre>
<h2 id="案例-文本框内只能输入数字"><a href="#案例-文本框内只能输入数字" class="headerlink" title="案例-文本框内只能输入数字"></a>案例-文本框内只能输入数字</h2><pre><code class="java"> //给文本框添加键盘事件,具体用到什么方法可以查看JDK API文档
        textField.addKeyListener(new KeyAdapter() &#123;
            @Override
            public void keyPressed(KeyEvent e) &#123;
                //返回文本框中的输入
                char a = e.getKeyChar();
                if (!(a&lt;=&#39;9&#39; &amp;&amp;	 a&gt;=&#39;0&#39;))&#123;
                    e.consume(); //取消事件

                    &#125;
            &#125;
        &#125;);
</code></pre>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>设置菜单栏</p>
<pre><code class="java">MenuBar menuBar = new MenuBar();
f.setMenuBar(menuBar);
</code></pre>
<p>设置菜单</p>
<pre><code class="java">Menu me = new Menu(&quot;菜单&quot;);
menuBar.add(me);
</code></pre>
<p>设置菜单项</p>
<pre><code class="java">MenuItem mi = new MenuItem(&quot;退出系统&quot;);
me.add(mi);
</code></pre>
<p>设置多级菜单</p>
<pre><code class="java">JMenuBar menuBar = new JMenuBar();
JMenu me = new JMenu(&quot;菜单1&quot;);
JMenu JM1 = new JMenu(&quot;更改名称&quot;);

JMenuItem mi = new JMenuItem(&quot;退出系统&quot;);
JMenuItem JM2 = new JMenuItem(&quot;好好学习&quot;);
JMenuItem JM3 = new JMenuItem(&quot;天天向上&quot;);

JM1.add(JM2);
JM1.add(JM3);

me.add(JM1);//将菜单嵌套进菜单实现多级菜单
me.add(mi);
menuBar.add(me);
f.setJMenuBar(menuBar);
</code></pre>
<h2 id="案例-计算器"><a href="#案例-计算器" class="headerlink" title="案例-计算器"></a>案例-计算器</h2><pre><code class="java">public class GUIDemo5 &#123;
    public static void main(String[] args) &#123;
        JFrame f = new JFrame(&quot;运算器&quot;);
        f.setLayout(new FlowLayout());
        f.setBounds(600,400,400,300);
        //关闭窗口事件
        f.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
                System.exit(0);
            &#125;
        &#125;);

        JTextField firstNumber = new JTextField(5);
        f.add(firstNumber);

        //下拉菜单	
        JComboBox&lt;Object&gt; objectJComboBox = new JComboBox&lt;&gt;();
        objectJComboBox.addItem(&quot;+&quot;);
        objectJComboBox.addItem(&quot;-&quot;);
        objectJComboBox.addItem(&quot;*&quot;);
        objectJComboBox.addItem(&quot;/&quot;);
        f.add(objectJComboBox);

        JTextField secondNumber = new JTextField(5);
        f.add(secondNumber);

        JLabel jl2 = new JLabel(&quot;=&quot;);
        f.add(jl2);

        JTextField resultNumber = new JTextField(5);
        f.add(resultNumber);

        JButton jb = new JButton(&quot;计算&quot;);
        f.add(jb);

        //为计算按钮添加事件
        jb.addActionListener(new ActionListener() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                //获取第一个文本框的数据
                String firstNumberString = firstNumber.getText().trim();
                int  firstNumber = Integer.valueOf(firstNumberString);


                //获取第二个文本框的数据
                String secondNumberString = secondNumber.getText().trim();
                int secondNumber = Integer.valueOf(secondNumberString);

                //获取运算符
                String selectedItem = objectJComboBox.getSelectedItem().toString();

                //定义一个变量，存储结果
                int result = 0;

                //进行运算
                switch (selectedItem)&#123;
                    case &quot;+&quot;:
                        result = firstNumber + secondNumber;
                        break;
                    case &quot;-&quot;:
                        result = firstNumber - secondNumber;
                        break;
                    case &quot;*&quot;:
                        result = firstNumber * secondNumber;
                        break;
                    case &quot;/&quot;:
                        result = firstNumber / secondNumber;
                        break;
                &#125;

                //将结果返回给文本框
                resultNumber.setText(String.valueOf(result));
            &#125;
        &#125;);

        f.setVisible(true);
    &#125;


&#125;
</code></pre>
<h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><pre><code class="java">        //下拉菜单	
        JComboBox&lt;Object&gt; objectJComboBox = new JComboBox&lt;&gt;();
        objectJComboBox.addItem(&quot;+&quot;);
        objectJComboBox.addItem(&quot;-&quot;);
        objectJComboBox.addItem(&quot;*&quot;);
        objectJComboBox.addItem(&quot;/&quot;);
        f.add(objectJComboBox);

        JTextField secondNumber = new JTextField(5);
        f.add(secondNumber);
</code></pre>
<h3 id="设置窗口的ICO图标"><a href="#设置窗口的ICO图标" class="headerlink" title="设置窗口的ICO图标"></a>设置窗口的ICO图标</h3><pre><code class="java">        //设置窗体的ICO图标
        Toolkit defaultToolkit = Toolkit.getDefaultToolkit();
        //获取本地图片
        Image image = defaultToolkit.getImage(&quot;C:\\Users\\18117\\Desktop\\笔记\\java web\\1.jpg&quot;);
        //添加到窗口中
        f.setIconImage(image);
</code></pre>
<h3 id="设置窗体在屏幕居中"><a href="#设置窗体在屏幕居中" class="headerlink" title="设置窗体在屏幕居中"></a>设置窗体在屏幕居中</h3><p>提示：用屏幕的宽高减去窗口的宽高除以2，获得的值重新赋值给窗体的位置</p>
<pre><code class="java">        //设置窗口居中
        //使用工具类获取屏幕的大小，以Dimension对象返回
        Toolkit defaultToolkit = Toolkit.getDefaultToolkit();
        Dimension screenSize = defaultToolkit.getScreenSize();
        //获取屏幕的宽高
        double widthScreen = screenSize.getWidth();
        double heightScreen = screenSize.getHeight();

        int width = (int) (widthScreen - f.getWidth()) / 2;
        int height = (int) (heightScreen - f.getHeight()) / 2;

        f.setLocation(width,height);
</code></pre>
<h3 id="设置窗体的主题"><a href="#设置窗体的主题" class="headerlink" title="设置窗体的主题"></a>设置窗体的主题</h3><pre><code class="java">String lookAndFeel =&quot;com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel&quot;;
UIManager.setLookAndFeel(lookAndFeel);
</code></pre>
<h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><h3 id="JOptionPane"><a href="#JOptionPane" class="headerlink" title="JOptionPane"></a>JOptionPane</h3><p>弹窗,具体方法API文档查看</p>
<pre><code class="java">String regex = &quot;\\d+&quot;; //正则表达式
//获取第一个文本框的数据
String firstNumberString = firstNumber.getText().trim();
if (!firstNumberString.matches(regex))&#123;
    JOptionPane.showMessageDialog(f,&quot;第一个操作数不满足要求&quot;);
    return;
&#125;
</code></pre>
<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>java中的反射机制是指，java程序在运行期间可以获取到一个对象的全部信息。</p>
<p>反射机制一般用来解决Java程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法</p>
<h3 id="反射机制原理"><a href="#反射机制原理" class="headerlink" title="反射机制原理"></a>反射机制原理</h3><p>反射机制允许Java程序在于运行时调用Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等），并能操作类的实例对象的属性和方法。</p>
<p>在Java程序中，JVM加载完成一个类后，在内存终究会产生该类的一个Class对象，一个类在堆内存中最多只会有一个Class对象，这个Class对象包含了该类的完整结构信息，我们可以通过这个Class对象便可以得到该类的完整结构信息。</p>
<p>这个Class对象就像是一面镜子，我们透过这面镜子可以清楚地看到类的结构信息。因此，我们形象的将获取Class对象的过程称为：</p>
<p>反射。</p>
<p>如下图</p>
<p><img src="/../img/JAVA/1.png"></p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><h4 id="静态加载"><a href="#静态加载" class="headerlink" title="静态加载"></a>静态加载</h4><p>加载的类不存在时，编译过程就会报错，</p>
<ul>
<li>当创建一个对象时（new），该类会被加载</li>
<li>当调用类中的静态成员时，该类会被加载</li>
<li>当子类被加载时，其超类也会被加载</li>
</ul>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p><code>加载的类不存在时，也不会报错</code></p>
<ul>
<li>通过反射的方式，在程序运行时使用到那个类，该类会被加载</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>类加载时有JVM创建，通过Class类获取其他类。</p>
<p>同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class类对象都是同一个</p>
<h4 id="获取Class的三种方式"><a href="#获取Class的三种方式" class="headerlink" title="获取Class的三种方式"></a>获取Class的三种方式</h4><pre><code class="java">package net.net2;

public class Student &#123;
    //无参构造
    public Student() &#123;
    &#125;
    //有参
    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    //私有的有参构造
    private Student(String name) &#123;
        this.name = name;
    &#125;


    public String name;
    private int age;



    public  void aihao()&#123;
        System.out.println(&quot;打篮球&quot;);
    &#125;;

    private void buai()&#123;
        System.out.println(&quot;打游戏&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>第一种</strong></p>
<pre><code class="java">Class.forName(&quot;全类名&quot;):将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类

Class class1 = Class.forName(&quot;net.net2.Student&quot;);
</code></pre>
<p><strong>第二种</strong></p>
<pre><code class="java">类名.class:通过雷鸣的class属性，返回Class对象

Class class2 = Student.class;
</code></pre>
<p><strong>第三种</strong></p>
<pre><code class="java">实例.getClass():通过实例的getClass()方法,返回Class对象
该方法定义在Object类中，过用于通过对象，调用getClass()方法，返回Class对象
    
    
Student student = new Student();
Class&lt;? extends Student&gt; aClass = student.getClass();
</code></pre>
<h3 id="Constructo类"><a href="#Constructo类" class="headerlink" title="Constructo类"></a>Constructo类</h3><p>存放一切类的构造方法</p>
<h4 id="获取构造方法有4种，都是有Class对象调用"><a href="#获取构造方法有4种，都是有Class对象调用" class="headerlink" title="获取构造方法有4种，都是有Class对象调用"></a>获取构造方法有4种，都是有Class对象调用</h4><p> <strong>第一种</strong></p>
<pre><code class="java">Constructor&lt;?&gt;[] getConstructors() //获取public修饰的构造器，此时返回的是一个数组
    
Constructor[] constructor1 = class1.getConstructors();
</code></pre>
<p><strong>第二种</strong></p>
<pre><code class="java">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;...parameterTypers) //获取public修饰的有参构造器，注意里面的参数写其对应类型的Class类
    
Constructor constructor2 = class1.getConstructor(String.class,int.class);
</code></pre>
<p><strong>第三种</strong></p>
<pre><code class="java">Constructor&lt;?&gt;[] getDeclaredConstructors() //获取所有的构造器
    
Constructor[] declaredConstructors = class1.getDeclaredConstructors();
</code></pre>
<p><strong>第四种</strong></p>
<pre><code class="java">Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;...parameterTypers) //获取所有的构造器，注意里面的参数写其对应类型的Class类
    
Constructor declaredConstructor = class1.getDeclaredConstructor(String.class);
</code></pre>
<p><strong>创建该类的对象</strong></p>
<p>构造方法对象.newInstance(具体参数)</p>
<pre><code class="java">Constructor constructor2 = class1.getConstructor(String.class,int.class);
//有参无参都可以，可以强制类型转换为相应的类
Object o = constructor2.newInstance();
</code></pre>
<p><code>注意</code></p>
<ul>
<li><p>什么方法获取的构造器对象，使用相应的方法创建其类。</p>
</li>
<li><p>如果创建类对象时使用私有的构造器，必须设置<code>setAccessible(true)</code>暴力反射。</p>
</li>
<li><p>如果使用无参构造方法构造对象，可以直接使用<code>class对象.newInstance()</code>来创建</p>
</li>
</ul>
<p>使用无参</p>
<p>方法一</p>
<pre><code class="java">Object o1 = class1.newInstance();
</code></pre>
<p>方法二</p>
<p><code>就是不写参数</code></p>
<pre><code class="java">Constructor constructor2 = class1.getConstructor(String.class,int.class);
Object o2 = constructor2.newInstance();
</code></pre>
<p>使用私有构造器创建</p>
<pre><code class="java">Constructor declaredConstructor = class1.getDeclaredConstructor(String.class);
//先经过暴力反射
declaredConstructor.setAccessible(true);

Object o = declaredConstructor.newInstance(&quot;小明00&quot;);
</code></pre>
<h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p><code>获取成员变量，方法类似构造器</code></p>
<p><strong>第一种</strong></p>
<pre><code class="java">Field[] getFields() //获取public修饰的成员变量
    
Field[] fields = class2.getFields();
</code></pre>
<p><strong>第二种</strong></p>
<pre><code class="java">Field[] getField(String name) //获取public修饰的指定的成员变量
    
    
Field field = class2.getField(&quot;name&quot;);
System.out.println(field);
</code></pre>
<p><strong>第三种</strong></p>
<pre><code class="java">Field[] getDeclaredFields() //获取所有的成员变量
    
Field[] declaredFields = class2.getDeclaredFields();
</code></pre>
<p><strong>第四种</strong></p>
<pre><code class="java">Field[] getDeclaredField(String name) //获取所有的指定的成员变量

Field age = class2.getDeclaredField(&quot;age&quot;);
System.out.println(age);
</code></pre>
<p><code>哪种方法获得的成员变量，设置哪种成员变量，私有的成员变量同样需要暴力反射</code></p>
<p><strong>设置其值</strong></p>
<pre><code class="java">void set(Object obj,Object value)
</code></pre>
<p><strong>取值</strong></p>
<pre><code class="java">get(Object obj)
</code></pre>
<p>public <strong>成员变量</strong></p>
<pre><code class="java">Class class2 = Student.class; 

Object o = class2.newInstance(); //使用反射获取对象

Student student = new Student(); //正常实例化对象

Field field = class2.getField(&quot;name&quot;); //获取指定成员变量

field.set(o,&quot;小明&quot;); //给指定的实例化对象，指定的成员变量赋值
System.out.println(field.get(o)); //获取指定的对象的指定的值

field.set(student,&quot;夏红&quot;);
System.out.println(field.get(student));
</code></pre>
<p>private  <strong>私有成员变量</strong></p>
<pre><code class="java">Field age = class2.getDeclaredField(&quot;age&quot;);
age.setAccessible(true); //暴力反射

age.set(student,22);
System.out.println(age.get(student));
</code></pre>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解主要有三个作用</p>
<ol>
<li><p>生成帮助文档：通过代码里标识的注解形式生成doc文档。</p>
<pre><code class="cmd">java -d doc -enconding UTF-8  C:\Users\Test.class

-d ：要创建的目录名字
</code></pre>
</li>
<li><p>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查，例如<code>@override</code></p>
</li>
<li><p>代码分析 ：通过代码里标识的注解对代码进行分析</p>
</li>
</ol>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解本质上就是一个接口，该接口默认继承于<code>Annotation接口</code></p>
<pre><code class="java">元注解
public @interface 注解名称&#123;
    属性(); //例如int a(); 类似于定义一个属性，但实际上是一个抽象方法。
&#125;
</code></pre>
<p><strong>@override注解详情</strong></p>
<pre><code class="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override &#123;
&#125;
</code></pre>
<p><strong>定义注解的格式</strong></p>
<pre><code class="java">元注解
public @interface 注解名称&#123;
    返回值类型 方法名称()
&#125;
</code></pre>
<p><strong>元注解：用于描述注解的位置</strong></p>
<p>@Target：描述注解能够作用的位置（FIELD、METHOD、TYPE[类]）</p>
<p>@Retention：描述注解被保留到哪个阶段（如源码阶段、Class类对象阶段、运行阶段）</p>
<p>@Documented：描述注解是否被抽取到api（doc文档中）、</p>
<p>@Inherited：描述注解知否被子类继承</p>
<h3 id="通过反射来获取注解对象"><a href="#通过反射来获取注解对象" class="headerlink" title="通过反射来获取注解对象"></a>通过反射来获取注解对象</h3><p>自定义注解</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Cuijian &#123;
    int a();
    String b();
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">@Cuijian(a=20,b=&quot;cuijian&quot;) //赋值
public class Test &#123;
    public static void main(String[] args)&#123;
        Cuijian cj =Test.class.getAnnotation(Cuijian.class); //通过CLass类的getAnnotation方法获取，
        System.out.println(cj.a());
        System.out.println(cj.b());
    &#125;
&#125;
</code></pre>
<h3 id="通过注解来获取任意类的对象"><a href="#通过注解来获取任意类的对象" class="headerlink" title="通过注解来获取任意类的对象"></a>通过注解来获取任意类的对象</h3><h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>即输入、输出流；</p>
<p>输入：从磁盘往内存中写。</p>
<p>输出：从内存往磁盘中写</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h3><ul>
<li>根据流操作的数据单位不同，分为字节流和字符流。</li>
<li>根据流功能的不同，分为节点流（低级流）和处理流（高级流，如缓冲流）。</li>
</ul>
<h3 id="字节输出、输出流"><a href="#字节输出、输出流" class="headerlink" title="字节输出、输出流"></a>字节输出、输出流</h3><p>就是按照字节来输入、输出</p>
<p>FileOutStream：输出</p>
<blockquote>
<p>write(byte[] b)：把参数b指定的byte数组中的所有字节写入输出流</p>
</blockquote>
<blockquote>
<p>close()：关闭连接</p>
</blockquote>
<p>FileInputStream：输入</p>
<blockquote>
<p>read(byte[] b)：传入一个动态byte数组，将读取到的内容放入此数组，并返回读取的长度</p>
</blockquote>
<pre><code class="java">    public static void main(String[] args) throws Exception &#123;
        
       
        File file = new File(&quot;D:/date.txt&quot;); //文件对象
        FileOutputStream fileOutputStream = new FileOutputStream(file);
        byte[] b = &quot;hello world&quot;.getBytes(); //将字符串转为字节数组
        fileOutputStream.write(b);


        FileInputStream fileInputStream = new FileInputStream(file);
        byte[] c = new byte[2];
        int len = 0;

        while((len = fileInputStream.read(c)) != -1)&#123; //将读取到的字节存入c数组，并返回读取字节的长度
//            System.out.println(Arrays.toString(c));
            System.out.print(new String(c,0,len)); //将字节转换为字符串
        &#125;
        
        fileInputStream.close();
        fileOutputStream.close();


    &#125;&#125;
</code></pre>
<h3 id="字符输出、输出流"><a href="#字符输出、输出流" class="headerlink" title="字符输出、输出流"></a>字符输出、输出流</h3><p>FileReader：字符输入流</p>
<blockquote>
<p>read()</p>
</blockquote>
<blockquote>
<p>read(char[] c)</p>
</blockquote>
<p>FileWriter：字符输出流</p>
<blockquote>
<p>wtite(char[] c)</p>
</blockquote>
<blockquote>
<p>write(String str)：可以直接写入字符串</p>
</blockquote>
<pre><code class="java">public static void main(String[] args) throws Exception &#123;

        File file = new File(&quot;D:/date.txt&quot;);
        FileWriter fileWriter = new FileWriter(file);
        fileWriter.write(&quot;你好，世界&quot;);

        fileWriter.close(); //注意字符输出流资源不关闭，字符输入流读取不到信息
    
        char[] c = new char[2];
        int len = 0;
        FileReader fileReader = new FileReader(file);
        while ((len=fileReader.read(c))!=-1)&#123;
            System.out.print(new String(c,0,len));
        &#125;

        fileReader.close();


    &#125;
</code></pre>
<h3 id="带缓冲的字符输入、输出流"><a href="#带缓冲的字符输入、输出流" class="headerlink" title="带缓冲的字符输入、输出流"></a>带缓冲的字符输入、输出流</h3><p>BufferReafer：字符输入</p>
<blockquote>
<p>readLine()：返回读取的字符串，当后面没有内容时，返回null</p>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
