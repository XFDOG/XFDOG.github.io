<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PHP | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="PHP | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="代码">
<meta property="og:url" content="http://example.com/%E4%BB%A3%E7%A0%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-28T07:26:32.000Z">
<meta property="article:modified_time" content="2024-03-28T07:55:53.731Z">
<meta property="article:author" content="花开人无在">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>花开人无在</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(7)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="代码">
            
            代码
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="操作系统">
            
            操作系统
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        <a 
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="7">
<input type="hidden" id="yelog_site_word_count" value="71.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 代码 "
           href="/2024/04/01/JavaScript/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JavaScript">JavaScript</span>
            <span class="post-date" title="2024-04-01 21:55:05">2024/04/01</span>
        </a>
        
        
        <a  class="全部文章 操作系统 "
           href="/2024/04/01/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-04-01 20:05:45">2024/04/01</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/03/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="博客搭建">博客搭建</span>
            <span class="post-date" title="2024-03-27 19:48:23">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 代码 "
           href="/2024/03/27/JAVA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JAVA">JAVA</span>
            <span class="post-date" title="2024-03-27 19:33:34">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 代码 "
           href="/2024/03/27/Python/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python">Python</span>
            <span class="post-date" title="2024-03-27 19:33:34">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 代码 "
           href="/2024/03/27/php-0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PHP">PHP</span>
            <span class="post-date" title="2024-03-27 19:33:34">2024/03/27</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/03/27/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2024-03-27 19:10:14">2024/03/27</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-php-0" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">PHP</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="代码">代码</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-04-16 22:35:31'>2024-03-27 19:33</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:33.3k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP%E4%BB%A3%E7%A0%81%E6%A0%87%E8%AE%B0"><span class="toc-text">PHP代码标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP%E6%B3%A8%E9%87%8A"><span class="toc-text">PHP注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="toc-text">单引号双引号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">预定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-text">可变变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BC%A0%E5%80%BC"><span class="toc-text">变量传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B8%B8%E9%87%8F"><span class="toc-text">系统常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F"><span class="toc-text">魔术常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">浮点类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">浮点型判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">比较运算符（返回结果都是布尔类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%EF%BC%8C%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E8%BF%94%E5%9B%9Etrue%EF%BC%8C%E4%B8%8D%E6%BB%A1%E8%B6%B3%E8%BF%94%E5%9B%9Efalse%EF%BC%89"><span class="toc-text">（针对不同结果进行匹配，满足条件返回true，不满足返回false）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">连接运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8A%91%E5%88%B6%E7%AC%A6"><span class="toc-text">错误抑制符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%9C%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">三木运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%93%8D%E4%BD%9C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">自操作运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A0%81"><span class="toc-text">计算机码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%88%86%E7%B1%BB"><span class="toc-text">控制分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-text">分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E5%88%86%E6%94%AF"><span class="toc-text">if分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E5%88%86%E6%94%AF"><span class="toc-text">switch分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while"><span class="toc-text">do-while</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-1"><span class="toc-text">循环结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">流程控制代替语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include%E5%92%8Cinclude-once%E5%8C%BA%E5%88%AB"><span class="toc-text">include和include_once区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">include和require的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">函数命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text">参数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82"><span class="toc-text">形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82"><span class="toc-text">实参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93"><span class="toc-text">函数体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0"><span class="toc-text">可变函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%9E%8B"><span class="toc-text">伪类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-text">常用系统函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">有关输出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">有关时间的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E6%95%B0%E5%AD%A6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">有关数学的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">有关函数的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%88%86%E7%B1%BB"><span class="toc-text">错误分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E4%BB%A3%E5%8F%B7"><span class="toc-text">错误代号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%A7%A6%E5%8F%91"><span class="toc-text">错误触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE"><span class="toc-text">错误显示设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E8%AE%BE%E7%BD%AE"><span class="toc-text">错误日志设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">自定义错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-text">字符串定义语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%BC%A0%E8%BD%AC%E4%B9%89"><span class="toc-text">字符传转义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">字符串长度问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">字符串相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">数组的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-text">数组定义语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP%E6%95%B0%E7%BB%84%E7%89%B9%E7%82%B9"><span class="toc-text">PHP数组特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84-1"><span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%80%A7%E6%95%B0%E7%BB%84"><span class="toc-text">异性数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-text">数组遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreach%E9%81%8D%E5%8E%86"><span class="toc-text">Foreach遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">遍历一维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#For%E5%BE%AA%E7%8E%AF"><span class="toc-text">For循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">数组相关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%EF%BC%9A%E9%83%BD%E5%AF%B9%E5%8E%9F%E6%9C%89%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E4%BA%86%E6%94%B9%E5%8F%98"><span class="toc-text">排序函数：都对原有数组进行了改变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-text">指针函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-text">其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">编程思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95"><span class="toc-text">递推算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">递归算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">数组排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-text">顺序查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">二分查找算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93Mysql"><span class="toc-text">数据库Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">典型的关系型数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">数据库基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">创建数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">查询数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E8%AF%AD%E5%8F%A5"><span class="toc-text">显示数据库创建语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">选择数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">修改数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">删除数据库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">数据表操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">复制表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">查看表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E8%AF%AD%E5%8F%A5"><span class="toc-text">显示表的创建语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9D%9F%E7%AC%A6"><span class="toc-text">mysql语句结束符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="toc-text">修改表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">数据基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-text">查询语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-text">更新数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">设置客户端字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%9D%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">查看系统保存的使用的字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">列类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E8%AE%BE%E5%AE%9A"><span class="toc-text">无符号设定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E9%95%BF%E5%BA%A6"><span class="toc-text">显示长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">小数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">浮点型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Float"><span class="toc-text">Float</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Double"><span class="toc-text">Double</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0"><span class="toc-text">定点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-text">日期时间类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Time"><span class="toc-text">Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Datetime"><span class="toc-text">Datetime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timestamp"><span class="toc-text">Timestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Year"><span class="toc-text">Year</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B"><span class="toc-text">字符串型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Char"><span class="toc-text">Char</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Varchar"><span class="toc-text">Varchar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Text"><span class="toc-text">Text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enum"><span class="toc-text">Enum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E8%AE%B0%E5%BD%95%E9%95%BF%E5%BA%A6"><span class="toc-text">Mysql记录长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-text">列属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NULL%E5%B1%9E%E6%80%A7"><span class="toc-text">NULL属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC-1"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E6%8F%8F%E8%BF%B0"><span class="toc-text">列描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE"><span class="toc-text">主键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%94%AE"><span class="toc-text">创建主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%90%8E%E5%A2%9E%E5%8A%A0"><span class="toc-text">表后增加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%BB%E9%94%AE"><span class="toc-text">删除主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E4%B8%BB%E9%94%AE"><span class="toc-text">复合主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-text">主键约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E5%88%86%E7%B1%BB"><span class="toc-text">主键分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%95%BF"><span class="toc-text">自动增长</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%87%AA%E5%A2%9E%E9%95%BF"><span class="toc-text">修改自增长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%87%AA%E5%A2%9E%E9%95%BF"><span class="toc-text">删除自增长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE"><span class="toc-text">初始设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E9%94%AE"><span class="toc-text">唯一键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">表关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">高级数据操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5"><span class="toc-text">多数据插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E5%86%B2%E7%AA%81"><span class="toc-text">主键冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A0%95%E8%99%AB%E5%A4%8D%E5%88%B6"><span class="toc-text">蠕虫复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE-1"><span class="toc-text">更新数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-1"><span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">查询数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-text">选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8"><span class="toc-text">字段列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#from%E6%BA%90"><span class="toc-text">from源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">单表查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">多表查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">动态数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-by"><span class="toc-text">group by</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#having%E5%AD%90%E5%8F%A5"><span class="toc-text">having子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order-by%E5%AD%90%E5%8F%A5"><span class="toc-text">order by子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit-%E5%AD%97%E5%8F%A5"><span class="toc-text">limit 字句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">查询中的运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IN-%E8%BF%90%E7%AE%97"><span class="toc-text">IN 运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#like%E8%BF%90%E7%AE%97"><span class="toc-text">like运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5"><span class="toc-text">交叉连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">using关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">子查询分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%BA%93%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F"><span class="toc-text">整库数据库备份还原</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%98%E5%8E%9F"><span class="toc-text">数据还原</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">用户权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-text">删除用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81"><span class="toc-text">修改用户名密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">权限管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-text">授予权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%9B%9E%E6%94%B6"><span class="toc-text">权限回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E6%9D%83%E9%99%90"><span class="toc-text">刷新权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">密码忘记解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE"><span class="toc-text">外键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%A4%96%E9%94%AE"><span class="toc-text">增加外键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%A4%96%E9%94%AE"><span class="toc-text">删除外键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="toc-text">外键基本要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-text">外键约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">约束的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E4%BA%8B%E5%8A%A1"><span class="toc-text">自动事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1"><span class="toc-text">手动事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E7%82%B9"><span class="toc-text">回滚点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%8F%98%E9%87%8F"><span class="toc-text">会话变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-text">流程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#If%E5%88%86%E6%94%AF"><span class="toc-text">If分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-text">复合语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF-1"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%A1%A8%E7%A4%BA%E7%AC%A6"><span class="toc-text">结构表示符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-text">核心编程技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BC%A0%E5%80%BC"><span class="toc-text">表单传值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">表单传值的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">PHP接收数据的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP%E5%A4%84%E7%90%86%E5%A4%8D%E9%80%89%E6%A1%86"><span class="toc-text">PHP处理复选框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%86%99%E6%B3%95"><span class="toc-text">表单写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FILES"><span class="toc-text">$_FILES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95"><span class="toc-text">移动临时文件到指定目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">多文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98"><span class="toc-text">文件上传后续问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%89%A9%E5%B1%95"><span class="toc-text">Mysql扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">连接数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%9E%E6%8E%A5%E7%BC%96%E7%A0%81"><span class="toc-text">设置连接编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">选定要使用的数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">增删改查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">关闭连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82"><span class="toc-text">HTTP请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-text">请求行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">请求体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94"><span class="toc-text">HTTP响应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%A1%8C"><span class="toc-text">响应行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-text">响应体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">常见HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E5%93%8D%E5%BA%94%E5%8D%B3%E8%AE%BE%E7%BD%AE"><span class="toc-text">常见HTTP响应即设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP%E6%A8%A1%E6%8B%9FHTTP%E8%AF%B7%E6%B1%82"><span class="toc-text">PHP模拟HTTP请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-text">目录操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-text">其他目录操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95"><span class="toc-text">递归遍历目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">其他操作文件的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="toc-text">文件下载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF"><span class="toc-text">会话技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E6%8A%80%E6%9C%AF"><span class="toc-text">Cookie技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">$this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E6%96%B9%E6%B3%95"><span class="toc-text">析构方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%80%BC"><span class="toc-text">对象传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">范围解析操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">self关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">类的加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-text">对象克隆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB"><span class="toc-text">封装数据库类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PHP-exit-exit-die%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">PHP  exit ,exit(),die的区别</span></a>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PHP是一种运行在服务器的脚本语言，可以嵌入到HTML中</p>
<hr>
<h2 id="PHP代码标记"><a href="#PHP代码标记" class="headerlink" title="PHP代码标记"></a>PHP代码标记</h2><p>使用多种标记来区分php脚本</p>
<p>ASP标记 ：</p>
<pre><code>&lt;% php代码 %&gt;
</code></pre>
<p>短标记：</p>
<pre><code>&lt;? php代码 ?&gt;
</code></pre>
<p>以上两种基本不用了，用的话可以去配置文件中打开：short_open_tag</p>
<p>脚本标记：</p>
<pre><code>&lt;script language=&quot;php&quot;&gt;php代码&lt;/script&gt;
可能版本问题，这个也不只能好用
</code></pre>
<p>标准标记</p>
<pre><code>&lt;?php 
代码
?&gt;
</code></pre>
<h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a>PHP注释</h2><pre><code>行注释：//注释内容  
        # 注释内容


块注释
/*
注释内容
注释内容
*/
</code></pre>
<p>PHP语句分割符</p>
<p>在php中，代码是以行为单位，系统通过判断行的结束，该结束通常都是一个符号：;(英文状态下的分号)</p>
<p>特殊说明：</p>
<ol>
<li>PHP中标记结束符?&gt;有自带结束符的效果，最后一行php代码可以没有;号</li>
<li>php中所有的代码都要加$</li>
</ol>
<h2 id="单引号双引号"><a href="#单引号双引号" class="headerlink" title="单引号双引号"></a>单引号双引号</h2><pre><code>1、双引号会解析字符串中的变量，而单引号不会。
2、在单引号定义的字符串中只能转义单引号和转义符本身，而在双引号定义的字符串中，可以转义更多的特殊字符。
3、在字符处理上单引号要优与双引号。
</code></pre>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><p>预定义变量：系统定义的变量，存储许多用到的数据（预定义变量都是数组）</p>
<pre><code>$_GET:获取所有表单以get方式提交的的数据
$_POST：POST提交的数据都会保存再此
$_REQUEST:GET和POST提交的数据都会保存
$_GLOUBALS:PHP中的所有全局变量
$_SERVER：服务器信息
$_SESSION：session会话数据
$_COOKIE：cookie会话数据
$_EVN：环境信息
$_FILES：用户上传的文件信息
</code></pre>
<h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p>如果一个变量保存的值刚好是另一个变量的名字，那么可以直接通过访问另一个变量得到另一个变量的值;在变量前多加一个$</p>
<pre><code>&lt;?php
$a = 1;
$b = $a; //值传递
$a = 5;
echo $a,$b,&#39;&lt;hr/&gt;&#39;;

$s = 6;
$d = &amp;$s; //地址传递
$s = 9;
echo $s,$d;
?&gt;
</code></pre>
<h2 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h2><p>值传递：将变量保存的值赋值一份，然后将新的值给另一个变量保存（两个变量没有关系）</p>
<p>地址（引用）传递：将变量保存的值所在的内存地址，传递给另一个变量，两个变量指向同一块内存空间（两个变量是同一个值）</p>
<h2 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h2><p>PHP_VERSION:PHP版本号</p>
<p>PHP_INT_SIZE:整形大小</p>
<p>PHP_INT_MAX:整形能表示的最大值</p>
<pre><code>&lt;?php
//系统常量
echo &#39;&lt;hr/&gt;&#39;,PHP_VERSION,&#39;&lt;hr/&gt;&#39;,PHP_INT_SIZE,&#39;&lt;hr/&gt;&#39;,PHP_INT_MAX;

//魔术常量
echo &#39;&lt;br/&gt;&#39;,__DIR__,&#39;&lt;br/&gt;&#39;,__FILE__,&#39;&lt;br/&gt;&#39;,__LINE__,&#39;&lt;br/&gt;&#39;,
__LINE__;
?&gt;
</code></pre>
<h2 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h2><p>在PHP中还有一些特殊的常量，他们有双下划线开始+长两名+双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了</p>
<p><strong>DIR</strong>:当前被执行的脚本所在电脑的绝对路径</p>
<p>__FILE__：当前被执行脚本所在电脑的绝对路径（带自己文件的名字）</p>
<p>__LINE__：当前所属的行数</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在很多的条件下，需要指定的数据类型，需要外部数据（当前PHP取得的数据），转换成目标数据类型</p>
<p>在PHP中有两种类型转换方式：</p>
<ol>
<li>自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低）</li>
</ol>
<p>​	2、强制（手动）转换：认为根据需要的目标类型转换</p>
<p>强制转换规则：在变量之前增加一个括号（）；然后在里面上写对应类型：int&#x2F;interger…</p>
<p>NULL类型要用到unset()</p>
<pre><code>&lt;?php
//数据类型转换
$a = &#39;abc.2.1&#39;;
$b = &#39;3.6.1abc&#39;;

echo $a + $b;   //自动转换  算数+运算，系统先转成数值类型（整形和浮点型），然后运算
echo &#39;&lt;hr&gt;&#39;;
echo (float)$a + (float)$b;//强制（手动）转换 
?&gt;
</code></pre>
<p>其他类型转数值的说明</p>
<p>1、布尔true为1，false为0；</p>
<p>2、字符串数值有自己的规则</p>
<p>2.1、以字母开头的字符串，永远为0</p>
<p>2.2、以数字开头的字符串，取到碰到字符换为止（不会同时包含两个小数点）</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型（相同结果为true，失败为false）：是一组以is_开头后面跟类型名字的函数：is_XXX(变量名)</p>
<p>Bool类型不能用echo查看，可以使用var_dump结构查看</p>
<p>Var_dump(变量1,变量2…)</p>
<pre><code>&lt;?php
//数据类型转换
$a = &#39;abc.1.1&#39;;
$b = &#39;1.1.1abc&#39;;

var_dump(is_int($a));
var_dump(is_string($b));
?&gt;
</code></pre>
<p>还有一组函数可以用来获取以及设定数据变量的类型</p>
<p>Gettype(变量名):获取类型，得到的是该类型对应的字符串</p>
<p>Settype(变量名，’类型’)：设定数据类型，与强制转换不同</p>
<p>1、强制转换（类型）变量名，是对数据复制的内容进行处理（不会处理实际存储的内容）</p>
<p>2、settype会直接改变数据本身</p>
<pre><code>&lt;?php
//数据类型转换
$a = &#39;abc.1.1&#39;;
$b = &#39;1.1.1abc&#39;;
echo gettype($a),&#39;&lt;hr&gt;&#39;,gettype($b),&#39;&lt;hr&gt;&#39;; //查看数据类型gettype
Var_dump(settype($a,&#39;int&#39;));//改变数据类型
echo &#39;&lt;hr&gt;&#39;,gettype($a),&#39;&lt;hr&gt;&#39;,gettype($b);
?&gt;
</code></pre>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><pre><code>&lt;?php
//定义4种整型数据
$a1 = 110;//10进制
$a2 = 0b110;//2进制
$a3 = 0110;//8进制
$a4 = 0x110;//16进制
echo $a1,&#39;--&#39;,$a2,&#39;--&#39;,$a3,&#39;--&#39;,$a4;//默认的php输出数值都会转变为10进制
?&gt;


bindec() — 二进制转换为十进制 
decbin() — 十进制转换为二进制 
dechex() — 十进制转换为十六进制 
decoct() — 十进制转换为八进制 
hexdec() — 十六进制转换为十进制 
octdec() — 八进制转换为十进制
base_convert()– 在任意进制之间转换数字
</code></pre>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>整形超过自身存储的大小之后会用浮点型存储</p>
<pre><code>&lt;?php
$f1 = 1.23;
$f2 = 1.23e10;//e表示以10为低
$f3 = PHP_INT_MAX + 1;//PHP_INT_MAX表示整数integer值的最大值
var_dump($f1,$f2,$f3);
?&gt;
</code></pre>
<h3 id="浮点型判断"><a href="#浮点型判断" class="headerlink" title="浮点型判断"></a>浮点型判断</h3><p>浮点型存储数据不太准确</p>
<pre><code>&lt;?php
$f1 = 0.7;
$f2 = 2.1;
$f3 = $f2 / 3;
var_dump($f1 == $f3);
?&gt;
</code></pre>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>false、true</p>
<p>在进行某些数据判断的时候，需要特别注意类型转换</p>
<p>Empty():判断数据的值是否为空，如果为空返回true，不为空返回false(一个不存在的变量也会返回true)</p>
<p>lsset：判断数据存储的变量本身是否存在，存在返回true，不存在返回false （其变量本身还要有值）</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>符号是“&#x3D;”，表示将右边的结果（可以是变量，数据，常量，和其他运算出来的结果	），保存到内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）。</p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><pre><code>+：执行数据累加
-：数据相减
*：键盘上没有乘法符号，使用*代替，两个数相乘
/：正斜杠代替，表示两个数相除
%：取余运算，两个数相除，保留余数
</code></pre>
<h2 id="比较运算符（返回结果都是布尔类型）"><a href="#比较运算符（返回结果都是布尔类型）" class="headerlink" title="比较运算符（返回结果都是布尔类型）"></a>比较运算符（返回结果都是布尔类型）</h2><p>&gt;</p>
<p>&gt;&#x3D;</p>
<p>&lt;</p>
<p>&lt;&#x3D;</p>
<p>&#x3D;&#x3D;:左边与右边相等（大小相同）</p>
<p>!&#x3D;:左边与右边不同（大小不同）</p>
<p>&#x3D;&#x3D;&#x3D;:全等于，左边与右边相同：的大小以及数据类型都要相同</p>
<p>!&#x3D;&#x3D;&#x3D;:不全等于，只有大小或者类型不同</p>
<pre><code>&lt;?php
//比较运算符
$f1 = &#39;123&#39;;     //字符串
$f2 = 123;      //整形
$f3 = null;
var_dump($f1 == $f2);
var_dump($f1 === $f2);
?&gt;
</code></pre>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h2 id="（针对不同结果进行匹配，满足条件返回true，不满足返回false）"><a href="#（针对不同结果进行匹配，满足条件返回true，不满足返回false）" class="headerlink" title="（针对不同结果进行匹配，满足条件返回true，不满足返回false）"></a>（针对不同结果进行匹配，满足条件返回true，不满足返回false）</h2><p>&amp;&amp;:逻辑与，左边的条件与右边的条件同时成立（两边结果都为true）</p>
<p>||：逻辑或，左边的条件或者右边的条件只要有一个满足即可</p>
<p>!:逻辑非，对已有条件进行取反，本身为true，取反结果为false</p>
<pre><code>&lt;?php
//逻辑运算符
$f1 = &#39;weeked&#39;;     
$f2 = &#39;good&#39;;      
$f3 = null;
var_dump($f1 == &#39;weeked&#39; &amp;&amp; $f2 == &#39;goods&#39;);//逻辑与
echo &#39;&lt;hr&gt;&#39;;
var_dump($f1 == &#39;weeked&#39; || $f2 == &#39;goods&#39;);//逻辑或
echo &#39;&lt;hr&gt;&#39;;
var_dump($f2 == &#39;goods&#39;);
var_dump(!($f2 == &#39;goods&#39;));//逻辑非
?&gt;
</code></pre>
<h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h2><p>连接运算：是PHP中将多个字符串拼接的一种符号</p>
<p>.	将两个字符串连接在一起</p>
<p>.&#x3D;	复合运算类似于+&#x3D;，将左边的内容和右边的内容连接起来。然后重新赋值给左边变量</p>
<pre><code>A.=p ===== A=A.b
</code></pre>
<pre><code class="PHP">//连接运算符
&lt;?PHP
$a = &quot;hello&quot;;
$b = 123;------&gt;
echo $a.$b,&#39;&lt;hr&gt;&#39;;
$a.=$b;-------&gt;
echo $a;
 ?&gt;
</code></pre>
<h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h2><p>在PHP中有一些错误可以提前预知，但是这些错误可能无法避免，但是又不希望报错给用户看，可以使用报错抑制符处理。</p>
<p>错误抑制符通常在产品上线谁用到，在开发时不用，系统本身最好不会出现任何错误</p>
<p>@：在可能存在的表达式前面使用@</p>
<pre><code>&lt;?php
$a = 10;
$b = 0;
 @($a/$b);
?&gt;
</code></pre>
<h2 id="三木运算符"><a href="#三木运算符" class="headerlink" title="三木运算符"></a>三木运算符</h2><p>三木运算：有三个表达式参与的运算 （简单的分支结构缩写）；可以嵌套<br>语法格式</p>
<pre><code>表达式1?表达式2:表达式3
运算：如果表达式1成立，那么执行表达式2，否则执行表达式3
注意：如果表达式本身比较复杂，建议使用括号抱起来
</code></pre>
<pre><code>&lt;?php 
$a = 10;
$b = $a &gt; 10 ? 100 : 0;
echo $b;

?&gt;
</code></pre>
<h2 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h2><p>++：原值+1</p>
<p>–：原址-1</p>
<p>$a++:后置自操作，先把自己的值留下来，然后改变自己，自己给别人的是原来的值</p>
<p>++$b:前置自操作，先改变自己，然后把改变的值给别人</p>
<pre><code>&lt;?php
$a = 1;
$b = 1;

$a++;
++$b;  //独立运算，不参与其他操作

echo $a,$b,&#39;&lt;hr&gt;&#39;;

echo ++$a,$b++,&#39;&lt;hr&gt;&#39;;  //参与了输出运算

echo $a,$b;


?&gt;
</code></pre>
<p>衍生符号：类似自操作</p>
<p>​			+&#x3D;</p>
<p>​			-&#x3D;</p>
<p>​			*&#x3D;</p>
<p>​			&#x2F;&#x3D;</p>
<p>​			%&#x3D;</p>
<p>如果进行除法或者取余运算，要考虑右边表达式的结果是否为0</p>
<pre><code>&lt;?php
$a =10;
$b = 5;

$a-=$b-1;//$a = $a - ($b-1);  优先级！！！

echo $a;


?&gt;
</code></pre>
<h2 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h2><p><strong>系统存储补码</strong></p>
<p>计算机码：计算机在实际存储数据的时候，采用的编码规则（二进制规则）</p>
<p>计算机码：原码、反码、补码，数值本身最左边以为是用来充当符号位：正数为0，负数为1</p>
<p>原码：数据本身从十进制转换为二进制得到的结果</p>
<p>​	正数：左边符号位为0（正数的原码、反码、补码就是原码本身）</p>
<p>​	负数：左边符号位为1</p>
<p>反码：针对负数，符号位不变，其他位取反 </p>
<p>补码：针对负数，反码+1</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算：取计算机中最小的单位（位bit）进行运算</p>
<pre><code>&amp;：按位与，两位都为1，结果为1，否则为0

|：按位或，两个有一个为1，结果为1

~：按位非，一个位如果为1，则变成0，否则反之

^:按位异或，两个相同则为0，不同则为1

&lt;&lt;:按位左移，整个位（32位），向左移动一位，右边补0-------&gt;乘以2的操作

&gt;&gt;:按位右移，整个位（32位），向右移动一位，左边补符号位对应内容（正数补0，负数补1）
</code></pre>
<p>注意：1、系统进行任何运算的时候都是使用的补码</p>
<p>​			2、运算结束之后必须转换成原码，才是最终显示的数据</p>
<pre><code>&lt;?php
//计算机码
$a = 5;
$b = -5;
/*
5	原码：00000101
    反码：00000101   
    补码：00000101

-5：原码：10000101
    反码：11111010 --符号位不变，其他位取反
    补码：11111011 --反码+1
*/
//按位与
var_dump($a &amp; $b);
/*
5补码：00000101
-5补码:11111011
&amp;:	  00000001
*/

//按位非
var_dump(~$a);
/*
5	补码：00000101
~    取反：11111010
运算后为负数，-1变为反码--&gt;11111001
取反变为原码-------------&gt;10000110----&gt;转为10进制为-6
*/
//按位右移
var_dump($b&gt;&gt;2);
/*
5	补码：11111011
&gt;&gt;2		 11111110
-1变为反码：11111101
取反变为原码：10000010-----&gt;-2
*/


?&gt;
</code></pre>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><h2 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h2><p>顺序结构：代码从上到下，顺序执行。（代码执行的最基本结构）</p>
<p>分支结构：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码</p>
<p>循环结构：在某个条件控制范围内，指定的代码块可以重复执行</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>最基本的结构，所有代码默认都是从上往下依次执行</p>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a>if分支</h3><p>​		最简if：只有一段代码，但是可以选择是否执行</p>
<p>​		基本if：有两面性，满足条件或者不满足条件都有对应的代码执行</p>
<pre><code>if(条件表达式)&#123;

//满足条件执行代码

&#125;
else&#123;
//不满足条件执行代码
&#125;
</code></pre>
<p>​		复杂if结构：</p>
<pre><code>if(条件表达式1)&#123;

&#125;
elseif(条件表达式2)&#123;

&#125;
elseif(条件表达式3)&#123;

&#125;
...
else&#123;&#125;
</code></pre>
<pre><code>&lt;?php
$a = &#39;sunday&#39;;

if($a == &#39;sunday&#39;)&#123;
echo &#39;play&#39;;
&#125;
elseif($a == &#39;staday&#39;)&#123;
echo &#39;at home&#39;;
&#125;
else&#123;
echo &#39;NO&#39;;
&#125;

?&gt;
</code></pre>
<h3 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h3><pre><code>switch(条件表达式)&#123;  //条件表达式结果一定是一个值
case 值 1：执行代码；  
break； //结束执行case
case 值 2：执行代码
break；
...
default:代码 //匹配失败代码


&#125;
</code></pre>
<pre><code>&lt;?php
$a = 2;
switch($a)&#123;
case 1:  //$a == 1
    echo &#39;1&#39;;
    break;
case 2:
    echo &#39;2&#39;;
    break;
case 3:
    echo &#39;3&#39;;
    break;
default:
    echo &#39;NO&#39;;

&#125;

?&gt;
</code></pre>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>for循环：通过条件、起始、终止判断执行</p>
<p>while循环：通过判断条件终止</p>
<p>Do-while循环：跟while差不多</p>
<p>foreach循环：专门针对数组</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre><code>for(条件表达式1；条件表达式2；条件表达示3)&#123;
//条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可；只执行一次
//条件表达式2：边界判定，限定循环次数
//条件表达式3：用来执行条件变化
循环体
&#125;
for循环（）里面的条件可以没有（;必须保留），就会无限执行
</code></pre>
<p>[</p>
<pre><code>&lt;?php
for($i=1,$end=10;$i&lt;=$end;$i++)&#123; //
echo &#39;$i&#39;,&#39;&lt;br&gt;&#39;;
&#125;


?&gt;
</code></pre>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code>&lt;?php
$i = 1; //初始化条件在外面
while($i&lt;=10)&#123;  //判定边界
echo $i++,&#39;&lt;br&gt;&#39;;//循环体
&#125;

?&gt;
</code></pre>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>先执行，在判断</p>
<pre><code>&lt;?php
$i = 1;
do&#123;
if($i % 2 !=1)&#123;
    echo $i,&#39;&lt;br&gt;&#39;;
    &#125;
    $i++;
&#125;while($i&lt;=10);

    
?&gt;
</code></pre>
<h2 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h2><p>continue：当前自己循环，后面内部不在执行，同时外部循环如果还有循环体也不再执行</p>
<p>break：当前自己结束，同时外部也结束（外部还有外部，不受影响 ）</p>
<pre><code>&lt;?php
$i = 1;
while($i&lt;=100)&#123;
    if($i % 5 != 0)&#123;
         $i++;
         continue; //break，执行第一次循环后就不在执行了
        
    &#125;
    echo $i++,&#39;&lt;br&gt;&#39;;
&#125;



?&gt;
</code></pre>
<h2 id="流程控制代替语法"><a href="#流程控制代替语法" class="headerlink" title="流程控制代替语法"></a>流程控制代替语法</h2><p>PHP中具体有哪些代替语法呢？PHP应该在HTML中只做数据输出。输出通常有条件判断和循环操作，因此PHP提供了对应分支结构和循环结构的代替语法：全部都是对应的一个模式：</p>
<p>{左大括号使用冒号代替:</p>
<p>}右大括号使用end+对应的其实标记代替</p>
<p>if：if():	endif</p>
<p>switch：switch():	endswitch</p>
<p>for：for():	endfor</p>
<p>while：while():	endwhile</p>
<pre><code>99乘法表
&lt;?php

$a = 1;
$b = 1;
while($b&lt;=9)&#123;
    for($a = 1;$a&lt;=$b;$a++)&#123;
        echo $a.&#39;*&#39;.$b.&#39;=&#39;.$a*$b;
    &#125;
    echo &#39;&lt;br&gt;&#39;;
    $b++;


&#125;


?&gt;
</code></pre>
<pre><code>打印一个99乘法表，用表格打印出出来，php与html联用
&lt;table border=1&gt;
&lt;?php for($j=1;$j&lt;10;$j++) &#123;?&gt;
    &lt;tr&gt;
        &lt;?php for($i=1;$i&lt;=$j;$i++)&#123;?&gt;
            &lt;td&gt;
                &lt;?php echo $i.&#39;*&#39;.$j.&#39;=&#39;.$i*$j;?&gt;


            &lt;/td&gt;
        &lt;?php &#125;?&gt;
    &lt;/tr&gt;
&lt;?php &#125;?&gt;
&lt;/table&gt;

等价代码
&lt;table border=1&gt;
&lt;?php for($j=1;$j&lt;10;$j++) :?&gt;
    &lt;tr&gt;
        &lt;?php for($i=1;$i&lt;=$j;$i++):?&gt;
            &lt;td&gt;
                &lt;?php echo $i.&#39;*&#39;.$j.&#39;=&#39;.$i*$j;?&gt;


            &lt;/td&gt;
        &lt;?php endfor;?&gt;
    &lt;/tr&gt;
&lt;?php endfor;?&gt;
&lt;/table&gt;


//for(;;)&#123;&#125;    &#123;---&gt;:    &#125;---&gt;endfor;
</code></pre>
<h2 id="include和include-once区别"><a href="#include和include-once区别" class="headerlink" title="include和include_once区别"></a>include和include_once区别</h2><p>include：系统碰到一次，执行一次 ；对一个文件重复包含，会加载多次</p>
<p>include_once:系统包含多次，只会执行一次；对一个文件重复包含，只会加载一次</p>
<h2 id="include和require的区别"><a href="#include和require的区别" class="headerlink" title="include和require的区别"></a>include和require的区别</h2><p>include：包含文件出错后，继续执行include后面的代码</p>
<p>require:包含文件出错后，不会执行require后面的代码</p>
<p>require_once、require的区别与include、include_once区别差不多</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>定义函数：
function 函数名([参数])&#123; //[]意思是可有可无
        函数体；
        返回值；
&#125;
</code></pre>
<pre><code>&lt;?php

function display()&#123;
    echo &quot;hellow word&quot;;
&#125;

display();
?&gt;
</code></pre>
<p>函数的特点：<strong>函数的调用可以在函数定义之前</strong></p>
<p>编译和执行是分开的（先编译后执行）</p>
<p>函数执行的内存分析：</p>
<ol>
<li>读取代码进入代码段（编译：将代码编成字节码存储到内存）</li>
<li>根据代码逐行执行</li>
</ol>
<h3 id="函数命名规范"><a href="#函数命名规范" class="headerlink" title="函数命名规范"></a>函数命名规范</h3><ol>
<li>命名规范：由字母、数字、下划线组成，但是不能以字母开头</li>
<li>函数作为一种常用结构，一般遵循以下规则<ul>
<li>驼峰法：showParent</li>
<li>下划线法：show_parent_info</li>
</ul>
</li>
</ol>
<h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><h4 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h4><p>形式参数，不具有 实际意义的参数，是函数定义时使用的参数</p>
<h4 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h4><p>实际参数，具有实际数据意义的参数，是函数调用时使用的参数</p>
<pre><code>&lt;?php
//定义函数
function add($arg1,$arg2)&#123;   //形参可以有多个，使用逗号分开即可	
    echo $arg1+$arg2; //函数体：可以直接调用形参计算	
&#125;
//调用函数
$numb = 10;
add($numb,20);

?&gt;
</code></pre>
<pre><code>1、函数调用add函数：去内存中寻找是否有add函数
2、系统会在栈区开辟内存空间运行函数add
3、系统会查看函数本身是否由形参
4、系统会判断调用的时候是由实参
5、系统默认会将实参的值$numb,20取出，顺序赋值给形参，
6、执行函数体
7、返回函数执行
</code></pre>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>指的是形参的默认值，在函数定义的时候，就给形参一个初始赋值，如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来参与函数内部运算；</p>
<p>注意</p>
<p>1、默认值的定义是放在最后右边的，不能左边形参有默认值，但右边没有</p>
<p>2、函数外部定义的变量名字与定义函数时用的形参名字不冲突，可以重名；多个函数使用相同的形参名字也没问题</p>
<pre><code>&lt;?php
function jian($numb1 = 0,$numb2 = 0)&#123; //当前$numb是形参，在编译时不执行，即便执行也是在jian函数内部，不会与外部的$numb变量冲突
    echo $numb1-$numb2;
    
&#125;
//调用
jian();

?&gt;
</code></pre>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>有的时候，希望在函数内部拿到的外部数据，能够在函数内部改变后，函数外部也改变，难么就需要明确告知函数（定义时），函数才会在调用的时候去主动获取外部数据的内存地址。</p>
<pre><code class="php">&lt;?php
function add($a,&amp;$b)&#123; //引用的变量b的数据存储地址
    $a = $a * $a;
    $b = $b * $b; //修改了$b的数据
    echo $a, &#39;&lt;br&gt;&#39;,$b;
&#125;
$a = 5;
$b = 10;
add($a,$b); //此处传入的实参也必须是&#39;$b&#39;。
echo &#39;&lt;hr&gt;&#39;,$a,&#39;&lt;br&gt;&#39;,$b;
?&gt;
</code></pre>
<h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>函数体：函数内部（{大括号里面}）的所有代码都称之为函数体</p>
<p>函数体：基本上所有代码都可以实现</p>
<ul>
<li>定义变量</li>
<li>定义常量</li>
<li>使用流程控制（分支、循环）</li>
<li>可以调用函数</li>
</ul>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>返回值：</p>
<p>1、return，指的是将函数实现的结果，通过return关键字。返回给函数外部（函数调用处），在PHP中所有函数都有返回值</p>
<p>如果没有明确return使用，那么系统默认返回null<br><strong>函数返回值可以是任意数据类型</strong></p>
<pre><code>&lt;?php
function display()&#123;
echo __FUNCTION__;  //无return

&#125;
display();
echo &#39;&lt;br&gt;&#39;;
var_dump(display());
?&gt;
</code></pre>
<pre><code>&lt;?php
function display()&#123;
return __FUNCTION__;
echo __DIR__;//  此处魔术常量__DIR__不会执行，因为return直接结束函数，后面的内容不会执行
&#125;
display();
echo &#39;&lt;br&gt;&#39;;
var_dump(display());
?&gt;
</code></pre>
<p>2、return还可以在文件中直接使用（不在函数里面）：代表文件将结果return后面的内容，转交给包含当前文件的位置。（通常在系统配置文件中较多使用），在文件中也代表终止文件后面的代码，return后面的内容不会执行。</p>
<pre><code>//1.php:
&lt;?php

$a = 101;
//echo $a,&#39;&lt;br&gt;&#39;;
return &quot;hello world&quot;;
echo $a;

?&gt;

//2.php
&lt;?php

$v = include_once &#39;1.php&#39;;
var_dump($v);

?&gt;


</code></pre>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域：变量（常量）能够访问的区域</p>
<ol>
<li>变量可以在普通代码中定义</li>
<li>变量也可以在函数内部定义</li>
</ol>
<p>在php中作用域严格来说分为两种：但是php内部还定义了一些在严格意义之外的一种，所以总共算三种：</p>
<ol>
<li><p>全局变量：用户普通定义的变量（函数外部定义）</p>
<ul>
<li>所属全局空间：在php中只允许在全局空间中使用：理论上函数内部不可访问</li>
<li>脚本周期：知道脚本运行结束（最后一行代码执行完）</li>
</ul>
</li>
<li><p>局部变量：在函数内部定义的变量</p>
<ul>
<li>所属局部空间：在php中只允许当前函数自己内部使用</li>
<li>函数周期：函数执行结束（函数是在栈区开辟独立内存空间运行）</li>
</ul>
</li>
<li><p>超全局变量：系统定义的变量（预定义变量：$_GET、$_POST等）</p>
<ul>
<li>所属超全局变量：没有访问限制（函数内外都可以访问）</li>
</ul>
<p>超全局变量会将全局变量纳入$GLOBALS里面，$GLOBALS没有作用域限制，所以能够帮助局部变量去访问全局变量：但是必须使用数组</p>
</li>
</ol>
<pre><code>//函数内部访问全局变量
&lt;?php
$a = &quot;hello world&quot;；

function display()&#123;
    echo &quot;13&quot;,&#39;&lt;br&gt;&#39;;
    echo $GLOBALS[&#39;a&#39;]; // 访问全局变量$a

&#125;

display;  //调用函数

?&gt;
</code></pre>
<p>在php中还有一种方式，能够实现全局访问局部，同时局部也可以访问全局：global关键字</p>
<p>global关键字：</p>
<ol>
<li>如果使用global定义的变量名在外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（同一个变量）；</li>
<li>如果使用global定义的变量名在外部不存在（全局变量），系统会自动在全局空间定义一个与局部变量同名的全局变量</li>
</ol>
<p>本质：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。</p>
<p>global语法</p>
<p>global 变量名；</p>
<p>变量名 &#x3D; 值；</p>
<pre><code>&lt;?php

global $a;
$a = &#39;hello world&#39;;

function display()&#123;
    global $a;  //引用，全局变量存在
    echo $a,&#39;&lt;br&gt;&#39;;  //局部访问全局，
    
    global $b;
    $b = &quot;you sure?&quot;;
    
&#125;

display();
echo $b;  //访问函数内部定义的变量， 不是局部变量了
?&gt;
</code></pre>
<p>虽然以上方式可以实现局部与全局的相互访问，但是通常不会这么用。一般如果会存在特殊使用，也会使用参数的形式来访问（还可以使用常量：define定义的）。</p>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>原理：系统在进行编译时，会对static这一行进行初始化：为静态变量赋值，函数在调用时会自动跳过这一行</p>
<p>作用：1、统计当前函数被调用的次数</p>
<p>​			2、统筹函数多次调用得到的不同结果（递归思想）</p>
<pre><code>&lt;?php
function display()&#123;
    $a = 1;
    static $b = 1;
    echo $a++,$b++,&#39;&lt;br&gt;&#39;;

&#125;
display();
display();
display();
?&gt;
</code></pre>
<h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><p>当前有一个变量保存的值，刚好是一个函数的名字，那么就可以使用变量+()来充当函数名使用</p>
<pre><code>&lt;?php

function display()&#123;

    echo __FUNCTION__;

&#125;

$a = &quot;display&quot;;
$a();
?&gt;
</code></pre>
<pre><code>&lt;?php

function sys_function($age1,$age2)&#123;   //假设这是一个系统函数
    $age2 = $age2 + 10; //对用户的输入做处理
    return $age1($age2);
&#125;

function use_function($num)&#123;   //定义一个用户函数，求一个数的4次方   回调函数

    return  $num * $num * $num * $num;
&#125;

var_dump(sys_function(&#39;use_function&#39;,10));

?&gt;
//回调过程

</code></pre>
<p>将一个用户定义的函数传入给另一个函数去使用的过程，称之为回调过程，而被传入的函数称之为回调函数</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><pre><code>&lt;?php

$func = function()&#123;
    echo &quot;hello word&quot;;

&#125;;  //注意此处有；号

//调用匿名函数
$func();
var_dump($func);//查看输出类型   object(Closure)#1 (0) &#123; &#125; ，保存匿名函数本质得到的是一个对象Closure
?&gt;   
</code></pre>
<p>闭包：</p>
<p>closure，一词来源于一下两着结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及他们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）</p>
<p>简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，<strong>是因为在函数内部还有对应的函数在引用</strong>（<strong>函数的内部函数：匿名函数）</strong></p>
<pre><code>闭包函数

&lt;?php

function display()&#123;
    $name = __DIR__;
    
    $b = function() use($name)&#123;
        echo $name;
    &#125;;
    return $b;
&#125;;

$a = display();  //当前局部变量$name在display（）函数运行的时候没有释放，所以在下面调用匿名函数的时候可以被使用。

var_dump($a);
echo &#39;&lt;br&gt;&#39;;
$a();  

?&gt;
</code></pre>
<h2 id="伪类型"><a href="#伪类型" class="headerlink" title="伪类型"></a>伪类型</h2><h2 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h2><h3 id="有关输出函数"><a href="#有关输出函数" class="headerlink" title="有关输出函数"></a>有关输出函数</h3><p>print():类似于echo输出提供的内容，本质是一种结构（不是函数），返回1，可以不需要使用括号</p>
<p>print_r():类似于var_dump,但是比var_dump简单，不会输出数据类型 ，只会输出值（数组打印较多）</p>
<h3 id="有关时间的函数"><a href="#有关时间的函数" class="headerlink" title="有关时间的函数"></a>有关时间的函数</h3><p>date():按照指定格式对应的时间戳（从1970年格林威治时间开始计算的秒数），如果没有特定指定时间戳，那么就是默认当前的时间戳</p>
<p>time():获取当前时间对应的时间戳</p>
<p>microtime():微秒级</p>
<p>strtotime():按照规定格式的字符串转化成时间戳</p>
<pre><code>&lt;?php
//时间函数
echo date(&#39;Y-m-d H:i:s&#39;),&#39;&lt;br&gt;&#39;;
echo time(),&#39;&lt;br&gt;&#39;;
echo microtime(),&#39;&lt;br&gt;&#39;;
echo strtotime(&#39;tomorrow 10 hours&#39;);  //明天10小时
?&gt;
</code></pre>
<h3 id="有关数学的函数"><a href="#有关数学的函数" class="headerlink" title="有关数学的函数"></a>有关数学的函数</h3><p>max():指定参数最大值</p>
<p>min():比较两个数中的最小值</p>
<p>rand():得到一个随机数，指定区间的随机整数</p>
<p>mt_rand(): 与rand一样，只是底层结构不一样，效率比rand高（建议使用）</p>
<p>round():四舍五入</p>
<p>ceil():向上取整（1.1，取2；比1.1大最小的整数）</p>
<p>floor():向下取整</p>
<p>pow():求指定数字的指定指数次结果：pow(2,3) &#x3D;&#x3D; 8</p>
<p>abs():求绝对值</p>
<p>sqrt():求平方根</p>
<h3 id="有关函数的函数"><a href="#有关函数的函数" class="headerlink" title="有关函数的函数"></a>有关函数的函数</h3><p>function_exists():判断指定的的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）</p>
<p>func_get_arg():在自定义函数中去获取指定数值对应的参数</p>
<p>func_get_args:在自定义函数中获取所有的参数（数组形式）</p>
<p>func_num_args():获取当前自定义函数的参数数量</p>
<pre><code>&lt;?php
echo &#39;&lt;pre&gt;&#39;;
function test($a,$b)&#123;
    //获取指定参数，从零开始
    var_dump(func_get_arg(1));
    //在自定义函数中获取所有的参数（数组形式）
    var_dump(func_get_args());
    //获取当前自定义函数的参数数量
    var_dump(func_num_args());
&#125;

function_exists(&#39;test&#39;) &amp;&amp;  test(1,20,3,4); 

?&gt;
</code></pre>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h3><ol>
<li>语法错误：用户书写的代码不符合PHP的语法规范，语法错误会导致代码在编译过程中不通过，所以代码不会执行（Parse error）</li>
<li>运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足的错误（runtime error）</li>
<li>逻辑错误：程序员在写代码的时候不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果。</li>
</ol>
<h3 id="错误代号"><a href="#错误代号" class="headerlink" title="错误代号"></a>错误代号</h3><p>所有看到的错误代码在PHP中都定义成了系统常量（可以直接使用）</p>
<ol>
<li><p>系统错误：</p>
<ul>
<li>E_PARSE:编译错误，代码不会执行</li>
<li>E_ERROR:  致命错误，会导致代码不能正确继续执行（出错的位置断掉）</li>
<li>E_WARNING：警告错误，不会影响代码执行，但是可能得到意想不到的结果</li>
<li>E_NOTICE：通知错误，不会影响代码执行</li>
</ul>
</li>
<li><p>用户错误:用户在使用自定义错误触达的时候</p>
<ul>
<li>E_USER_PARSE</li>
<li>E_USER_ERROR</li>
<li>E_USER_WARNING</li>
<li>E_USER_NOTICE</li>
</ul>
</li>
<li><p>其他</p>
<p>E_ALL，代表着所有错误（通常在进行错误控制的时候使用比较多），建议在开发过程中（开发环境）使用</p>
</li>
</ol>
<p>​		所有以E开头的错误常量（代号）其实都有一个字节存储，然后每一种错误占据一个对应的位，如果想进行一些错误的控制，可以使用位运算进行操作</p>
<p>排除通知级别notice：E_ALL&amp; ~E_NOTICE</p>
<p>只要警告和通知：E_WARNING | E_NOTICE</p>
<h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><ol>
<li><p>系统运行时触发：系统自动根据错误发生后，对比对应的错误信息，输出给用户；主要针对代码的语法错误和运行时的错误</p>
</li>
<li><p>认为触发：知道了某些逻辑可能会出错，从而使用对应的判断代码来触发相应的错提示</p>
<pre><code>
&lt;?php
//处理脚本让浏览器按照指定字符集解析的方法 
header(&#39;Content-type:text/html;charset=utf-8&#39;);
$a = 0;

if($a == 0)&#123;
    trigger_error(&#39;除数不能为0！&#39;);  //人为控制报错，trigger_error()函数设置报错信息,默认notice报错，代码会继续执行
&#125;							//使用trigger_error(&#39;除数不能为0！&#39;,E_USER_ERROR);默认error错误，代码不会继续执行
echo $b/$a;
echo &#39;&lt;br&gt;&#39;,&#39;hello&#39;;



?&gt;
</code></pre>
<h3 id="错误显示设置"><a href="#错误显示设置" class="headerlink" title="错误显示设置"></a>错误显示设置</h3><p>哪些错误该显示，以及该如何显示</p>
</li>
</ol>
<p>​	在php中有两种方式来设置档期脚本的错误处理</p>
<ol>
<li>php配置文件：全局配置php.ini文件<ul>
<li>Display_errors:是否显示错误	</li>
<li>Error_reporting:显示什么级别的错误</li>
</ul>
</li>
</ol>
<p>​	2.可以在运行的php脚本中设置,在脚本中定义的配置项级别比配置文件高</p>
<ul>
<li>Ini_set(‘配置文件中的配置项’,E_ALL);</li>
<li>Ini_set(‘error_reporting’,E_ALL);</li>
<li>Ini_set(‘display_error’,1);</li>
</ul>
<h3 id="错误日志设置"><a href="#错误日志设置" class="headerlink" title="错误日志设置"></a>错误日志设置</h3><ol>
<li>开启日志功能：在php.ini文件中  log_errors &#x3D; On</li>
<li>设置日志存储路径：在php.ini文件中   error_log &#x3D; ‘路径’</li>
</ol>
<h3 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h3><pre><code>&lt;?php

//自定义函数处理机制

//自定义函数

function my_error($errno,$errstr,$errfile,$errline)&#123;
    //判断，当前碰到的错误有哪些
    if(!(error_reporting() &amp; $errno))&#123; //error_repoting没有参数代表当前获取系统错误处理对应的级别
        return;                        //$erron，是系统提供的错误代码：E_ALL,E_NOTICE...
    &#125;

    //判断错误类型
    switch($errno)&#123;
        case E_ERROR:
        case E_USER_ERROR:
            echo &#39;fatal error in file&#39;.$errfile.&#39;on line&#39;.$errline.&#39;&lt;br&gt;&#39;;
            echo &#39;error info :&#39;.$errstr;
            break;
        case E_NOTICE:
        case E_USER_NOTICE:
            echo &#39;notice error in file&#39;.$errfile.&#39;on line&#39;.$errline.&#39;&lt;br&gt;&#39;;
            echo &#39;error info :&#39;.$errstr;
            break;
        case E_WARNING:
        case E_USER_WARNING:
            echo &#39;warning error in file&#39;.$errfile.&#39;on line&#39;.$errline.&#39;&lt;br&gt;&#39;;
            echo &#39;error info :&#39;.$errstr;
            break;
    &#125;
    return true;
&#125;


echo $a;

//修改报错机制
set_error_handler(&#39;my_error&#39;);

echo $a;

</code></pre>
<h2 id="字符串定义语法"><a href="#字符串定义语法" class="headerlink" title="字符串定义语法"></a>字符串定义语法</h2><ol>
<li>单引号：使用单引号包裹</li>
<li>双引号：使用双引号baoguo</li>
<li>nowdoc字符串：</li>
<li>heredoc字符串：</li>
</ol>
<pre><code>&lt;?php

$a = &#39;abcd&#39;;
$b = &#39;asdf&#39;;  //适合定义一行数据



//nowdoc结构
$c = &lt;&lt;&lt;&#39;EOD&#39;
    hello wi shi da sha bi
4545
EOD;



//heredoc结构
$d = &lt;&lt;&lt;EOD
    qwerty
12312
EOD;

var_dump($c,$d);


//这种结构化定义字符串对应的边界符有条件
1、上边界符后面不能跟任何东西，注释与空格也不行
2、下边界符必须顶格，最左边，也只能跟；号，不能跟任何内容
3、结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身

?&gt;
</code></pre>
<h2 id="字符传转义"><a href="#字符传转义" class="headerlink" title="字符传转义"></a>字符传转义</h2><p>转义的含义：在计算机通用协议中，有一些特定的方式定义的字母，系统会特定处理：通常这种方式都是使用反斜杠+字母的特性</p>
<pre><code>例如
\n\r   回车换行的意思
</code></pre>
<p>在php中系统常用的转义符号</p>
<pre><code>\&#39;：在单引号中显示单引号
\&quot;：在双引号中显示双引号
\r：回车符，回到本行行首
\n：移动到下一行
\t：一个tab键
\$：在PHP中使用$符号作为变量符号，因此需要特定识别
</code></pre>
<p>双引号内能识别变量，前提是能够区分变量</p>
<pre><code>&lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);
$a = &#39;hello&#39;;

$b= &quot;123 $a 456&quot;;

$c = &quot;123$a456&quot;; //这样写系统识别不了准确的变量，会报错

$d = &quot;123&#123;$a&#125;456&quot;;//使用变量表示符&#123;&#125;
echo $b,&#39;&lt;br/&gt;&#39;,$c,&#39;&lt;br&gt;&#39;,$d,&#39;&lt;br&gt;&#39;;

//结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身
$t = &lt;&lt;&lt;EOD
    //这个注释会显示出来
    &lt;script&gt;
    alert(&#39;$a&#39;);
    &lt;/script&gt;

EOD;

echo $t;



?&gt;


</code></pre>
<h2 id="字符串长度问题"><a href="#字符串长度问题" class="headerlink" title="字符串长度问题"></a>字符串长度问题</h2><p>strlen()函数，得到字符串的长度，针对标准交换码ASCII，以字节为单位</p>
<p>mbstring扩展会针对不同的字符集，在php.ini中开启</p>
<pre><code>&lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);
$a = &#39;132465&#39;;
$b = &#39;你好我叫崔健123&#39;;

echo strlen($a),&#39;&lt;br&gt;&#39;,strlen($b),&#39;&lt;br&gt;&#39;,&#39;&lt;hr&gt;&#39;;

echo mb_strlen($a),&#39;&lt;br&gt;&#39;,mb_strlen($b),&#39;&lt;br&gt;&#39;,mb_strlen($b,&#39;utf-8&#39;);

?&gt;
</code></pre>
<h2 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h2><p>1、转换函数：implode(),explode(),str_split()</p>
<p>​	Implode(分割字符，数组)：将数组中的元素按照某个规则连接成一个字符串</p>
<p>​	Explode(分割字符，目标字符串)：将字符串按照某个格式进行分割，变成数组</p>
<p>​	Str_split(字符串，字符长度)：按照指定长度拆分字符得到数组</p>
<pre><code>&lt;?php

$a = &#39;cuijiansfsf&#39;;
$b = (str_split($a,3));

var_dump($b);
echo  &#39;&lt;hr&gt;&#39;;

var_dump(implode(&#39;--&#39;,$b));
echo &#39;&lt;hr&gt;&#39;;
$c = implode(&#39;--&#39;,$b);


var_dump(explode(&#39;--&#39;,$c));

?&gt;
</code></pre>
<p>2、截取函数：trim(),ltrim(),rtrim()</p>
<p>​	Trim(字符串[指定字符])：本身默认是用来去除两边的空格（中间不行），但也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：碰到一个不是目标字符的为止</p>
<p>​	Ltrim()：去除左边的</p>
<p>​	Ltrim()：去除右边的</p>
<pre><code>去除默认空格
&lt;?php

$a = &#39;     123       &#39;;
var_dump($a);
echo &#39;&lt;br&gt;&#39;;
var_dump(trim($a));

?&gt;

去除a
&lt;?php

$a = &#39;     123       aaaaa&#39;;
var_dump($a);
echo &#39;&lt;br&gt;&#39;;
var_dump(trim($a,&#39;a&#39;));

?&gt;
</code></pre>
<p>3、截取函数：substr(),strstr()</p>
<p>​	Substr(字符串，起始位置从零开始[长度])：指定位置开始截取字符串，可以截取指定长度（不指定，截取到最后）</p>
<p>​	Strstr(字符串，匹配字符)：从指定位置开始，截取到最后 —&gt;可以去除文件后缀名</p>
<pre><code>substr()函数
&lt;?php

$a = &#39;abcdefkhijk&#39;;

var_dump(substr($a,1));


?&gt;

</code></pre>
<pre><code>//strstr函数
&lt;?php

$a = &#39;cuijian.jpg.php3.php4&#39;;

var_dump(strstr($a,&#39;php&#39;,true)); //默认为false，如果为false，返回该字符串截取的部分；为true则返回原字符串剩余的部分；如果查询不到返回 FALSE。
</code></pre>
<p>4、大小转换函数：strtolower(),strtoupper(),ucfirst()</p>
<p>​	Strtolower()：全部小写</p>
<p>​	Strtoupper()：全部大写</p>
<p>​	Ucfirst()：首字母大写</p>
<pre><code>&lt;?php

$a = &#39;cuijian.jpg.php3.php4&#39;;

var_dump(strtoupper($a));
echo &#39;&lt;br&gt;&#39;;

var_dump(ucfirst($a));
</code></pre>
<p>5、查找函数：strpos(),strrpos()，从零开始算</p>
<p>​	Strpos(字符串，要查询的字符串)：判断字符在目标字符串中首次出现的位置</p>
<p>​	Strrpos(字符串，要查询的字符串)：判断字符在目标字符串中最后一次出现的位置</p>
<pre><code>&lt;?php

$a = &#39;cuijian.jpg.php3.php4&#39;;

var_dump(strpos($a,&#39;jpg&#39;));
echo &#39;&lt;br&gt;&#39;;

var_dump(strrpos($a,&#39;php3&#39;));


</code></pre>
<p>6、替换函数：str_replacea()</p>
<p>​	Str_replace(匹配目标，替换内容，字符串本身)：将目标字符串部分内容进行替换</p>
<pre><code>&lt;?php

$a = &#39;cuijian.jpg.php3.php4&#39;;

var_dump(str_replace(&#39;.php3&#39;,&#39; &#39;,$a));
echo &#39;&lt;br&gt;&#39;;




</code></pre>
<p>7、格式化函数：printf(),sprintf() —&gt;许多语言都有格式话输出，大同小异，基本都差不多</p>
<pre><code>&lt;?php

$age = 20;
$name = &#39;崔健&#39;;


printf(&#39;大家好我叫%s,我进年%d岁&#39;,$name,$age); //%s代表字符串 ，%d代表十进制


?&gt;
</code></pre>
<p>8、其他：srt_repeat(),str_shuffle()</p>
<p>​	Str_repeat()：重复某个字符串N次</p>
<p>​	Str_shuffle()：随机打乱字符串 —-&gt;可用作最简单的验证码</p>
<pre><code>&lt;?php

$a = &#39;cuijian&#39;;

echo str_repeat($a,10),&#39;&lt;br&gt;&#39;;

echo str_shuffle($a);

?&gt;
</code></pre>
<p>9、chr(int $ascii)</p>
<p>返回相对应的ascii所指的单个字符</p>
<pre><code class="php">&lt;?php

echo chr(99);
?&gt;
</code></pre>
<h2 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h2><p>array，数据的组合，指将一组数据存储到一个指定的容器中，用变量指向该容器，然后通过变量一次性得到该容器中的所有数据</p>
<h3 id="数组定义语法"><a href="#数组定义语法" class="headerlink" title="数组定义语法"></a>数组定义语法</h3><p>在php中系统提供多种定义数组的方式：</p>
<ol>
<li><p>使用array关键字</p>
<pre><code>&lt;?php

$a = array(&#39;beijing&#39;,10,&#39;50&#39;);

var_dump($a);

?&gt;
</code></pre>
</li>
<li><p>中括号</p>
<pre><code>&lt;?php

$b = [&#39;linyi&#39;,&#39;shanghai&#39;,50];
var_dump($b);

?&gt;
</code></pre>
</li>
<li><p>隐形定义数组，给变量增加一个中括号，系统自动变成数组</p>
<pre><code>&lt;?php
/*
$变量[]=值1；
$变量[]=值2；	
$变量[下标]=值3；   可以手动设置下标，可以是字母或者数字，默认从零开始
*/

$c[]=&#39;shanghai&#39;;
$c[99]=50;
$c[&#39;diming&#39;]=&#39;lingyi&#39;;
$c[]=&#39;lin&#39;;
var_dump($c);

?&gt;
</code></pre>
<h3 id="PHP数组特点"><a href="#PHP数组特点" class="headerlink" title="PHP数组特点"></a>PHP数组特点</h3><ol>
<li>可以是整数下表或者字符串<ul>
<li>如果下标都为整数：索引数组</li>
<li>如果下表都为字符串：关联数组</li>
</ul>
</li>
<li>不同下标可以混合存在：混合数组</li>
<li>数组元素顺序以放入顺序为准，跟下标无关</li>
<li>数字下标的自增站特性：从零开始自动增长，如果中间手动出现较大的，那么后面的自增长元素 从最大的值+1开始</li>
<li>特殊值下标的自动转换</li>
<li>PHP中数组元素没有类型限制</li>
<li>PHP中数组元素没有长度限制</li>
<li>PHP中的数组中是很大的数据，所以存储的位置是堆区，为当前数组分配一块连续的内存</li>
</ol>
</li>
</ol>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>数组里面的元素又是数组</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>数组中所有的元素都是一顿数组</p>
<pre><code>&lt;?php
$info = array(

    array(&#39;name&#39; =&gt; &#39;cuijian&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;cui&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;jian&#39;,&#39;ahg&#39; =&gt; 20),
    [&#39;123&#39;,10,&#39;cuijain&#39;]
);
echo &#39;&lt;pre&gt;&#39;;
print_r($info);


</code></pre>
<h4 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h4><p>在二维数组元素中，可继续是数组，在php中没有维度限制，不建议使用超过三维，会降低访问效率</p>
<pre><code>&lt;?php
$info = array(

    array(
        [1,2,3],
        [&#39;cuijian&#39;,10,21],
        [&#39;sahgahi&#39;,&#39;beijing&#39;]
    ),
    array(&#39;name&#39; =&gt; &#39;cui&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;jian&#39;,&#39;ahg&#39; =&gt; 20),
    [&#39;123&#39;,10,&#39;cuijain&#39;]
);
echo &#39;&lt;pre&gt;&#39;;
print_r($info);


</code></pre>
<h4 id="异性数组"><a href="#异性数组" class="headerlink" title="异性数组"></a>异性数组</h4><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>普通数组数据的访问都是通过数组元素的下标来实现访问，如果说数组中所有的数据都需要依次输出，就需要我们使用到一些简单化的规则来实现自动获取下标以及输出数组元素。</p>
<pre><code>&lt;?php
$info = array(

    array(&#39;name&#39; =&gt; &#39;cuijian&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;cui&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;jian&#39;,&#39;ahg&#39; =&gt; 20),
    [&#39;123&#39;,10,&#39;cuijain&#39;]
);
echo &#39;&lt;pre&gt;&#39;;
print_r($info[0][&#39;ahg&#39;]);  //获取第一个数组里面，ahg下标的数组聂荣


</code></pre>
<h3 id="Foreach遍历"><a href="#Foreach遍历" class="headerlink" title="Foreach遍历"></a>Foreach遍历</h3><p>原理：本质是数组的内部有一颗指针，默认指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针</p>
<pre><code>Foreach($array as $k =&gt; $v)&#123;

    //循环体

&#125;

</code></pre>
<ol>
<li>foreach会重置指针，让指针指向第一个元素；</li>
<li>进入foreach循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量$k中（存在），将值取出来放到对应的值变量$v中；（指针下移）</li>
<li>进入到循环内部（循环体），开始执行</li>
<li>重复2和3，直到在2的时候遇到指针取不到的内容（指针指向数组最后）</li>
</ol>
<h4 id="遍历一维数组"><a href="#遍历一维数组" class="headerlink" title="遍历一维数组"></a><strong>遍历一维数组</strong></h4><pre><code>

&lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);
$a = array(

    &#39;cuijain&#39;,
    &#39;beijing&#39;,
    &#39;shanghai&#39;

);

foreach($a as $v)&#123;    //此处的$v变量随便定义
   
 
    echo $v,&#39;&lt;br&gt;&#39;;   //注意运行了 三次

&#125;

?&gt;


  
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//带着下标输出
&lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);
$a = array(

    &#39;cuijain&#39;,
    &#39;beijing&#39;,
    &#39;shanghai&#39;

);

foreach($a as $k =&gt; $v)&#123;    //$k为下标，$v为值
   
 
    echo &#39;下标：&#39;,$k,&#39;值：&#39;,$v,&#39;&lt;br&gt;&#39;;   //注意运行了三次

&#125;

?&gt;



</code></pre>
<p><strong>遍历二维数组</strong></p>
<p>在进行数据存储定义的时候，通常二维数组不会两个维度的key下标都是数字，一般是一维为数字（无意义），二维为字符串（数据库表字段），所以在进行遍历的是时候，通常只需要针对一维数组进行遍历，取得二维数组元素，然后二维数组通过下标访问。</p>
<pre><code>&lt;?php
$info = array(

    array(&#39;name&#39; =&gt; &#39;cuijian&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;cui&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;jian&#39;,&#39;ahg&#39; =&gt; 20),
    [&#39;123&#39;,10,&#39;cuijain&#39;]
);

foreach($info as $k =&gt; $v)&#123;
    echo &#39;&lt;pre&gt;&#39;;
    echo $k,&#39;&lt;hr&gt;&#39;;
    print_r($v);

&#125;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////



&lt;?php
$info = array(

    array(&#39;name&#39; =&gt; &#39;cuijian&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;cui&#39;,&#39;ahg&#39; =&gt; 20),
    array(&#39;name&#39; =&gt; &#39;jian&#39;,&#39;ahg&#39; =&gt; 20),
    [&#39;123&#39;,10,&#39;cuijain&#39;]
);

foreach($info as $k =&gt; $v)&#123;
    echo $v[&#39;name&#39;],&#39;&lt;br&gt;&#39;; //通过下标遍历出所有name值

&#125;

</code></pre>
<h3 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h3><p>基于已知边界条件（起始和结束）然后有条件的变化（规律）；</p>
<p>条件：</p>
<ol>
<li>获取数组长度：count(数组)得到数组元素长度</li>
<li>要求数组元素下标是规律的数字</li>
</ol>
<pre><code>&lt;?php

$a = array (
    &#39;a&#39;,
    &#39;b&#39;,
    &#39;c&#39;,
    &#39;d&#39;

);

for($i=0;$i&lt;count($a);$i++)&#123;

    echo $a[$i],&#39;&lt;br&gt;&#39;;

&#125;

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx




//优化

&lt;?php

$a = array (
    &#39;a&#39;,
    &#39;b&#39;,
    &#39;c&#39;,
    &#39;d&#39;

);

for($i=0,$len=count($a);$i &lt; %len;$i++)&#123;

    echo $a[$i],&#39;&lt;br&gt;&#39;;

&#125;
</code></pre>
<h3 id="数组相关的函数"><a href="#数组相关的函数" class="headerlink" title="数组相关的函数"></a>数组相关的函数</h3><h4 id="排序函数：都对原有数组进行了改变"><a href="#排序函数：都对原有数组进行了改变" class="headerlink" title="排序函数：都对原有数组进行了改变"></a>排序函数：都对原有数组进行了改变</h4><p>对数组元素进行排序，都是按照ASCII吗进行比较</p>
<p>sort():顺序排序，下标也重新排序</p>
<p>rsort()：逆序排序,</p>
<p>asort()：顺序排序，下标保留，<code>意味着下标跟着对应的值走</code></p>
<p>arsort():逆序排序，下标保留</p>
<pre><code>&lt;?php

$a = array(4,3,9,2,6,7);
echo &#39;&lt;pre&gt;&#39;;
sort($a);

print_r($a);

rsort($a);

print_r($a);


asort($a);

print_r($a);
</code></pre>
<p>ksort()：顺序排序，按照下标（键名）</p>
<p>krsort()：逆序排序，</p>
<pre><code>&lt;?php

$a = array(4,3,9,2,6,7);
echo &#39;&lt;pre&gt;&#39;;

ksort($a);

print_r($a);

krsort($a);
print_r($a);
</code></pre>
<p>shuffle()：随机打乱数组</p>
<pre><code>&lt;?php

$a = array(4,3,9,2,6,7);
echo &#39;&lt;pre&gt;&#39;;

shuffle($a);

print_r($a);
</code></pre>
<h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p><strong>改变的是指针</strong></p>
<p>reset():重置指针，将数组指针回到首位</p>
<p>end():重置指针，将数组指针指到最后一个元素</p>
<p>next():指针下移，取得下一个元素的值</p>
<p>prev():指针上移，取得上一个元素的值</p>
<p>current():取得当前指针对应的元素值</p>
<pre><code>&lt;?php

$a = array(1,2,3,4,5);
echo &#39;&lt;pre&gt;&#39;;

echo next($a),next($a),&#39;&lt;br&gt;&#39;;

echo current($a),key($a);





</code></pre>
<p>key():获取当前指针对应的下标值</p>
<p><strong>注意</strong>：</p>
<p>next和prev会移动指针。有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过next和prev不能回到正确的指针位置。只有通过end和reset进行指针重置</p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p>count()：统计数组中元素的数量</p>
<p>array_push()：从数组中加入一个元素（数组后面）</p>
<p>array_pop()：从数组中取出一个元素(数组后面)</p>
<p>array_shift()：从数组中取出一个元素（数组前面）</p>
<p>array_unshift()：从数组中加入一个元素(数组前面)</p>
<pre><code>&lt;?php

$a = array();

//php模拟数据结构

//栈，压栈，先进后出
echo &#39;&lt;pre&gt;&#39;;
//压栈
array_push($a,2);
array_push($a,4);
array_push($a,6);

print_r($a);

//出栈

echo array_pop($a),array_pop($a),array_pop($a);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

&lt;?php

$a = array();

//php模拟数据结构

//队列，先进先出
echo &#39;&lt;pre&gt;&#39;;
//后面进
array_push($a,2);
array_push($a,4);
array_push($a,6);

print_r($a);

//前面出

echo array_shift($a),array_shift($a),array_shift($a);




</code></pre>
<p>in_array()：判断一个元素是否在数组中存在</p>
<pre><code>&lt;?php

$a = array(2,5,6,8,4,3);

var_dump(in_array(6,$a));  //返回的是布尔值


</code></pre>
<p>array_keys()：获取一个数组的所有下标，返回一个索引数组</p>
<p>array_values()：获取一个数组的所有值，返回一个索引数组</p>
<pre><code>&lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);

$a = array(
    &#39;name&#39;=&gt;&#39;ci&#39;,
    &#39;age&#39;=&gt;&#39;20&#39;,
    &#39;sex&#39;=&gt;&#39;nan&#39;,
    &#39;banji&#39;=&gt;&#39;20-1&#39;
);
echo &#39;&lt;pre&gt;&#39;;

echo &#39;键名:&#39;;
print_r(array_keys($a));

echo &#39;键值:&#39;;
print_r(array_values($a));

</code></pre>
<h3 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h3><p>编程思想，如何利用数学模式，来解决对应的需求 问题；然后利用代码实现对应的数据模型（逻辑）</p>
<h3 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h3><p>递推算法是一种简单的算法，即通过已知条件，利用特定关系得出中间结论，直至得到结果的算法。递推算法分为顺推和逆推。</p>
<p>顺推：通过简单的条件（已知），然后逐步推演结果。</p>
<p>逆推：通过结果找到规律，然后推到已知条件。</p>
<p>斐波那契数列：1，1，2，3，5，8……  指定位置n的值是多少</p>
<p><strong>递推算法</strong></p>
<pre><code>
&lt;?php

$a[1]=1;
$a[2]=1;
$des = 15;
for($i=3;$i&lt;=$des;$i++)&#123;

    $a[$i] = $a[$i-1]+$a[$i-2];


&#125;
echo &#39;&lt;pre&gt;&#39;;
print_r($a);

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

//这时候就可以写成一个函数，方便使用



&lt;?php
function display($des)&#123;

    if($des == 1 || $des == 2)&#123;
        return 1;
    &#125;
    else&#123;
        $a[1]=1;
        $a[2]=1;

        for($i=3;$i&lt;=$des;$i++)&#123;
  
        $a[$i] = $a[$i-1]+$a[$i-2];


        &#125;
    &#125;

     return $a[$des];
&#125;


echo display(1);
</code></pre>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a><strong>递归算法</strong></h3><p>1、简化问题：找到最优子问题（不能再小）；</p>
<p>2、函数自己调用自己</p>
<p>斐波那契数列：1，1，2，3，5，8……</p>
<p>需求：求指定位置的数列</p>
<p>规律：第一个和第二个为1，从第三个开始为前两个之和</p>
<p>F(N) &#x3D; F(N-1) + F(N-2)</p>
<p>F(N-1) &#x3D; F(N-2) + F(N-3)</p>
<p>……</p>
<p>F(2) &#x3D;  F(1) &#x3D; 1</p>
<p>递归的本质是函数调用函数:一个函数需要开辟一块内存空间，递归会出现同时多个调用N多个函数（自己）：递归的本质是利用空间换取时间</p>
<pre><code>&lt;?php

function display($n)&#123;
    if($n == 1 || $n ==2)&#123;
        return 1;        
    &#125;
    else&#123;
        static $b = 1;
        echo $b++,&#39;&lt;br&gt;&#39;;  // 静态变量
        return display($n-1) + display($n-2);

    &#125;
    

&#125;


echo display(6);


</code></pre>
<h2 id="数组排序算法"><a href="#数组排序算法" class="headerlink" title="数组排序算法"></a>数组排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>重复的走访要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复进行的，进行到知道没有在需要交换，也就是说该数列已经排序完成。</p>
<p>冒泡排序思路：</p>
<ol>
<li>比较相邻元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一个相邻元素作同样的工作，从开始第一个到结尾的最后一对。在这一点，最后的元素应该是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一堆数字需要比较</li>
</ol>
<pre><code>&lt;?php


$arr = array(1,5,6,3,7,2,4);

for($j = 0,$len = count($arr);$j &lt; $len -1;$j++)&#123;
    for($i = 0,$a = count($arr); $i &lt; $a -1;$i++)&#123;
        if($arr[$i] &gt; $arr[$i+1])&#123;
         $tmp = $arr[$i];
         $arr[$i] = $arr[$i+1];
            $arr[$i+1] = $tmp;

        &#125;
    &#125;
&#125;
echo &#39;&lt;pre&gt;&#39;;
print_r($arr);
</code></pre>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序方法。它的工作原理是，每一次从待排序的数据元素中选出最小的（或最大的一个元素），存放在序列的起始位置，直到全部待排序的数据元素排完。选择排序是最不稳定的排序方法（比如序列[5,5,3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p>
<p>思路：</p>
<ol>
<li>假设第一个元素为最小元素，记下住标</li>
<li>寻找右侧剩余的元素，如果有更小的，重新记下最新的下标</li>
<li>如果有新的最小的，交换两个元素</li>
<li>往右重复以上的步骤，直到元素本身是最后一个</li>
</ol>
<pre><code>&lt;?php

$arr =array(2,5,6,3,1,7,9);

for($i=0,$len=count($arr);$i&lt;$len;$i++)&#123;
    $min = $i;
    for($j = $i+1;$j&lt;$len;$j++)&#123;
        if($arr[$j]&lt;$arr[$min])&#123;
            $min = $j;
        &#125;
    &#125;

    if($min != $i)&#123;  // (!$min == $i)和这种写法执行结果不一样
        $tmp = $arr[$i];
        $arr[$i] = $arr[$min];
        $arr[$min] = $tmp;
    &#125;
&#125;

echo &#39;&lt;pre&gt;&#39;;

print_r($arr);
</code></pre>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ol>
<li>认定第一个元素已经排好序</li>
<li>取出第二个元素，作为待插入数据</li>
<li>与已经排序好的数组的最右侧元素开始进行比较</li>
<li>如果后面的小于前面的：说明前面已经排序好的那个数组元素不再对的位置（向后移一个），然后让新的元素填进去（继续向前比：高级）</li>
<li>重复前面的步骤：直到当前元素插入到对的位置</li>
<li>重复以上步骤，直到所有数组元素都插入到对的位置。</li>
</ol>
<pre><code>&lt;?php

$arr = array(5,3,1,9,6,4);

for($i = 1,$len = count($arr);$i &lt; $len;$i++)&#123;

    $tmp = $arr[$i];
    for($j = $i - 1;$j &gt;= 0;$j--)&#123;
        if($arr[$j] &gt; $tmp)&#123;
            $arr[$j+1] = $arr[$j];
            $arr[$j] = $tmp;

        &#125;
        else&#123;
            break; //说明当前待插入元素，比前面的元素要大，说明位置正确，优化运行次数
        &#125;

    &#125;

&#125;
echo &#39;&lt;pre&gt;&#39;;
print_r($arr);
</code></pre>
<p><strong>优化代码</strong></p>
<pre><code>&lt;?php

$arr = array(5,3,1,9,6,8,4);

for($i = 1,$len = count($arr);$i &lt; $len;$i++)&#123;

    $tmp = $arr[$i];
    $flag = True;
    for($j = $i - 1;$j &gt;= 0;$j--)&#123;
        if($arr[$j] &gt; $tmp)&#123;
            $arr[$j+1] = $arr[$j];
            $flag = False;

        &#125;
        else&#123;
            break; //说明当前待插入元素，比前面的元素要大，说明位置正确，优化运行次数
        &#125;

    &#125;
    if($flag != True)&#123;
        $arr[$j+1] = $tmp;
    &#125;
&#125;
echo &#39;&lt;pre&gt;&#39;;
print_r($arr);
</code></pre>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><pre><code>&lt;?php

$arr = array(1,2,3,6,8,9);

function display($arr,$num)&#123;

    for($i=0,$len = count($arr);$i &lt; $len;$i++)&#123;
        if($arr[$i] == $num)&#123;
            return $i;
        &#125;

    &#125;

    return false;

&#125;

var_dump(display($arr,9));
</code></pre>
<h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><pre><code>&lt;?php

$arr = array(1,2,3,5,8,9);

$right = count($arr);
$left = 0;
$res = 5;

while($left &lt;= $right)&#123;
    $middle = floor(($right + $left) / 2);
    if($arr[$middle] == $res)&#123;
        echo $middle;
        break;
                                                                                                                                                                                               
    &#125;
    if($arr[$middle] &lt; $res)&#123;
        $left = $left +1;
    &#125;
    else&#123;
        $right = $right -1;
    &#125;
&#125;

</code></pre>
<p>变为函数</p>
<pre><code class="php">&lt;?php

$arr = array(1,2,3,5,8,9);

function display($arr,$res)&#123;
$right = count($arr);
$left = 0;


while($left &lt;= $right)&#123;
    $middle = floor(($right + $left) / 2);  //floor取整数部分，仅限于正数
    if($arr[$middle] == $res)&#123;
        return $middle;                                                                                                                                                                                 
    &#125;
    if($arr[$middle] &lt; $res)&#123;
        $left = $left +1;
    &#125;
    else&#123;
        $right = $right -1;
    &#125;
&#125;
    return false;
&#125;

var_dump(display($arr,9));
</code></pre>
<h1 id="数据库Mysql"><a href="#数据库Mysql" class="headerlink" title="数据库Mysql"></a>数据库Mysql</h1><p>存储介质分为两种：磁盘和内存</p>
<p>关系型数据库：存储在磁盘中</p>
<p>非关系型数据库：存储在内存中</p>
<h2 id="典型的关系型数据库"><a href="#典型的关系型数据库" class="headerlink" title="典型的关系型数据库"></a>典型的关系型数据库</h2><p>小型关系型数据库：Access，SQLite</p>
<p>中兴关系型数据库：SQL Server，Mysql</p>
<p>大型关系型数据库：Oracle，DB2</p>
<h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>语法</p>
<p> create database 数据库名 [库选项];</p>
<p>库选项：数据库的相关属性</p>
<p>字符集：charset,代表当前数据库下的所有表存储的数据默认指定的字符集（如果不直指定，采用DBMS默认的）</p>
<p>校对集：collate</p>
<h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><pre><code>语法：show database like &#39;匹配模式&#39;;
_：匹配当前位置单个字符
%：匹配指定位置多个字符

获取以my开头的全部数据库 ：&#39;my%&#39;;
获取以m开头，后面第一个字母不确定，最后为database的数据库；&#39;m_database&#39;;
获取以database结尾的所有数据库:&#39;%database&#39;;
</code></pre>
<h4 id="显示数据库创建语句"><a href="#显示数据库创建语句" class="headerlink" title="显示数据库创建语句"></a>显示数据库创建语句</h4><pre><code>show create database 数据库名字; 
</code></pre>
<h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><pre><code>use 数据库名称;
</code></pre>
<h4 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h4><p>修改数据库字符集（库选项）：字符集和校对集</p>
<p>语法</p>
<pre><code>alter database 数据库名字  charset = 字符集;
</code></pre>
<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><pre><code>drop database 数据库名字;
</code></pre>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>语法</p>
<pre><code>create table 表名(字段名 字段类型 [字段属性],字段名 字段类型 [字段属性],......)[表选项];
表选项：
1、charset  字符集
2、collate  校对集
3、存储引擎
</code></pre>
<pre><code>1、
use test;
create table class ......


2、
create table test.class ......
</code></pre>
<pre><code>mysql&gt; create table class(
    -&gt; id varchar(10))
    -&gt; charset gbk;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<h3 id="复制表结构"><a href="#复制表结构" class="headerlink" title="复制表结构"></a>复制表结构</h3><p>语法</p>
<p>create table 新表名 like 表明;  – 此处的表明可以是任何数据库下的表</p>
<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><pre><code>desc 表名;

show columns from 表名;   表明可用反引号 ``
</code></pre>
<h3 id="显示表的创建语句"><a href="#显示表的创建语句" class="headerlink" title="显示表的创建语句"></a>显示表的创建语句</h3><pre><code>show create table 表名;
</code></pre>
<h3 id="mysql语句结束符"><a href="#mysql语句结束符" class="headerlink" title="mysql语句结束符"></a>mysql语句结束符</h3><p>;与\g结束效果一样</p>
<p>\G :   字段名在左面</p>
<pre><code>mysql&gt; show tables\G
*************************** 1. row ***************************
Tables_in_security: emails
*************************** 2. row ***************************
Tables_in_security: referers
*************************** 3. row ***************************
Tables_in_security: uagents
*************************** 4. row ***************************
Tables_in_security: users
4 rows in set (0.00 sec)
</code></pre>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>修改表名</p>
<pre><code>rename table 旧表明 to 新表名;
</code></pre>
<p>修改表选项</p>
<pre><code>alter table 表名 表选项 = 新值;
</code></pre>
<p>新增字段</p>
<pre><code>alter table 表名 add [column] 新字段名 列类型 [列属性] [位置:first、after 字段名 ];
</code></pre>
<pre><code>mysql&gt; alter table class add name varchar(20); -- 默认添加到最后面
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc class;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  |     | NULL    |       |
| name  | varchar(20) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)


mysql&gt; alter table class add age int(10) after id; --指定添加位置
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc class;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  |     | NULL    |       |
| age   | int(10)     | YES  |     | NULL    |       |
| name  | varchar(20) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.01 sec)
</code></pre>
<p>修改字段名</p>
<pre><code>alter table 表名 change 旧字段名 新字段名 字段类型 [列属性] [新位置]; -- 必须写，字段类型
</code></pre>
<p>修改字段类型</p>
<pre><code>alter table 表名 modify 字段名 新类型 [新属性] [新位置];
</code></pre>
<p>删除表字段</p>
<pre><code>alter table 表名 drop 字段名;
</code></pre>
<p>删除表</p>
<pre><code>drop table 表名1,[表名2,......]  -- 可以同时删除多个表
</code></pre>
<h3 id="数据基础操作"><a href="#数据基础操作" class="headerlink" title="数据基础操作"></a>数据基础操作</h3><p>向表中插入字段</p>
<pre><code>insert into 表名 [字段名] values(字段值);
</code></pre>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><pre><code>select 字段列表/* from 表名 [where 字段名 = 值];
</code></pre>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre><code>     delete from 表名 [where 条件]   # 如果没有where条件，系统会默认删除表中所有的数据
</code></pre>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre><code>update 表名 set 字段名 = 新值 [where 条件];
</code></pre>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>常见字符集</p>
<pre><code>ASCII、GB2312、BIG5、GB18030、Unico
</code></pre>
<h3 id="设置客户端字符集"><a href="#设置客户端字符集" class="headerlink" title="设置客户端字符集"></a>设置客户端字符集</h3><p>如果直接通过cmd下的mysql.exe进行中文数据插入，那么很可能出错</p>
<p>出错原因：</p>
<ol>
<li>用户是通过mysql.exe来操作mysqld.exe</li>
<li>真正的SQL执行是mysqld.exe</li>
<li>mysql.exe将数据传入mysqld.exe的时候，没有告知其对应的符号规则（字符集），而mysqld.exe也没有能力自己判断，就会使用自己默认的字符集</li>
</ol>
<p>解决方案：mysql.exe客户端在进行数据操作之前将自己使用的字符集告诉mysqld.exe</p>
<p><strong>快捷方式：set names 字符集</strong></p>
<h3 id="查看系统保存的使用的字符集"><a href="#查看系统保存的使用的字符集" class="headerlink" title="查看系统保存的使用的字符集"></a>查看系统保存的使用的字符集</h3><pre><code>show variables like &#39;character_set_%&#39;;





mysql&gt; show variables like &#39;character_set_%&#39;;
+--------------------------+---------------------------------------------------------------------+
| Variable_name            | Value                                                               |
+--------------------------+---------------------------------------------------------------------+
| character_set_client     | utf8                                                                |
| character_set_connection | utf8                                                                |
| character_set_database   | utf8                                                                |
| character_set_filesystem | binary                                                              |
| character_set_results    | utf8                                                                |
| character_set_server     | utf8                                                                |
| character_set_system     | utf8                                                                |
| character_sets_dir       | D:\xuexi\xiaopi\phpstudy_pro\Extensions\MySQL5.7.26\share\charsets\ |
+--------------------------+---------------------------------------------------------------------+
8 rows in set, 1 warning (0.00 sec)
</code></pre>
<p><strong>修改系统变量</strong></p>
<pre><code>set 变量名 = 值;
</code></pre>
<pre><code>set names = gbk;
等价于
set character_set_client = gbk; # 客户端传入数据给服务端
set character_set_connection = gbk;
set character_set_results = gbk; # 服务端返回数据给客户端
</code></pre>
<h3 id="列类型"><a href="#列类型" class="headerlink" title="列类型"></a>列类型</h3><h4 id="整数类型-1"><a href="#整数类型-1" class="headerlink" title="整数类型"></a>整数类型</h4><p>Tinyint</p>
<pre><code>mysql 默认的为整形增加负数；
实际tinyint表示空间为
-128，127
</code></pre>
<p>迷你整形，，系统采用一个字节来保存的整形：一个字节 &#x3D; 8 位，最大能表示的数值是0-255</p>
<p>Smallint</p>
<p>小整形，系统采用两个字节来保存整形：能表示0-65535之间</p>
<p>Mediumint</p>
<p>中整形，采用三个字节来保存数据</p>
<p>Int</p>
<p>标准整形，采用四个字节来保存数据</p>
<p>Bigint</p>
<p>大整形，采用八个字节来保存数据</p>
<h4 id="无符号设定"><a href="#无符号设定" class="headerlink" title="无符号设定"></a>无符号设定</h4><p>​	表示存储的字段在当前字段中，没有负数，只有正数，区间为0–255</p>
<pre><code>在设置字段属性时，后面加上 unsigned

int_1 tinyint(3) unsigned
</code></pre>
<h3 id="显示长度"><a href="#显示长度" class="headerlink" title="显示长度"></a>显示长度</h3><p>指数据（整型）在数据显示的是时候，到底可以显示多长位</p>
<pre><code>mysql&gt; desc int_table;
+-------+---------------------+------+-----+---------+-------+
| Field | Type                | Null | Key | Default | Extra |
+-------+---------------------+------+-----+---------+-------+
| int_5 | tinyint(4)          | YES  |     | NULL    |       |
| int_1 | tinyint(3) unsigned | YES  |     | NULL    |       |
| int_2 | smallint(6)         | YES  |     | NULL    |       |
| int_3 | mediumint(9)        | YES  |     | NULL    |       |
| int_4 | int(11)             | YES  |     | NULL    |       |
+-------+---------------------+------+-----+---------+-------+
5 rows in set (0.00 sec)

tinyint(3)  表示最长可以显示3位，unsigned说明只能是正数，0-255永远不会超过三个长度
tinyint(4)	表示最长可以显示4位，-128~127

显示长度只是代表了数据是否可以达到指定的长度，但是不会自动满足到指定长度：如果想要数据显示的时候，保持显示长度，那么还需要给字段增加一个zerofill属性才可以
</code></pre>
<h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><p>在Mysql中小数分为两类</p>
<p>浮点型和定点型</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型又称为精度类型：是一种有可能丢失精度的数据类型，数据可能不那么准确（尤其是在超出范围的时候）</p>
<p>浮点型之所以能够存储较大的数据（不精确），原因就是利用存储数据的位，部分来存储指数</p>
<p>如果数据精度丢失，那么浮点型是按照四舍五入的方式计算的</p>
<p>浮点数可用科学技术法存储数据</p>
<h4 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h4><p>Float又称之为单精度类型：系统提供四个字节来存储数据，但是能表示的数据范围比整形大得多，大概是10^38;只能保证大概7个左右的精度（如果数据在7位数内，那么基本是准确的，但是如果超过7位数，那么就是不准确的）</p>
<pre><code>语法
Float:表示不指定小数位的浮点数
Float(M,D):表示一共存储M个有效数字，其中小数部分占D位

</code></pre>
<h4 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h4><p>Double又称之为双精度：系统采用八个字节来存储数据，表示更大的范围，10^308次方，但是精度也只有15位左右</p>
<h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>Decimal</p>
<p>能够保证数据精确的小数（小数部分可能不精确，超出长度会四舍五入），整数部分一定精确</p>
<pre><code>Decimal(M,D)：M表示总长度，最大不能超过65，D代表小数部分长度，最长不超过30；整数部分和小数部分是分开保存的
</code></pre>
<h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><pre><code>日期类型：系统使用三个字节来存储数据，对用格式位：YYYY-mm-dd，能表示的范围是从1000-01-01到9999-12-12，初始值为0000-00-00
</code></pre>
<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><pre><code>时间类型：能够表示某个指定的时间，但是系统同样是提供三个字节来存储，对应格式为：HH:ii:ss,但是mysql中的time类型能够表示时间范围要大得多，能表示从 -838:59:59~838:59:59
</code></pre>
<h3 id="Datetime"><a href="#Datetime" class="headerlink" title="Datetime"></a>Datetime</h3><pre><code>将前面的date和time合并起来，表示的时间，使用8个字节存储数据，格式为YYYY-mm-dd HH:ii:ss	能表示的区间1000-01-01 00:00:00到 9999-12-12 23:59:59 其中可以为0值
</code></pre>
<h3 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h3><pre><code>时间戳类型：mysql的时间戳表示从格林威治时间开始，格式与Datetime一样；同一行内容修改，会自动同步最新时间  
</code></pre>
<h3 id="Year"><a href="#Year" class="headerlink" title="Year"></a>Year</h3><pre><code>年类型：占用一个字节保存，能表示1900~2155，year有两种插入方式：0~99，四位数具体年；两位数插入时，69  70  是个分界线
</code></pre>
<h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><h3 id="Char"><a href="#Char" class="headerlink" title="Char"></a>Char</h3><pre><code>顶长字符，指定长度之后，系统一定会分配指定的空间用于存储数据
语法
char(L)：L代表字符数（中英文一样），存储长度为0-255
</code></pre>
<h3 id="Varchar"><a href="#Varchar" class="headerlink" title="Varchar"></a>Varchar</h3><pre><code>变长字符：指定长度后，系统会根据实际存储数据来计算长度，分配合适的长的存储数据；保存完数据，要记录数据长度，最多占用两个字节
varchar(L)：L代表字符数，L的理论长度为0-65535
</code></pre>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>文本类型：本质上mysql提供了两种文本类型</p>
<p>text：存储普通的字符</p>
<p>blob：存储二进制文本（图片，文件），一般不用blob来存储文件本身，通常是使用一个链接来指向对应的文件本身。</p>
<pre><code>test：系统中提供四种test
Tinytest：系统使用一个字节来保存，实际能够保存的数据为2^8+1
text：使用两个字节保存，实际存储：2^16+2
Mediumtext:使用三个字节保存，实际存储 2^24 +3
Longtext:使用四个字节保存，实际存储为：2^32+4

注意：在选择对应的存储文本时，不用刻意去选择text类型，系统会自动根据存储的数据长度来选择合适的文本类型
</code></pre>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><pre><code>枚举类型：在数据插入之前，先预定及个项，这几个项就是可能得到最终出现的结果。
基本语法：
enum(数据值1,数据值2)
# 系统提供了1到2个字节来存储枚举数据：通过计算enum列举的具体值来选择实际的存储空间，如果数据值在255内，一个字节就够了
</code></pre>
<pre><code>枚举存储原理：实际上字段所存储的值并不是真正的字符串，而是字符串对应的下标：当系统设定枚举类型的时候，会给枚举中每一个元素定义一个下标，这个下标规则从1开始（数组方式）
所以，enum字段实际存储的是数值，在进行数据插入的时候，可以使用相应的数值进行。
</code></pre>
<p>特性：在mysql中系统是自动进行类型转换的：如果数据碰到运算符，系统会自动将数据转换为数值，普通字符串转换成数值0</p>
<pre><code class="mysql">mysql&gt; create table enum(
    -&gt; gender enum(&#39;男&#39;,&#39;女&#39;,&#39;保密&#39;));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; desc enum;
+--------+----------------------------+------+-----+---------+-------+
| Field  | Type                       | Null | Key | Default | Extra |
+--------+----------------------------+------+-----+---------+-------+
| gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;保密&#39;)     | YES  |     | NULL    |       |
+--------+----------------------------+------+-----+---------+-------+
1 row in set (0.00 sec)


mysql&gt; insert into enum values(&#39;男&#39;); insert into enum values(&#39;女&#39;); insert into enum values(&#39;保密&#39;);
Query OK, 1 row affected (0.00 sec)

Query OK, 1 row affected (0.00 sec)

Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from enum;
+--------+
| gender |
+--------+
| 男     |
| 女     |
| 保密   |
+--------+
3 rows in set (0.00 sec)

mysql&gt; insert into enum values(1);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select  * from enum;
+--------+
| gender |
+--------+
| 男     |
| 女     |
| 保密   |
| 男     |
+--------+
4 rows in set (0.00 sec)

mysql&gt; select gender + 0 from enum;
+------------+
| gender + 0 |
+------------+
|          1 |
|          2 |
|          3 |
|          1 |
|          2 |
+------------+
5 rows in set (0.00 sec)
</code></pre>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>集合：是一种将多个数据选项可以同时保存的数据类型，本质是将指定的项按照对应的二进制位进行的控制的：1表示该项被选中，而表示该项没有被选中。


语法：
set(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;,&#39;值4&#39;,……);
系统为set提供多个字节进行保存，但是系统会自动计算来选择具体的存储单元
与enum一样，字段最终存储的是数值

1个字节：set只能由8个选项
2个字节：set只能由16个选项
最多8个字节：64个选项
</code></pre>
<pre><code class="mysql">mysql&gt; create table my_set(
    -&gt; hooby set(&#39;篮球&#39;,&#39;足球&#39;,&#39;羽毛球&#39;,&#39;乒乓球&#39;,&#39;冰球&#39;,&#39;网球&#39;,&#39;橄榄球&#39;,&#39;蹴鞠&#39;)
    -&gt; );
    mysql&gt; insert into my_set values(&#39;足球,网球,蹴鞠&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from my_set;
+----------------------+
| hooby                |
+----------------------+
| 足球,网球,蹴鞠       |
+----------------------+
1 row in set (0.00 sec)

数据存储过程：
            &#39;篮球&#39;,&#39;足球&#39;,&#39;羽毛球&#39;,&#39;乒乓球&#39;,&#39;冰球&#39;,&#39;网球&#39;,&#39;橄榄球&#39;,&#39;蹴鞠&#39;
              1      1       1       1       1      1      1       1
              
              足球,网球,蹴鞠 
              (01000101)
              
              将二进制顺序颠倒
              10100010
              转换为10进制
              162
              
mysql&gt; select hooby+0 from my_set;
+---------+
| hooby+0 |
+---------+
|     162 |
+---------+
1 row in set (0.00 sec)
              
              
              
              
    
    
    
    
</code></pre>
<p>enum：单选框</p>
<p>set：复选框</p>
<h2 id="Mysql记录长度"><a href="#Mysql记录长度" class="headerlink" title="Mysql记录长度"></a>Mysql记录长度</h2><p>mysql的记录最大长度为35535个字节</p>
<p>证明varchar在mysql中只能够达到的理论值（utf8和GBK）</p>
<p>varchar除了存储数据本身外，还需要额外空间来保存记录长度</p>
<pre><code class="mysql">mysql&gt; create table my_utf(
    -&gt; name varchar(65535)
    -&gt; )charset utf8;
ERROR 1074 (42000): Column length too big for column &#39;name&#39; (max = 21845); use BLOB or TEXT instead
# 实际是21844   65535/3=21845
mysql&gt; create table my_utf(
    -&gt; name varchar(21844)
    -&gt; )charset utf8;
Query OK, 0 rows affected (0.01 sec)




# 65525/2=32767  实际最大可用32766

mysql&gt; create table my_gbk(
    -&gt; name varchar(32766)
    -&gt; )charset GBK;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; create table my_gbk1(
    -&gt; name varchar(32767)
    -&gt; )charset GBK;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs

</code></pre>
<h2 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h2><h3 id="NULL属性"><a href="#NULL属性" class="headerlink" title="NULL属性"></a>NULL属性</h3><p>1、在设计表的时候，尽量不要让数据为空</p>
<p>2、mysql的记录长度为65535个字节，如果一个表中有字段允许为NULL，那么系统就会设计保留一个字节来存储NULL，最终有效存储长度为65534个字节</p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>default：默认值，当字段被设计的时候，如果允许默认条件下，用户不进行数据插入，那么就可以使用事先准备好的数据来填充，通常填充的是NULL</p>
<pre><code>mysql&gt; create table my_default(
    -&gt; name varchar(10),
    -&gt; age int default 18
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

# 显示的告知字段使用默认值；在进行数据插入的时候，对字段直接使用default
mysql&gt; insert into my_default values(&#39;jack&#39;,default);
Query OK, 1 row affected (0.00 sec)
</code></pre>
<h3 id="列描述"><a href="#列描述" class="headerlink" title="列描述"></a>列描述</h3><p>查看表的创建才可以看到的注释</p>
<pre><code>mysql&gt; create table my_comment(
    -&gt; name varchar(10)  not null comment &#39;用户名,不为空&#39;,
    -&gt; passwd varchar(10)  not null comment &#39;密码,不为空&#39;
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; desc my_comment;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| name   | varchar(10) | NO   |     | NULL    |       |
| passwd | varchar(10) | NO   |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql&gt; show create table my_comment;
+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table      | Create Table                                                                                                                                                                                                                                                     |
+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| my_comment | CREATE TABLE `my_comment` (
  `name` varchar(10) COLLATE utf8_unicode_ci NOT NULL COMMENT &#39;用户名,不为空&#39;,
  `passwd` varchar(10) COLLATE utf8_unicode_ci NOT NULL COMMENT &#39;密码,不为空&#39;
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci            |
+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt;
</code></pre>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>primary key，具体唯一性</p>
<h3 id="创建主键"><a href="#创建主键" class="headerlink" title="创建主键"></a>创建主键</h3><p>两种创建主键方式</p>
<ol>
<li>直接在需要当作主键的字段之后，增加primary key属性来确定主键</li>
<li>在所有字段之后增加primary key：primary key(字段信息)</li>
</ol>
<h3 id="表后增加"><a href="#表后增加" class="headerlink" title="表后增加"></a>表后增加</h3><pre><code>mysql&gt; create table my_pri1(
    -&gt; name varchar(20)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; alter table my_pri1 add primary key(name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc my_pri1;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| name  | varchar(20) | NO   | PRI | NULL    |       |
+-------+-------------+------+-----+---------+-------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><pre><code>mysql&gt; alter table my_pri1 drop primary key;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc my_pri1;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| name  | varchar(20) | NO   |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h3><p>俩个字段的数据，同一行的内容，上下不能有重复的</p>
<pre><code>mysql&gt; create table xh(
    -&gt; id char(10),
    -&gt; cj char(10),
    -&gt; primary key(id,cj)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; desc xh;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| id    | char(10) | NO   | PRI | NULL    |       |
| cj    | char(10) | NO   | PRI | NULL    |       |
+-------+----------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql&gt;
</code></pre>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>主键一旦增加，对子的字段有数据要求</p>
<ol>
<li>当前字段对应的数据不能为空</li>
<li>当前字段对应的数据类型不能有任何重复</li>
</ol>
<h3 id="主键分类"><a href="#主键分类" class="headerlink" title="主键分类"></a>主键分类</h3><p>采用所对应的字段业务分类</p>
<p>业务主键：主键所在的字段，具有业务意义</p>
<p>逻辑主键：自然增长的整形（应用广泛）</p>
<h2 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h2><pre><code>语法：
在字段后面加一个属性auto_increment
</code></pre>
<pre><code>mysql&gt;  create table increment(
    -&gt;  id int primary key auto_increment,
    -&gt;  name varchar(10),
    -&gt;  passwd varchar(10));
Query OK, 0 rows affected (0.00 sec)

mysql&gt; desc increment;
+--------+-------------+------+-----+---------+----------------+
| Field  | Type        | Null | Key | Default | Extra          |
+--------+-------------+------+-----+---------+----------------+
| id     | int(11)     | NO   | PRI | NULL    | auto_increment |
| name   | varchar(10) | YES  |     | NULL    |                |
| passwd | varchar(10) | YES  |     | NULL    |                |
+--------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

mysql&gt; insert into increment values(null,&#39;小明&#39;,&#39;123465&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from increment;
+----+--------+--------+
| id | name   | passwd |
+----+--------+--------+
|  1 | 小明   | 123465 |
+----+--------+--------+
1 row in set (0.00 sec)

mysql&gt;
</code></pre>
<h3 id="修改自增长"><a href="#修改自增长" class="headerlink" title="修改自增长"></a>修改自增长</h3><pre><code>下一次自增长从多少开始
mysql&gt; alter table increment auto_increment=10;
mysql&gt; show create table increment;
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table     | Create Table                                                                                                                                                                                                                                                                                   |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| increment | CREATE TABLE `increment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(10) COLLATE utf8_unicode_ci DEFAULT NULL,
  `passwd` varchar(10) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)


</code></pre>
<h3 id="删除自增长"><a href="#删除自增长" class="headerlink" title="删除自增长"></a>删除自增长</h3><pre><code>修改自增长所在字段时，如果没有添加auto_increment属性，系统会自动清除该自增长
</code></pre>
<pre><code>mysql&gt; alter table increment modify id int;
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; desc increment;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | NO   | PRI | NULL    |       |
| name   | varchar(10) | YES  |     | NULL    |       |
| passwd | varchar(10) | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><pre><code>查看自增长初始变量设置
mysql&gt; show variables like &quot;auto_increment%&quot;;
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 1     |    # 步长
| auto_increment_offset    | 1     |	# 初始值
+--------------------------+-------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h2><p>unique key，保证对应字段的数据唯一性。</p>
<p>唯一键允许字段为空，表中可以有多个唯一键</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在表字段后面加 unique key</p>
<p>使用方法和主键一样</p>
<pre><code>mysql&gt; create table unique1(
    -&gt; id int primary key auto_increment,
    -&gt; uname varchar(10) unique,
    -&gt; passwd varchar(10) unique
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; desc unique1;
+--------+-------------+------+-----+---------+----------------+
| Field  | Type        | Null | Key | Default | Extra          |
+--------+-------------+------+-----+---------+----------------+
| id     | int(11)     | NO   | PRI | NULL    | auto_increment |
| uname  | varchar(10) | YES  | UNI | NULL    |                |
| passwd | varchar(10) | YES  | UNI | NULL    |                |
+--------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

mysql&gt;
</code></pre>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>index关键字：索引，唯一键是索引的一种</p>
<pre><code>mysql&gt; show create table unique1;
+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table   | Create Table                                                                                                                                                                                                                                                                                                                                  |
+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| unique1 | CREATE TABLE `unique1` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uname` varchar(10) COLLATE utf8_unicode_ci DEFAULT NULL,
  `passwd` varchar(10) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uname` (`uname`),
  UNIQUE KEY `passwd` (`passwd`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci |
+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
<pre><code>mysql&gt; alter table unique1 drop  index uname;
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0
</code></pre>
<h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><p>一对一</p>
<p>一对多</p>
<p>多对多</p>
<h2 id="高级数据操作"><a href="#高级数据操作" class="headerlink" title="高级数据操作"></a>高级数据操作</h2><h3 id="多数据插入"><a href="#多数据插入" class="headerlink" title="多数据插入"></a>多数据插入</h3><pre><code>insert into 表名([字段列表]) values(值列表),(值列表)......
</code></pre>
<pre><code>mysql&gt; insert into my_pri1 values
    -&gt; (&#39;张三&#39;,1),
    -&gt; (&#39;张四&#39;,2),
    -&gt; (&#39;张五&#39;,3);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
</code></pre>
<h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><pre><code>mysql&gt; select * from my_pri1;
+--------+----+
| name   | id |
+--------+----+
| 张三   |  1 |
| 张四   |  2 |
| 张五   |  3 |
+--------+----+
3 rows in set (0.00 sec)

-- 插入数据，提醒我们主键冲突
mysql&gt; insert into my_pri1 values(&#39;晓婷&#39;,3);
ERROR 1062 (23000): Duplicate entry &#39;3&#39; for key &#39;PRIMARY&#39;


-- 1、解决，向表my_pri1插入一条数据，如果主键冲突，修改name字段值为要插入数据值
mysql&gt; insert into my_pri1 values(&#39;晓婷&#39;,3) on duplicate key update name=&#39;晓婷&#39;;
Query OK, 2 rows affected (0.00 sec)

mysql&gt; select * from my_pri1;
+--------+----+
| name   | id |
+--------+----+
| 张三   |  1 |
| 张四   |  2 |
| 晓婷   |  3 |
+--------+----+
3 rows in set (0.00 sec)

-- 2、使用replace替换
语法，把 insert 语句的 insert 替换为 replace 即可

replace into my_pri1 values(&#39;张一&#39;,1);
</code></pre>
<h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><p>一分为二，成倍的增加。从已有的数据中获取数据，并将获取到的数据插入到数据表中</p>
<p>注意主键冲突，</p>
<p>可以短期内添加大量数据，测试表的压力</p>
<pre><code>mysql&gt; select * from class;
+------+------+-------------+
| id   | age  | name        |
+------+------+-------------+
| 1    |   10 | 宕斿仴      |
| 1    |   10 | 崔          |
| 2    |    2 | cuiji0x0aan |
| 2    |    2 | cuijin0x0a  |
| 10   |    3 | 发顺丰      |
| 6    |   20 | 方式        |
| 1    |   20 | 崔健        |
+------+------+-------------+
7 rows in set (0.00 sec)
-- 蠕虫复制
mysql&gt; insert into class select * from class;
Query OK, 7 rows affected (0.00 sec)
Records: 7  Duplicates: 0  Warnings: 0

mysql&gt; insert into class select * from class;
Query OK, 14 rows affected (0.00 sec)
Records: 14  Duplicates: 0  Warnings: 0

mysql&gt; insert into class select * from class;
Query OK, 28 rows affected (0.00 sec)
Records: 28  Duplicates: 0  Warnings: 0

mysql&gt; insert into class select * from class;
Query OK, 56 rows affected (0.00 sec)
Records: 56  Duplicates: 0  Warnings: 0
</code></pre>
<pre><code>mysql&gt; create table users1 like security.users;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; desc users1;
+----------+-------------+------+-----+---------+----------------+
| Field    | Type        | Null | Key | Default | Extra          |
+----------+-------------+------+-----+---------+----------------+
| id       | int(3)      | NO   | PRI | NULL    | auto_increment |
| username | varchar(20) | NO   |     | NULL    |                |
| password | varchar(20) | NO   |     | NULL    |                |
+----------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

-- 蠕虫复制
mysql&gt; insert into users1 select * from security.users;
Query OK, 15 rows affected (0.00 sec)
Records: 15  Duplicates: 0  Warnings: 0

mysql&gt; select * from users1;
+----+----------------------+----------------------+
| id | username             | password             |
+----+----------------------+----------------------+
|  1 | Dumb                 | Dumb                 |
|  2 | Angelina             | I-kill-you           |
|  3 | Dummy                | p@ssword             |
|  4 | secure               | crappy               |
|  5 | stupid               | stupidity            |
|  6 | superman             | genious              |
|  7 | batman               | mob!le               |
|  8 | admin                | admin                |
|  9 | admin1               | admin1               |
| 10 | admin2               | admin2               |
| 11 | admin3               | admin3               |
| 12 | dhakkan              | dumbo                |
| 14 | admin4               | admin4               |
| 15 | 12345678912345678912 | 123456789123456789   |
| 16 | 12345678912345678912 | 12345678912345678912 |
+----+----------------------+----------------------+
15 rows in set (0.00 sec)
</code></pre>
<h3 id="更新数据-1"><a href="#更新数据-1" class="headerlink" title="更新数据"></a>更新数据</h3><pre><code>可用limit做限制
update 表名 set 字段名 = 新值 [where 条件] limit 数字;
</code></pre>
<h3 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h3><pre><code>delete删除数据，但不会重置auto_increment
truncate 表名;  -- 重置auto_increment
</code></pre>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><pre><code>完整的查询指令

select 选项 字段列表 from 数据源 where 条件 gruop by 分组 having 条件 order by 排序 limit 限制;
</code></pre>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a><strong>选项</strong></h4><pre><code>选项 
ALL 默认的，保存所有数据
select all *  == select *

Distinct:去除重复记录
select distinct * 
</code></pre>
<h4 id="字段列表"><a href="#字段列表" class="headerlink" title="字段列表"></a><strong>字段列表</strong></h4><pre><code>字段列表
有时候需要从几张表里获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段命名成不同名的:别名:alias

语法：
字段名 [as]

mysql&gt; select username as name1,username name2 from users1;
+----------+----------+
| name1    | name2    |
+----------+----------+
| Dumb     | Dumb     |
| Angelina | Angelina |
| Dummy    | Dummy    |
| secure   | secure   |
| stupid   | stupid   |
| superman | superman |
| batman   | batman   |
+----------+----------+
7 rows in set (0.00 sec)
</code></pre>
<h3 id="from源"><a href="#from源" class="headerlink" title="from源"></a>from源</h3><h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><pre><code>from 表1,表2......


结果：两张表的记录数相乘，字段数拼接
本质：从第一张表取出一条记录，去拼凑第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的说法：笛卡尔积
</code></pre>
<h4 id="动态数据"><a href="#动态数据" class="headerlink" title="动态数据"></a>动态数据</h4><p>from后面跟的不是一个实体表，而是一个从表中查询出来的二维结果表（子查询）。</p>
<pre><code>from (select 字段列表 from 表) as 表名;
</code></pre>
<pre><code>mysql&gt; select * from (select * from users1) as bieming;
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
|  4 | secure   | crappy     |
|  5 | stupid   | stupidity  |
|  6 | superman | genious    |
|  7 | batman   | mob!le     |
+----+----------+------------+
7 rows in set (0.00 sec)
</code></pre>
<h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><p>分组统计</p>
<pre><code>mysql&gt;  select class_id,count(*),group_concat(name) from student group by class_id;
+----------+----------+----------------------+
| class_id | count(*) | group_concat(name)   |
+----------+----------+----------------------+
|        1 |        3 | 崔健,宋旭,夏红       |
|        2 |        2 | 明明,花花            |
+----------+----------+----------------------+
2 rows in set (0.00 sec)
</code></pre>
<p>多分组</p>
<p>回溯统计</p>
<h4 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h4><p>可以对group by 进行再次筛选</p>
<p>注意：<br>having 是在group by之后，group by实在where之后：where的时候表示将数据从磁盘拿到内存，where之后的所有操作哦都是内存操作</p>
<h4 id="order-by子句"><a href="#order-by子句" class="headerlink" title="order by子句"></a>order by子句</h4><pre><code>语法：
order by 字段 [asc/desc];  # asc升序，默认的
</code></pre>
<h4 id="limit-字句"><a href="#limit-字句" class="headerlink" title="limit 字句"></a>limit 字句</h4><pre><code>limit offset,lenght; # offset：偏移量。从哪开始，lenght：集体获取多少条数据
</code></pre>
<h2 id="查询中的运算符"><a href="#查询中的运算符" class="headerlink" title="查询中的运算符"></a>查询中的运算符</h2><h3 id="算数运算符-1"><a href="#算数运算符-1" class="headerlink" title="算数运算符"></a>算数运算符</h3><p> select 字段列表 from 源表</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><pre><code>&gt;	&gt;=	&lt;	&lt;=	=/&lt;=&gt;	&lt;&gt;:不等于
</code></pre>
<pre><code>-- 以班级为单位，列出两个班中年龄大于20的人数
mysql&gt; select class_id, count(*), group_concat(name,&#39;:&#39;,age) from student where age &gt; 20 group by class_id;
+----------+----------+----------------------------+
| class_id | count(*) | group_concat(name,&#39;:&#39;,age) |
+----------+----------+----------------------------+
|        1 |        2 | 宋旭:21,夏红:30            |
|        2 |        2 | 明明:50,花花:40            |
+----------+----------+----------------------------+
2 rows in set (0.00 sec)
</code></pre>
<p>在Mysql中没有bool值，1代表True，0代表False</p>
<p>Between 条件1 and 条件2，条件1必须小于条件2，<strong>闭区间查找</strong></p>
<pre><code>mysql&gt; select * from student where age between 30 and 50;
+----------+--------+------+-------+
| class_id | name   | age  | hight |
+----------+--------+------+-------+
|        2 | 明明   |   50 |   1.8 |
|        2 | 花花   |   40 |   1.6 |
|        1 | 夏红   |   30 |  1.65 |
+----------+--------+------+-------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="逻辑运算符-1"><a href="#逻辑运算符-1" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>and	or	not</p>
<h3 id="IN-运算"><a href="#IN-运算" class="headerlink" title="IN 运算"></a>IN 运算</h3><pre><code>mysql&gt; select &#39;a&#39; in (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);
+----------------------+
| &#39;a&#39; in (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) |
+----------------------+
|                    1 |
+----------------------+
1 row in set (0.00 sec)
</code></pre>
<p>IS运算</p>
<p>用来判断是否为null</p>
<pre><code>mysql&gt; select * from xh where class_id is null;
+----+--------+----------+
| id | cj     | class_id |
+----+--------+----------+
| 3  | 松溪   | NULL     |
+----+--------+----------+
1 row in set (0.00 sec)

mysql&gt; select * from xh where class_id is not null;
+----+--------+----------+
| id | cj     | class_id |
+----+--------+----------+
| 1  | 崔健   | a        |
| 2  | 崔健   | b        |
| 2  | 宋旭   | b        |
+----+--------+----------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="like运算"><a href="#like运算" class="headerlink" title="like运算"></a>like运算</h3><p>模糊查询</p>
<p>占位符：</p>
<pre><code>_:匹配对应的单个字符
%：匹配多个字符
</code></pre>
<pre><code>mysql&gt; select * from student where name like &#39;崔_&#39;;
+----------+--------+------+-------+
| class_id | name   | age  | hight |
+----------+--------+------+-------+
|        1 | 崔健   |   20 |  1.75 |
+----------+--------+------+-------+
1 row in set (0.00 sec)

mysql&gt; select * from student where name like &#39;崔%&#39;;
+----------+--------+------+-------+
| class_id | name   | age  | hight |
+----------+--------+------+-------+
|        1 | 崔健   |   20 |  1.75 |
+----------+--------+------+-------+
1 row in set (0.00 sec)
</code></pre>
<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>union</p>
<p>默认是去重的</p>
<p>union all 保存所有数据</p>
<p>union 两边查询的字段数要一致</p>
<p><strong>联合查询配合order by</strong></p>
<ol>
<li>使用order by 时两边的查询语句必须括起来</li>
<li>必须配合limit使用</li>
</ol>
<pre><code>mysql&gt; (select * from student where class_id=1 order by age limit 10) union  (select * from student where class_id=2 order by age desc limit 10);
+----------+--------+------+-------+
| class_id | name   | age  | hight |
+----------+--------+------+-------+
|        1 | 崔健   |   20 |  1.75 |
|        1 | 宋旭   |   21 |  1.76 |
|        1 | 夏红   |   30 |  1.65 |
|        2 | 明明   |   50 |   1.8 |
|        2 | 花花   |   40 |   1.6 |
+----------+--------+------+-------+
5 rows in set (0.00 sec)
</code></pre>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>产生的结果是笛卡尔积</p>
<pre><code>mysql&gt; select * from xh cross join student;
</code></pre>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>inner join</p>
<p>原理：从一张表中去除所有记录去另外一张表中匹配；利用匹配条件进行匹配，成功则保留，失败则放弃</p>
<pre><code>语法
表1 [inner] join 表2 on 匹配条件
on 可以用where替换，where替换后现在一次笛卡尔积在进行where匹配
</code></pre>
<pre><code>mysql&gt; select * from student inner join users1 on student.class_id = users1.id;  -- 表名可以用别名
+----------+--------+------+-------+----+----------+------------+
| class_id | name   | age  | hight | id | username | password   |
+----------+--------+------+-------+----+----------+------------+
|        1 | 崔健   |   20 |  1.75 |  1 | Dumb     | Dumb       |
|        1 | 宋旭   |   21 |  1.76 |  1 | Dumb     | Dumb       |
|        2 | 明明   |   50 |   1.8 |  2 | Angelina | I-kill-you |
|        2 | 花花   |   40 |   1.6 |  2 | Angelina | I-kill-you |
|        1 | 夏红   |   30 |  1.65 |  1 | Dumb     | Dumb       |
+----------+--------+------+-------+----+----------+------------+
5 rows in set (0.00 sec)
</code></pre>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>outer join</p>
<p>外连接分两种</p>
<p>左连接：左表是主表 left join</p>
<p>右连接：右表是主表right join</p>
<p>原理：</p>
<ol>
<li>那主表的每一条记录去匹配另一张表的（从表）的每一条记录</li>
<li>如果主表的每一条数据都没有匹配成功，那么也要保留记录；从表对应字段值都为null</li>
</ol>
<pre><code>语法
左连接：主表 left join 从表 on 连接条件
右连接：从表 right join 主表 on 连接条件

左连接对应的主表数据在左边；
右连接对应的主表数据在右边；
</code></pre>
<pre><code>-- 左连接
mysql&gt; select * from xh left join users1 on  xh.id=users1.id;
+----+--------+----------+------+----------+------------+
| id | cj     | class_id | id   | username | password   |
+----+--------+----------+------+----------+------------+
| 1  | 崔健   | a        |    1 | Dumb     | Dumb       |
| 2  | 崔健   | b        |    2 | Angelina | I-kill-you |
| 2  | 宋旭   | b        |    2 | Angelina | I-kill-you |
| 3  | 松溪   | NULL     |    3 | Dummy    | p@ssword   |
+----+--------+----------+------+----------+------------+
4 rows in set (0.00 sec)

-- 右连接
mysql&gt; select * from xh right join users1 on  xh.id=users1.id;
+------+--------+----------+----+----------+------------+
| id   | cj     | class_id | id | username | password   |
+------+--------+----------+----+----------+------------+
| 1    | 崔健   | a        |  1 | Dumb     | Dumb       |
| 2    | 崔健   | b        |  2 | Angelina | I-kill-you |
| 2    | 宋旭   | b        |  2 | Angelina | I-kill-you |
| 3    | 松溪   | NULL     |  3 | Dummy    | p@ssword   |
| NULL | NULL   | NULL     |  4 | secure   | crappy     |
| NULL | NULL   | NULL     |  5 | stupid   | stupidity  |
| NULL | NULL   | NULL     |  6 | superman | genious    |
| NULL | NULL   | NULL     |  7 | batman   | mob!le     |
+------+--------+----------+----+----------+------------+
8 rows in set (0.01 sec)
</code></pre>
<h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><ol>
<li>再连接查询式，使用on得地方用using代替</li>
<li>使用using的前提是对应的两张表连接的字段同名（类似于自然连接自动匹配）</li>
<li>如果使用using关键字，那么对应的同名字段，最在结果中只会保留一个</li>
</ol>
<pre><code>mysql&gt; select * from users1 left join xh  using(id);
+----+----------+------------+--------+----------+
| id | username | password   | cj     | class_id |
+----+----------+------------+--------+----------+
|  1 | Dumb     | Dumb       | 崔健   | a        |
|  2 | Angelina | I-kill-you | 崔健   | b        |
|  2 | Angelina | I-kill-you | 宋旭   | b        |
|  3 | Dummy    | p@ssword   | 松溪   | NULL     |
|  4 | secure   | crappy     | NULL   | NULL     |
|  5 | stupid   | stupidity  | NULL   | NULL     |
|  6 | superman | genious    | NULL   | NULL     |
|  7 | batman   | mob!le     | NULL   | NULL     |
+----+----------+------------+--------+----------+
8 rows in set (0.00 sec)
</code></pre>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>sub query</p>
<p>子查询：在一条sql语句中，嵌入了另一条select语句，那么被嵌入的select语句称之为子查询语句</p>
<p>子查询和主查询的关系</p>
<ol>
<li>子查询是嵌入到主查询当中的：</li>
<li>子查询辅助主查询：要么作为条件，要么作为数据源</li>
<li>子查询其实可以独立存在：是一条完整的select语句</li>
</ol>
<h3 id="子查询分类："><a href="#子查询分类：" class="headerlink" title="子查询分类："></a>子查询分类：</h3><p><strong>按功能分：</strong></p>
<p>标量子查询：子查询返回的结果是一个数据（一行一列）</p>
<p>列子查询：返回的结果是一列（一列多行）</p>
<p>行子查询：返回的结果是一行（一行多列）</p>
<p>表子查询：返回的结果是多行多列</p>
<p>Exists子查询：返回的结果是1或者0（类似于bool）</p>
<p><strong>按位置分<em>：</em></strong>*</p>
<p>where子查询：子查询出现的位置在where条件中</p>
<p>from子查询：子查询出现的位置在from数据源中</p>
<p>标量查询</p>
<pre><code>mysql&gt; select * from users1 where username=(select username from users1 where id=1 );
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row in set (0.00 sec)
</code></pre>
<p>列查询</p>
<pre><code>语法：
主查询 where 条件 in （列查询）


mysql&gt; select id,username,password from users1 where id in (select id from xh);
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
+----+----------+------------+
3 rows in set (0.00 sec)
</code></pre>
<p>行子查询</p>
<pre><code>语法：
主查询 where 条件[(构造一个行元素)] = (行子查询)

mysql&gt; select * from student where (age,hight) = (select max(age),max(hight) from student);
+----------+--------+------+-------+
| class_id | name   | age  | hight |
+----------+--------+------+-------+
|        2 | 明明   |   50 |   1.8 |
+----------+--------+------+-------+
1 row in set (0.00 sec)
</code></pre>
<p>总结：标量、列、行子查询都属于where子查询</p>
<p>Exists子查询</p>
<pre><code>语法
where exists(查询语句); -- 根据查询到的结果进行判断，如果结果存在，返回1，否则返回0


where 1; 永远为真


mysql&gt;  select * from users1 where exists (select id from xh where xh.id=users1.id);  -- 列子查询也可以实现
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
+----+----------+------------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>in</p>
<p>any</p>
<pre><code>= any ：查询结果右一个匹配即可
&lt;&gt; any ： 查询结果中不匹配其中一个即可
</code></pre>
<p>some</p>
<p>以上三个差不多</p>
<p>all</p>
<pre><code> = all： 全部都匹配
&lt;&gt; all：全都不匹配
</code></pre>
<h2 id="整库数据库备份还原"><a href="#整库数据库备份还原" class="headerlink" title="整库数据库备份还原"></a>整库数据库备份还原</h2><p>整库数据库备份也叫SQL数据备份：备份的结果都是SQL指令</p>
<p>在Mysql中提供了一个专门用于备份SQL的客户端：mysqldump.exe</p>
<p>SQL备份是一中非常常见的备份与还原方式，SQL备份不只是备份数据，还备份对应的SQL指令（表结构）</p>
<p>SQL备份不适合特大型数据备份，不适合数据变换频繁型数据库备份</p>
<pre><code>语法：
mysqldump/mysqldump.exe -hPup 数据库名字[表1 [表2......]] &gt; 备份文件地址
</code></pre>
<p>1、整库备份</p>
<pre><code>mysqldump -hlocalhost -P3306 -uroot -proot test &gt; D:/test.sql
</code></pre>
<p>2、多表备份</p>
<pre><code>mysqldump -hlocalhost -P3306 -uroot -proot test student  xh &gt; D:/student.sql
</code></pre>
<h3 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h3><p>数据还原的时候必须指定数据库</p>
<ol>
<li><p>利用mysql.exe客户端：没登陆之前，可以直接使用改客户端进行数据还原</p>
<pre><code>mysql.exe -hPup 数据库 &lt; 文件位置

mysql -hlocalhost -P3306 -uroot -proot test1 &lt; D:/test.sql
</code></pre>
</li>
<li><p>利用sql指令，提供一种导入sql指令的方式</p>
<pre><code>source sql文件位置


source D:/test1.sql
</code></pre>
</li>
<li><p>打开备份文件，复制sql语句</p>
</li>
</ol>
<h2 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>在mysql中，对应的用户管理中（myslq.user表），是由host和user组成复合主键来区分用户的</p>
<ol>
<li>user：代表用户的用户名</li>
<li>host：是允许访问的客户端（ip或者主机地址）。如果是*代表都可以访问</li>
</ol>
<pre><code>两种方式创建用户
 1、直接使用root用户在mysql.user表中插入记录
 2、专门创建用户的Sql指令
 语法：
 create user 用户名 identified by &#39;明文密码&#39;;
 用户：用户名@主机地址
 主机地址：&#39;&#39;或 %&#39;
  
mysql&gt; create user &#39;cj&#39;@&#39;%&#39; identified by &#39;123456&#39;;
Query OK, 0 rows affected (0.01 sec)
</code></pre>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>mysql 中user是带着host本身的（具有唯一性）</p>
<p>在mysql8.0版本，不支持password()函数了，password()对密码进行加密</p>
<p>语法</p>
<pre><code>drop uesr 用户名@host
</code></pre>
<h3 id="修改用户名密码"><a href="#修改用户名密码" class="headerlink" title="修改用户名密码"></a>修改用户名密码</h3><ol>
<li><p>使用专门的修改密码得指令</p>
<pre><code>set password for 用户 = password(&#39;新的明文密码&#39;);
</code></pre>
</li>
<li><p>使用更新语句</p>
<pre><code>update mysql.user set password = password(&#39;新的明文密码&#39;) where user=&#39;&#39; and host = &#39;&#39;;
-- 有的表中不是password字段
</code></pre>
<p>3、使用alter（8.0+版本也可用）</p>
<pre><code>ALTER USER 用户 IDENTIFIED BY &#39;明文密码&#39;;

ALTER USER &#39;cj&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
</code></pre>
</li>
</ol>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ol>
<li>数据权限：增删改查(select&#x2F;delete&#x2F;update&#x2F;insert)</li>
<li>结构权限：结构操作(create&#x2F;alter&#x2F;drop)</li>
<li>管理权限：权限管理(create user&#x2F;grant&#x2F;revoke)</li>
</ol>
<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p>grant：将权限分配给指定的用户</p>
<p>语法：</p>
<pre><code>grant 权限列表 on 数据库.表名(*.*) to 用户

权限列表：使用逗号分隔，可用all privileges代表所有权限

数据库.表名：可以是单表（数据库.表名）   单库（数据库.*）   整库（*.*）
</code></pre>
<h3 id="权限回收"><a href="#权限回收" class="headerlink" title="权限回收"></a>权限回收</h3><p><strong>注意</strong>：自己测试时，发现如果基于用户的权限是逐步赋予的，回收权限时，也要逐步回收</p>
<p>revoke：将权限从用户手里回收</p>
<p>语法</p>
<pre><code>revoke 权限列表 on 数据库.表 from 用户
</code></pre>
<h3 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h3><p>flush，将当前对用户的权限操作进行一个刷新</p>
<p>flush privileges</p>
<h3 id="密码忘记解决方案"><a href="#密码忘记解决方案" class="headerlink" title="密码忘记解决方案"></a>密码忘记解决方案</h3><ol>
<li>停止mysql服务</li>
<li>重新启动服务：mysqld.exe -skip-grant-tables  &#x2F;&#x2F; 启动服务但是跳过权限</li>
<li>启动之后的服务器没有权限概念，直接输入mysql就可登录，而且是root权限</li>
<li>修改root密码</li>
<li>重启服务</li>
</ol>
<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>foreign key</p>
<p>一张表（A）中有一个字段的值，指向另一张表的（B）的主键</p>
<p>A：从表</p>
<p>B：主表</p>
<h3 id="增加外键"><a href="#增加外键" class="headerlink" title="增加外键"></a>增加外键</h3><ol>
<li><p>创建表时增加（类似主键）</p>
<pre><code>[constraint `外键名`] foreign key(外键字段) references 主表(主键)
</code></pre>
</li>
<li><p>创建表之后</p>
<pre><code>alter table 从表 add [constraint `外键名`] foreign key(外键字段) references 主表(主键)
</code></pre>
</li>
</ol>
<h3 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h3><pre><code>alter table 从表名 drop  foreign key `外键名字`
</code></pre>
<pre><code>-- 删除外键索引
alter table 从表名 drop  索引名字
</code></pre>
<h3 id="外键基本要求"><a href="#外键基本要求" class="headerlink" title="外键基本要求"></a>外键基本要求</h3><ol>
<li>外键字段需要保证与关联的主表的主键字段类型完全一致</li>
<li>基本属性相同</li>
<li>外键只能用innodb存储引擎</li>
</ol>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ol>
<li>从表不能插入主表外键没有的字段值</li>
<li>主表不能删除，外键字段已经被引用的字段</li>
</ol>
<h3 id="约束的概念"><a href="#约束的概念" class="headerlink" title="约束的概念"></a>约束的概念</h3><p>可以在创建外键时，对外键约束进行选择性操作</p>
<pre><code>alter table 从表 add [constraint `外键名`] foreign key(外键字段) references 主表(主键) on 约束模式
</code></pre>
<p>主要是针对主表的约束</p>
<ol>
<li>district：严格模式，默认的，不允许操作</li>
<li>cascade：级联模式，一起操作，主表变化，从表变化</li>
<li>set null：置空模式，主表变化（删除），从表对应记录为空：前提，从表对应字段可以为空</li>
</ol>
<pre><code>在进行约束的时候需要制定操作：update  delete
on update cascade on delete set null
</code></pre>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="自动事务"><a href="#自动事务" class="headerlink" title="自动事务"></a>自动事务</h3><p>autocommit,当用户发送一条SQL指令给服务器时，服务器执行之后，不等待用户的反馈，自动同步到数据表</p>
<p>用户提供是都同步的命令</p>
<p>commit：提交（同步到数据库，事务清空）</p>
<p>rollback：回滚（清空事务）</p>
<pre><code class="mysql">查看自动事务是否开启
mysql&gt; show variables like &quot;autocommit%&quot;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)


关闭
mysql&gt; set autocommit = OFF;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show variables like &#39;autocommit%&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h3 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h3><p>开启事务：start transaction</p>
<h3 id="回滚点"><a href="#回滚点" class="headerlink" title="回滚点"></a>回滚点</h3><pre><code>增加回滚点：save 回滚点名字;//字母数字，下划线
回到回滚点：rollback to 回滚点名字


可以设置多个回滚点，但是，回滚到前面的回滚点，后面的就没有了
</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>show variables：查看系统变量</p>
<p>select @@变量名</p>
<p>修改系统变量</p>
<pre><code>临时修改：set 变量名 = 值
永久修改： set global 变量名 = 值
          set @@global.变量名 = 值
          全局修改之后，在新的客户端生效
</code></pre>
<h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>会话变量也称用户变量，会话变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效</p>
<pre><code>定义用户变量：
    set @变量名 := 值;
    
    mysql中的赋值符号  &#39;:=&#39;
</code></pre>
<pre><code>mysql&gt; set @name := &#39;hello world!&#39;;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select @name;
+--------------+
| @name        |
+--------------+
| hello world! |
+--------------+
1 row in set (0.00 sec)
</code></pre>
<p>Mysql是专门存储数据的，允许数据从表中取出存储到变量中，查询得到的数据只能是一行（一个变量对应一个字段值）,mysql中没有数组</p>
<pre><code>1、赋值且查看赋值过程：
    select @变量1 := 字段1, @变量2 := 字段2,...... fron 数据表 where 条件;
</code></pre>
<pre><code class="mysql">mysql&gt; select @username := username, @password := password from users1 where id=6;
+-----------------------+-----------------------+
| @username := username | @password := password |
+-----------------------+-----------------------+
| superman              | genious               |
+-----------------------+-----------------------+
1 row in set (0.00 sec)

mysql&gt; select @username;
+-----------+
| @username |
+-----------+
| superman  |
+-----------+
1 row in set (0.00 sec)

mysql&gt; select @password;
+-----------+
| @password |
+-----------+
| genious   |
+-----------+
1 row in set (0.00 sec)
</code></pre>
<pre><code>2、只赋值，不看过程
    select 字段1, 字段2,...... from 数据源 where 条件 into @变量1, @变量2......
</code></pre>
<pre><code class="mysql">mysql&gt; select username,password from users1 where id=2 into @username,@password;
Query OK, 1 row affected (0.00 sec)

mysql&gt; select @username;
+-----------+
| @username |
+-----------+
| Angelina  |
+-----------+
1 row in set (0.00 sec)

mysql&gt; select @password;
+------------+
| @password  |
+------------+
| I-kill-you |
+------------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>作用范围在begin到end语句块之间。在该语句块里设置的变量，declare语句专门用于定义局部变量</p>
<ol>
<li>局部变量是使用declare关键字声明</li>
<li>局部变量declare语句出现的位置一定是在begin和end之间（beginend实在大型语句块中使用：函数&#x2F;存储过程&#x2F;触发器）</li>
<li>声明语法：declare 变量名 数据类型 [属性];</li>
</ol>
<h2 id="流程结构"><a href="#流程结构" class="headerlink" title="流程结构"></a>流程结构</h2><h3 id="If分支"><a href="#If分支" class="headerlink" title="If分支"></a>If分支</h3><p>if在Mysql中有两种基本用法</p>
<p>1、用在select 查询条件当中，当作一种条件来进行判断</p>
<p>​		</p>
<pre><code>基本语法：
    if(条件,为真结果,为假结果)
</code></pre>
<pre><code class="mysql">mysql&gt; select *, if (age &gt; 30,&#39;符合&#39;,&#39;不符合&#39;) as juje from student;
+----------+--------+------+-------+-----------+
| class_id | name   | age  | hight | juje      |
+----------+--------+------+-------+-----------+
|        1 | 崔健   |   20 |  1.75 | 不符合    |
|        2 | 明明   |   50 |   1.7 | 符合      |
|        2 | 花花   |   40 |   1.6 | 符合      |
|        1 | 夏红   |   30 |  1.65 | 不符合    |
+----------+--------+------+-------+-----------+
4 rows in set (0.00 sec)
</code></pre>
<p>2、用在复杂的语句块中（函数&#x2F;存储过程&#x2F;触发器）</p>
<pre><code>语法

if 条件表达式 then
    满足条件执行的语句
End if;
</code></pre>
<h3 id="复合语法"><a href="#复合语法" class="headerlink" title="复合语法"></a>复合语法</h3><pre><code>if 条件表达式 then
    满足条件执行的语句
else
    不满足条件执行的语句;
    //如果还有其他分支，继续嵌套if
        if 条件表达式 then
            执行语句
        else
            执行语句
        End if;
End if;
</code></pre>
<h3 id="while循环-1"><a href="#while循环-1" class="headerlink" title="while循环"></a>while循环</h3><p>循环体都是需要在大型代码中使用</p>
<pre><code>语法
while 条件 do
    在执行代码
End while;
</code></pre>
<h3 id="结构表示符"><a href="#结构表示符" class="headerlink" title="结构表示符"></a>结构表示符</h3><pre><code>
</code></pre>
<hr>
<h1 id="核心编程技术"><a href="#核心编程技术" class="headerlink" title="核心编程技术"></a>核心编程技术</h1><h2 id="表单传值"><a href="#表单传值" class="headerlink" title="表单传值"></a>表单传值</h2><p>表单传值即浏览器通过表单元素将用户的选择或者输入的数据提交给后台服务器语言</p>
<h3 id="表单传值的方式"><a href="#表单传值的方式" class="headerlink" title="表单传值的方式"></a>表单传值的方式</h3><p>GET传值</p>
<pre><code>1、form表单
&lt;form method=&quot;GET&quot;&gt;表单元素&lt;/form&gt;
</code></pre>
<pre><code>2、a标签
&lt;a href=&quot;www.itcast.cn/index.php?学科=PHP&quot;&gt;
</code></pre>
<pre><code>3、location对象的href属性
&lt;script&gt;location.href=&quot;www.itcast.cn/index.php?学科=PHP&quot;&lt;/script&gt;
</code></pre>
<pre><code>4、location对象的assign()方法
&lt;script&gt;location.assign(&quot;www.itcast.cn/index.php?学科=PHP&quot;)&lt;/script&gt;
</code></pre>
<p>POST传值</p>
<pre><code>1、post表单传值的基本设定
&lt;form method=&quot;POST&quot;&gt;表单元素&lt;/form&gt;
</code></pre>
<p>POST方式跟GET方式的区别</p>
<pre><code>1、get方式主要是用来获取数据，不改变服务器上的资源
2、post方式传输的数据主要是用来增加数据，改变服务器上的资源
3、传输方式上，POST必须用表单，而get可以使用form表单和url
4、get和post能传输的数据大小不同，get为2k，post无限制（实际上，两种方式本身没有数据长度限制，浏览器厂商做了一些限制）
5、get传输数据可在url中显示，post不可见
6、get和post传输的数据格式有区别，get传输简单数据（数值/字符串），post可以提交复杂数据（二进制等）
</code></pre>
<h3 id="PHP接收数据的三种方式"><a href="#PHP接收数据的三种方式" class="headerlink" title="PHP接收数据的三种方式"></a>PHP接收数据的三种方式</h3><pre><code>1、不管是$_GET/$_POST?$_REQUEST,三个都是PHP超全局变量预定义数组，表单的元素的&quot;name&quot;属性的值作为数组的下标，而value属性对应的值就是数组的元素值
2、如果get和post中有同名数组元素，post会覆盖get，可以在php.ini中修改
</code></pre>
<pre><code class="php">&lt;?php


echo &quot;&lt;pre&gt;&quot;;
var_dump($_GET);

echo &quot;&lt;hr&gt;&quot;;

var_dump($_POST);

echo &quot;&lt;hr&gt;&quot;;

var_dump($_REQUEST);
</code></pre>
<h3 id="PHP处理复选框"><a href="#PHP处理复选框" class="headerlink" title="PHP处理复选框"></a>PHP处理复选框</h3><p>浏览器不识别[ ]，但是PHP认为[ ]有特殊性：系统自动认为该符号是数组的形式，所以PHP就会自动地将同名的但是有[ ]的元素组合到一起形成一个数组</p>
<pre><code class="HTML">&lt;body&gt;
   &lt;form method=&quot;post&quot; action=&quot;2.php&quot;&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;basketball&quot;&gt;basketball
        &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;football&quot;&gt;football
        &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;pingpang&quot;&gt;pingpang
        &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;提交&quot;/&gt;
   &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<pre><code>&lt;?php


echo &quot;&lt;pre&gt;&quot;;

print_r($_POST);
</code></pre>
<pre><code class="php">&lt;?php


echo &quot;&lt;pre&gt;&quot;;

print_r($_POST);

$hobby = isset($_POST[hobby])?$_POST[hobby]:array();  //isset只在验证未曾定义的变量时才会返回false

$hobby_str = implode(&#39;,&#39;,$hobby); // 将传递的数组转换为字符串，存储到数据库中
echo $hobby_str;
echo &#39;&lt;hr&gt;&#39;;
$arryy = explode(&#39;,&#39;, $hobby_str);  // 将数据从数据库中拿出来，重新转换为数组
print_r($arryy);
</code></pre>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>原理：文件从用户本地电脑通过传输方式（web表单）保存到服务器所在电脑指定的目录下</p>
<p>1、增加文件上传的表单：浏览器请求一个服务器的HTML脚本（包含文件上传表单）</p>
<p>2、用户从本地选择一个文件（点击文件上传按钮）</p>
<p>3、用户点击上传，文件会通过互联网传输到服务器上</p>
<p>4、服务器操作系统会将文件保存到临时目录：是以临时文件格式保存（windows下tmp）</p>
<p>5、服务器脚本开始工作：判断文件有效（是否是指定的文件类型）</p>
<p>6、服务器脚本将有效文件从临时目录移动到指定的目录下</p>
<h3 id="表单写法"><a href="#表单写法" class="headerlink" title="表单写法"></a>表单写法</h3><pre><code class="HTML">1、method属性：表单提交方式必须为POST
2、enctype属性：form表单属性，主要是规范表单数据的编码方式
    application/x-www-form-urlencoded：在发送前编码所有字符
    multipart/form-data：不对字符编码，在使用包含文件上传控件的表单时，必须使用该值
    text/plain：空格转换为&quot;+&quot;号，但不对特殊字符编码。
3、上传表单：file表单
</code></pre>
<pre><code class="html">&lt;body&gt;
   &lt;form method=&quot;post&quot;  enctype=&quot;multipart/form-data&quot; action=&quot;2.php&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;image&quot; /&gt;
        &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;文件上传&quot;/&gt;
   &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<h3 id="FILES"><a href="#FILES" class="headerlink" title="$_FILES"></a>$_FILES</h3><p>$_FILES接收到上传的文件</p>
<pre><code class="php">array(1) &#123;
  [&quot;image&quot;]=&gt;
  array(5) &#123;
    [&quot;name&quot;]=&gt;   			//上传的文件名，实际用来保存扩展名
    string(10) &quot;崔健.jpg&quot;   
    [&quot;type&quot;]=&gt;				//文件上传到服务器后操作系统保存的临时路径
    string(10) &quot;image/jpeg&quot;
    [&quot;tmp_name&quot;]=&gt;			//MIME类型
    string(22) &quot;C:\Windows\php48A2.tmp&quot;
    [&quot;error&quot;]=&gt;		//文件上传的带代号 0：文件上传成功。1：文件超过了PHP.ini中的upload_max_filesize选项的值。
    int(0)			//2：上传文件的大小超过了HTML表单中MAZ_FILE_SIZE的值。3：文件只有部分上传。
                    //4：用户没有选择上传文件。6：找不到临时文件夹。7：文件写入失败
        
        
    [&quot;size&quot;]=&gt;		//文件大小
    int(28573)
  &#125;
&#125;
</code></pre>
<h3 id="移动临时文件到指定目录"><a href="#移动临时文件到指定目录" class="headerlink" title="移动临时文件到指定目录"></a>移动临时文件到指定目录</h3><p>1、判断是否为上传文件</p>
<p>2、移动文件</p>
<pre><code class="PHP">&lt;?php

header(&#39;Content-type:text/html;charset=utf-8&#39;);

$file = $_FILES[&#39;image&#39;];

if (is_uploaded_file($file[&#39;tmp_name&#39;]))&#123;  // 判断的是临时文件
    if(move_uploaded_file($file[&#39;tmp_name&#39;],&#39;upload/&#39;.$file[&#39;name&#39;]))&#123;  // 移动文件(被移动的文件路径,要去的地方+文件名)
        echo &quot;文件保存成功&quot;;
    &#125;
    else&#123;
        echo &quot;文件保存失败！&quot;;
    &#125;
&#125;
else&#123;
    echo &quot;上传失败！&quot;;
&#125;


?&gt;

</code></pre>
<h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p>$_FILES变量的数据结构</p>
<p><strong>同名表单</strong></p>
<pre><code class="HTML">&lt;body&gt;
   &lt;form method=&quot;post&quot;  enctype=&quot;multipart/form-data&quot; action=&quot;2.php&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;image[]&quot; /&gt;
        &lt;input type=&quot;file&quot; name=&quot;image[]&quot; /&gt;
        &lt;input type=&quot;file&quot; name=&quot;image[]&quot; /&gt;
        &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;文件上传&quot;/&gt; 
   &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="php">Array
(
    [image] =&gt; Array
        (
            [name] =&gt; Array
                (
                    [0] =&gt; 371324200202240351.jpg
                    [1] =&gt; 372328200207090934.jpg
                    [2] =&gt; 崔健.jpg
                )

            [type] =&gt; Array
                (
                    [0] =&gt; image/jpeg
                    [1] =&gt; image/jpeg
                    [2] =&gt; image/jpeg
                )

            [tmp_name] =&gt; Array
                (
                    [0] =&gt; C:\Windows\php330F.tmp
                    [1] =&gt; C:\Windows\php3310.tmp
                    [2] =&gt; C:\Windows\php3311.tmp
                )

            [error] =&gt; Array
                (
                    [0] =&gt; 0
                    [1] =&gt; 0
                    [2] =&gt; 0
                )

            [size] =&gt; Array
                (
                    [0] =&gt; 10855
                    [1] =&gt; 15306
                    [2] =&gt; 28573
                )

        )

)
</code></pre>
<p><strong>不同名表单</strong></p>
<pre><code class="html">&lt;body&gt;
   &lt;form method=&quot;post&quot;  enctype=&quot;multipart/form-data&quot; action=&quot;2.php&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;image1&quot; /&gt;
        &lt;input type=&quot;file&quot; name=&quot;image2&quot; /&gt;
        &lt;input type=&quot;file&quot; name=&quot;image3&quot; /&gt;
        &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;文件上传&quot;/&gt; 
   &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="php">Array
(
    [image1] =&gt; Array
        (
            [name] =&gt; 371324200202240351.jpg
            [type] =&gt; image/jpeg
            [tmp_name] =&gt; C:\Windows\php6F7.tmp
            [error] =&gt; 0
            [size] =&gt; 10855
        )

    [image2] =&gt; Array
        (
            [name] =&gt; Default.jpg
            [type] =&gt; image/jpeg
            [tmp_name] =&gt; C:\Windows\php6F8.tmp
            [error] =&gt; 0
            [size] =&gt; 872927
        )

    [image3] =&gt; Array
        (
            [name] =&gt; 372328200207090934.jpg
            [type] =&gt; image/jpeg
            [tmp_name] =&gt; C:\Windows\php6F9.tmp
            [error] =&gt; 0
            [size] =&gt; 15306
        )

)
</code></pre>
<p><strong>同名数组遍历</strong></p>
<pre><code class="php">&lt;?php

header(&#39;Content-type:text/html;charset=utf-8&#39;);
echo &quot;&lt;pre&gt;&quot;;


if(isset($_FILES[&#39;image&#39;][&#39;name&#39;]) &amp;&amp; is_array($_FILES[&#39;image&#39;][&#39;name&#39;]))&#123;
    $images = array();
    foreach($_FILES[&#39;image&#39;][&#39;name&#39;] as $k =&gt; $v)&#123;
        $images[] = array(
            &#39;name&#39; =&gt; $v,
            &#39;type&#39; =&gt; $_FILES[&#39;image&#39;][&#39;type&#39;][$k],
            &#39;tmp_name&#39; =&gt; $_FILES[&#39;image&#39;][&#39;tmp_name&#39;][$k],
            &#39;error&#39; =&gt; $_FILES[&#39;image&#39;][&#39;error&#39;][$k] ,
            &#39;size&#39; =&gt; $_FILES[&#39;image&#39;][&#39;size&#39;][$k] 
        );
        
    &#125;
    print_r($images);
&#125;


?&gt;

</code></pre>
<p><strong>一次遍历实现文件上传</strong></p>
<pre><code class="php">&lt;?php

$arr = $_FILES[&#39;image&#39;];
if(isset($arr[&#39;name&#39;]) &amp;&amp; is_array($arr[&#39;name&#39;]))&#123;
    foreach($arr[&#39;name&#39;] as $k =&gt; $v)&#123;
        if (is_uploaded_file($arr[&#39;tmp_name&#39;][$k]))&#123;  
            if(move_uploaded_file($arr[&#39;tmp_name&#39;][$k],&#39;upload/&#39;.$arr[&#39;name&#39;][$k]))&#123;  
                echo &quot;文件保存成功&quot;;
            &#125;
            else&#123;
                echo &quot;文件保存失败！&quot;;
            &#125;
        &#125;
        else&#123;
            echo &quot;上传失败！&quot;;
        &#125;
    &#125;
&#125;else&#123;
    echo 2;
&#125;
?&gt;
</code></pre>
<p><strong>不同命数组</strong></p>
<pre><code class="php">&lt;?php

$arr = $_FILES;

foreach($arr as $file)&#123;
    if(is_uploaded_file($file[&#39;tmp_name&#39;]))&#123;
        if(move_uploaded_file($file[&#39;tmp_name&#39;],&#39;upload/&#39;.$file[&#39;name&#39;]))&#123;
            echo &quot;文件上传成功&quot;;
        &#125;else&#123;
            echo &quot;1&quot;;
            echo &quot;文件表保存失败&quot;;
        &#125;
    &#125;else&#123;
        echo &quot;2&quot;;
        echo &quot;文件上传失败&quot;;
    &#125;
&#125;
?&gt;
</code></pre>
<h3 id="文件上传后续问题"><a href="#文件上传后续问题" class="headerlink" title="文件上传后续问题"></a>文件上传后续问题</h3><p>实现上传功能代码的重复利用：封装上传函数</p>
<p>功能：上传文件</p>
<p>条件：条件判断</p>
<ol>
<li>需要上传的文件信息：对应的五个元素的数组</li>
<li>文件类型是否合适？外部指定MIME类型</li>
<li>文件存储到什么位置？外部指定</li>
<li>文件格式限制（后缀）？外部指定</li>
<li>文件大小限制？外部指定</li>
</ol>
<p>结果：实现文件上传</p>
<ol>
<li>成功：返回文件路径和名字</li>
<li>失败：返回false，指定错误原因</li>
</ol>
<pre><code class="php">&lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);
/*

实现文件上传（单文件）

    1、array $file,需要上传的文件信息：一维五元素数组（name\tmp_name\error\size\type）
    2、array $allow_type,允许上传的MIME类型
    3、string $path,存储路径
    4、string $error，如果出错的原因
    5、array $allow_format = array(), 允许上传的文件格式
    6、int $max_size = 2000000，允许上传的最大值
*/

function upload_single($file,$allow_type, $path, &amp;$error, $allow_format = array(), $max_size)&#123;
    // 判断文件是否有效
    // 文件无效
    if(!is_array($file) || !isset($file[&#39;error&#39;]))&#123;
        $error = &quot;不是一个有效的上传文件！&quot;;
        return false;
    &#125;

    // 判断存储路径是否有效

    if(!is_dir($path))&#123;
        // 路径不存在
        $error = &quot;文件存储路径不存在！&quot;;
        return false;
    &#125;

    // 判断文件上传过程是否出错
     switch($file[&#39;error&#39;])&#123;
        case 1:
        case 2:
            $error = &#39;文件超过服务器大小!&#39;;
            return false;
        case 3:
            $error = &#39;文件上传过程中出现我问题，只上传了一部分!&#39;;
            return false;
        case 4:
            $error = &#39;用户没有选中要上传的文件！&#39;;
            return false;
        case 6:
        case 7:
            $error = &#39;文件保存失败!&#39;;
            return false;

     &#125;

     // 判断MIME类型
     if(!in_array($file[&#39;type&#39;], $allow_type))&#123;
        $error = &quot;当前文件类型不允许上传！&quot;;
        return false;
     &#125;



    // 判断后缀是否允许
    $ext = ltrim(strrchr($file[&#39;name&#39;], &#39;.&#39;), &#39;.&#39;);
    if(!empty($allow_format) &amp;&amp; !in_array($ext, $allow_format))&#123;
        $error = &quot;当前文件格式不允许上传！&quot;;
        return false;
    &#125;

    // 判断当前文件大小是否满足当前需求
    if($file[&#39;size&#39;] &gt; $max_size)&#123;
        //文件过大
        $error = &quot;当前上传的文件超出大小，最大允许&quot;. $max_size.&quot;字节&quot;;
        return false;
    &#125;
    



    // 构造文件名字：类型——年月日+随机字符串.$ext
    $fullname = strstr($file[&#39;type&#39;], &#39;/&#39;,TRUE) . date(&#39;Ymd&#39;);

    // 产生随机字符串
    for($i=0;$i&lt;4;$i++)&#123;
        $fullname .= chr(mt_rand(65,90)); 
    &#125;

    // 拼凑后缀
    $fullname .= &#39;.&#39;.$ext;



    // 移动到指定目录
    if(!is_uploaded_file($file[&#39;tmp_name&#39;]))&#123;
        $error = &quot;不是上传文件！&quot;;
        return false;
    &#125;

    if(move_uploaded_file($file[&#39;tmp_name&#39;],$path . &#39;/&#39; . $fullname))&#123;
        //成功
        return $fullname;
    &#125;else&#123;
        $error = &quot;文件移动失败&quot;;
        return false;
    &#125;

&#125;



// 提供数据

$file = $_FILES[&#39;image&#39;];
$allow_type = array(&#39;image/jpg&#39;,&#39;image/jpeg&#39;,&#39;image/gif&#39;,&#39;image/png&#39;);
$path = &quot;upload&quot;;
$allow_format = array(&#39;jpg&#39;,&#39;png&#39;,&#39;jpeg&#39;,&#39;gif&#39;);
$max_size = 8000000;


if($filename = upload_single($file,$allow_type, $path, $error, $allow_format, $max_size))&#123;
    echo $filename;
&#125;else&#123;
    echo $error;
&#125;





?&gt;
</code></pre>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;form method=&quot;post&quot;  enctype=&quot;multipart/form-data&quot; action=&quot;1.php&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;image&quot; /&gt;
        &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;文件上传&quot;/&gt; 
   &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="Mysql扩展"><a href="#Mysql扩展" class="headerlink" title="Mysql扩展"></a>Mysql扩展</h2><p><code>mysql_connect()</code> 是 PHP 旧版中用于连接 MySQL 数据库的函数，在 PHP 7.0.0 版本以后已被废弃，并且在 PHP 8.0.0 版本中完全移除。</p>
<p>解决方法：</p>
<ol>
<li>如果你使用的是 PHP 5.x 版本，请升级到 PHP 7.x 或 PHP 8.x，并使用 <code>mysqli</code> 或 <code>PDO</code> 替代 <code>mysql</code> 函数。</li>
<li>修改代码，使用 <code>mysqli_connect()</code> 或 <code>PDO</code> 连接数据库。</li>
</ol>
<p>例如，使用 <code>mysqli_connect()</code> 替换 <code>mysql_connect()</code>,mysqli是需要指定<code>$link</code>，旧版的mysql可以省略</p>
<pre><code class="php">// 旧的 mysql_connect() 用法
// $link = mysql_connect(&#39;localhost&#39;, &#39;mysql_user&#39;, &#39;mysql_password&#39;);
// mysql_select_db(&#39;database&#39;, $link);
 
// 使用 mysqli_connect() 替换
$link = mysqli_connect(&#39;localhost&#39;, &#39;mysql_user&#39;, &#39;mysql_password&#39;, &#39;database&#39;);
 
// 确保连接成功
if (!$link) &#123;
    die(&#39;Connect Error (&#39; . mysqli_connect_errno() . &#39;) &#39; . mysqli_connect_error());
&#125;
</code></pre>
<p>使用PDO</p>
<pre><code class="php">// 旧的 mysql_connect() 用法
// $link = mysql_connect(&#39;localhost&#39;, &#39;mysql_user&#39;, &#39;mysql_password&#39;);
// mysql_select_db(&#39;database&#39;, $link);
 
// 使用 PDO 替换
try &#123;
    $pdo = new PDO(&quot;mysql:host=localhost;dbname=database&quot;, &#39;mysql_user&#39;, &#39;mysql_password&#39;);
    // 设置 PDO 错误模式为异常
    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
&#125; catch (PDOException $e) &#123;
    die(&quot;Connection failed: &quot; . $e-&gt;getMessage());
&#125;
</code></pre>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>连接资源默认式超全局的，任何地方都可以使用该资源进行数据库的其他操作。</p>
<p>补充：mysql_connect默认是对一个服务器之连接一次（如果再次运行，返回的是同一个资源），但是如果有需要连接同一个资源两次，那么可以使用用第四个参数：TRUE</p>
<pre><code>mysql_connect(服务器地址,用户名,密码)
</code></pre>
<h3 id="设置连接编码"><a href="#设置连接编码" class="headerlink" title="设置连接编码"></a>设置连接编码</h3><pre><code class="php">形式1：mysql_query(&quot;set names XXX&quot;)
形式2: mysql_set_charset(&quot;xxx&quot;)
//mysqli
//mysqli_set_charset($link,&#39;utf8&#39;);
</code></pre>
<h3 id="选定要使用的数据库"><a href="#选定要使用的数据库" class="headerlink" title="选定要使用的数据库"></a>选定要使用的数据库</h3><pre><code class="php">形式1：mysql_query(&quot;use XXX&quot;) //里面是sql指令，返回的结果是TRUE或者FALSE
形式2：mysql_select_db(&quot;XXX&quot;) //简化了
//mysqli
//mysqli_query($link,&quot;use security&quot;);
</code></pre>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><pre><code class="php">mysql_close(); 
//mysqli
//mysqli_close($link);
</code></pre>
<pre><code class="php">&lt;?php
$co = mysql_connect(&#39;localhost:3306&#39;,&#39;root&#39;,&#39;root&#39;);

// var_dump($co);

$sn = mysql_query(&#39;set names utf8&#39;);

// var_dump($sn);

$db = mysql_query(&#39;use test&#39;);
var_dump($db);

mysql_close();

?&gt;
</code></pre>
<hr>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a><strong>请求行</strong></h4><p>形式：请求方式 资源路径 协议版本号</p>
<p>GET &#x2F;index.php HTTP&#x2F;1.1</p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>请求头就是各项协议内容：具体的协议内容不会每次都使用全部。</p>
<p>请求头不固定数量，每个请求协议也是独占一行，最后会有一行空行（用来区分请求头和请求体）</p>
<ol>
<li>Host：请求的主机地址（必须）</li>
<li>Accept：当前请求能够接受服务器返回的类型（MIME类型）</li>
<li>Accept-Language：接收的语言</li>
<li>User-Agent：客户端浏览器所在主机的一些信息</li>
</ol>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>请求数据：POST请求会有请求体。GET请求所有的数据都是跟在URL之后，会在请求行中的资源路径上体现</p>
<p>基本格式：资源名字&#x3D;资源值&amp;资源名字&#x3D;资源值</p>
<h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><p>形式：协议版本号 状态码 状态消息</p>
<p>状态码：</p>
<ol>
<li>200：成功</li>
<li>403：没访问权限</li>
<li>404：未找到页面</li>
<li>500：Server Internal Error：服务器内部错误</li>
</ol>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>时间：Date: Sat, 06 Apr 2024 03:36:22 GMT</p>
<p>服务器：Server: Apache</p>
<p>内容长度：Server: Apache</p>
<p>内容类型：Content-Type: text&#x2F;html</p>
<p>当前请求文件在服务器上一次修改的最后时间（缓存技术）：Last-Modified: Tue, 02 Apr 2024 02:29:49 GMT</p>
<p>Keep-Alive：tmieout&#x3D;5，max&#x3D;100：在5秒内最多请求100次</p>
<h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><p>实际服务器返回的内容</p>
<h3 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h3><ol>
<li><blockquote>
<p>1xx：服务器正在处理过程中</p>
</blockquote>
</li>
<li><blockquote>
<p>2xx：成功</p>
</blockquote>
</li>
<li><blockquote>
<p>3xx：重定向</p>
</blockquote>
</li>
<li><blockquote>
<p>4xx：客户端出错</p>
</blockquote>
</li>
<li><blockquote>
<p>5xx：服务器端出错</p>
</blockquote>
</li>
</ol>
<h3 id="常见HTTP响应即设置"><a href="#常见HTTP响应即设置" class="headerlink" title="常见HTTP响应即设置"></a>常见HTTP响应即设置</h3><p>PHP中针对http协议（响应）进行了底层设计，可以通过函数header来实现修改HTTP响应</p>
<p><strong>注意事项</strong></p>
<blockquote>
<p>Header可以设计HTTP响应，因为HTTP协议特点是，响应行，响应头  </p>
</blockquote>
<blockquote>
<p>Location：重定向，立即跳转（响应体不用解析），浏览器看到该项，不在向下解析</p>
</blockquote>
<pre><code class="php">&lt;?php
header(&#39;Location:Test.php&#39;)
echo __FILE__;// 不会解析改代码
</code></pre>
<blockquote>
<p>Refresh：重定向，定时跳转（响应体会解析).</p>
<p>浏览器会根据具体响应时间延迟后在访问指定跳转连接:浏览器在准备跳转访问之前,会继续解析HTTP协议(响应头和响应体)</p>
</blockquote>
<pre><code class="php">&lt;?php

header(&#39;Refresh:3;url=Test.php&#39;); //先写时间

echo __FILE__;
</code></pre>
<blockquote>
<p>Content-type：内容类型，MIME类型</p>
</blockquote>
<blockquote>
<p>Content-disposition：内容类型，MIME类型扩展，激活浏览器文件下载对话框</p>
<p>浏览器在解析内容的时候,默认是直接解析;有时候需要浏览器不解析,当作内容下载成文件</p>
</blockquote>
<pre><code class="php">&lt;?php

header(&#39;Content-disposition:attacment;filename=girl.jpg&#39;);
/* 
attchament是告诉浏览器这是副本
filename:给文件命名
*/
</code></pre>
<h3 id="PHP模拟HTTP请求"><a href="#PHP模拟HTTP请求" class="headerlink" title="PHP模拟HTTP请求"></a>PHP模拟HTTP请求</h3><p><strong>原理:</strong></p>
<blockquote>
<p>PHP可以通过模拟HTTP协议发起HTTP请求。</p>
<p>CURL是一个非常强大的开源库,支持很多协议,包括HTTP、FTP、TELNET等，我们使用他来发送HTTP请求。他给我们带来的好处是可以通过灵活的选项，设置不同的HTTP协议参数，并且支持HTTPS。</p>
<p>CURL可以根据URL前缀是“HTTP”还是“HTTPS”自动选择是否加密发送内容。</p>
</blockquote>
<p><strong>Curl扩展库使用</strong></p>
<p>首先需要在<code>php.ini</code>中开启<code>php_curl</code>扩展</p>
<p>1、建立连接：curl_init()</p>
<pre><code class="php">&lt;?php
$link = curl_init();
</code></pre>
<p>2、设置请选项：curl_setOpt()对应的一些选项都是常量</p>
<blockquote>
<p>CURLOPT_URL：连接对象</p>
</blockquote>
<blockquote>
<p>CURLOPT_RETURNTRANSFER：将服务器执行的结果（响应）以文件流的形式返回给请求界面（PHP脚本）</p>
</blockquote>
<blockquote>
<p>CURLOPT_POST ：是否采用POST的方式发起请求（默认是GET）</p>
</blockquote>
<blockquote>
<p>CURLOPt_POSTFIELDS：用来传递POST提交的数据，分为两种方式：字符串（name&#x3D;abc&amp;password&#x3D;123）以及数组形式（array(‘name’ &#x3D;&gt; ‘abc’,’password’ &#x3D;&gt; 123,…)）</p>
</blockquote>
<blockquote>
<p>CURLOPT_HEADER：是否得到相应的header信息（服务器相应的响应行和响应头）。0：不获取；1：获取</p>
</blockquote>
<pre><code class="php">&lt;?php
$link = curl_init();

//设置连接选项
curl_setopt($link,CURLOPT_URL,&quot;localhost/Test.php&quot;);
curl_setopt($link,CURLOPT_RETURNTRANSFER,TRUE);
curl_setopt($link,CURLOPT_HEADER,0);
</code></pre>
<p>3、执行请求：curl_exex()</p>
<pre><code class="php">&lt;?php
$link = curl_init();

//设置连接选项
curl_setopt($link,CURLOPT_URL,&quot;localhost/Test.php&quot;);
curl_setopt($link,CURLOPT_RETURNTRANSFER,TRUE); // 文件流形式返回
curl_setopt($link,CURLOPT_HEADER,0);

//使用POST提交数据
curl_setopt($link,CURLOPT_POST,TRUE); 
curl_setopt($link,CURLOPT_POSTFIELDS,array()); 

//执行
$reuslt = curl_exec($link);
echo &quot;&lt;pre&gt;&quot;;
var_dump($reuslt);
</code></pre>
<p>4、关闭连接：curl_close()</p>
<pre><code class="php">&lt;?php
$link = curl_init();

//关闭连接
curl_close($link);
</code></pre>
<h2 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h2><p>文件编程指利用PHP代码针对文件（文件夹）进行增、删、改、查操作。</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><strong>1、创建目录</strong></p>
<blockquote>
<p>mkDir(路径)：成功返回ture，失败返回false</p>
<p>注意：当创建的文件夹已经存在时，会报错，可以用错误抑制符<code>@</code>隐藏错误</p>
</blockquote>
<p><strong>2、删除目录</strong></p>
<blockquote>
<p>rmDir(路径)：返回bool值</p>
</blockquote>
<p><strong>3、读取目录</strong></p>
<p>读取方式：将文件夹按照资方式打开</p>
<blockquote>
<p>openDir()：打开资源，返回一个路径资源，包含指定目录下的所有文件（文件夹）</p>
</blockquote>
<blockquote>
<p>readDir()：从资源中读取指针所在位置的文件名字，然后指针下移，直到指针移除资源</p>
</blockquote>
<p><strong>4、关闭目录</strong></p>
<blockquote>
<p>closeDir()：关闭目录</p>
</blockquote>
<pre><code class="php">&lt;?php

$res = opendir(&quot;error&quot;);

while($file = readdir($res))&#123;
    echo $file,&quot;&lt;br&gt;&quot;;
&#125;
closedir($res);
</code></pre>
<h3 id="其他目录操作"><a href="#其他目录操作" class="headerlink" title="其他目录操作"></a>其他目录操作</h3><blockquote>
<p>dirName()：得到的是路径的上一层目录</p>
</blockquote>
<pre><code class="PHP">&lt;?PHP
var_dump(dirname(&quot;D:\Blog\Blog\source\_posts&quot;));
//输出：string(19) &quot;D:\Blog\Blog\source&quot;
</code></pre>
<blockquote>
<p>realPath()：得到的是真实路径，如果是文件将会返回false（相对路径会返回文件的真是路径）</p>
</blockquote>
<pre><code class="php">&lt;?php
$path1 = &quot;D:\Blog\Blog\source\_posts&quot;;
$path2 = &quot;./index.html&quot;;

var_dump(realpath($path1),realpath($path2));
//输出：string(26) &quot;D:\Blog\Blog\source\_posts&quot; string(45) &quot;D:\Xuexi\PHPstudy\phpstudy_pro\WWW\index.html&quot;
</code></pre>
<blockquote>
<p>is_dir()：判断指定路径是否是一个目录</p>
</blockquote>
<pre><code class="php">&lt;?php
var_dump(is_dir(&#39;D:\Blog\Blog\source\_posts&#39;));
</code></pre>
<blockquote>
<p>scandir()：封装版的opendir()&#x2F;readir()&#x2F;closedir()，获取一个指定目录下的所有文件信息，数组形式返回</p>
</blockquote>
<pre><code class="php">&lt;?php
echo &quot;&lt;pre&gt;&quot;;
var_dump(scandir(&quot;./&quot;));
</code></pre>
<h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p>指定一个目录的情况下，将其下的所有文件夹和目录，以及目录内部的所有内容都输出出来。</p>
<p><code>没有做目录的分层显示</code></p>
<pre><code class="php">&lt;?php
echo &quot;&lt;pre&gt;&quot;;
function a_dir($paht)&#123;
    if(!is_dir($paht))&#123;
        return false; //递归出口，不是目录，停止调用
    &#125;
    $arr = scandir($paht);
    var_dump($arr);
    foreach($arr as $v)&#123;
       if($v == &#39;.&#39; || $v == &#39;..&#39;) continue;
       $file_dir = $paht.$v;
       a_dir($file_dir);
    &#125;
&#125;
// $paht = &quot;D:/Xuexi/PHPstudy/phpstudy_pro/WWW/m/&quot;;
a_dir(&quot;D:/Xuexi/PHPstudy/phpstudy_pro/WWW/m/&quot;);
</code></pre>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>php5常见的文件操作函数</strong></p>
<blockquote>
<p>1、file_get_contents(路径)：获取指定文件的所有内容（如果文件不存在，会报错+返回false）</p>
</blockquote>
<pre><code class="php">&lt;?php

var_dump(file_get_contents(&#39;con.txt&#39;));
/*Warning: file_get_contents(con.txt): failed to open stream: No such file or directory in D:\Xuexi\PHPstudy\phpstudy_pro\WWW\Test.php on line 3
bool(false)*/
</code></pre>
<blockquote>
<p>2、file_put_contents()：将指定内容写入指定文件内（如果文件不存在，会创建文件；如果目录不存在，不会创建目录），返回写入的内容长度。</p>
</blockquote>
<pre><code class="php">&lt;?php

$str = &quot;hello world&quot;;
$file = &#39;con.txt&#39;;
var_dump(file_put_contents($file,$str));
/*
int(11)
*/
</code></pre>
<p><strong>php4常见文件操作函数</strong></p>
<p>php4中是将文件操作用资源形式处理的，不论是读、还是写都依赖资源指针：文件内容中指针所在的位置</p>
<blockquote>
<p>fopen(路径,打开模式)：打开一个文件资源</p>
</blockquote>
<p><img src="/../img/php/wjcz.png"></p>
<blockquote>
<p>fread (资源,长度)：从打开的资源中读取指定长度（字节）</p>
</blockquote>
<blockquote>
<p>fwrite(资源,内容)：向打开的资源中写入指定的内容</p>
</blockquote>
<blockquote>
<p>fclose(资源)：关闭资源</p>
</blockquote>
<h3 id="其他操作文件的函数"><a href="#其他操作文件的函数" class="headerlink" title="其他操作文件的函数"></a>其他操作文件的函数</h3><blockquote>
<p>is_file()：判断文件是否正确（不识别路径）</p>
</blockquote>
<blockquote>
<p>filesize()：获取文件大小</p>
</blockquote>
<blockquote>
<p>file_exists()：判断文件是否存在（识别路径）</p>
</blockquote>
<blockquote>
<p>unLink()：取消文件名字与磁盘地址的连接（删除文件）</p>
</blockquote>
<blockquote>
<p>filemtime()：获取文件最后一次修改时间</p>
</blockquote>
<blockquote>
<p>fseek()：设定fopen打开的文件的指针位置</p>
</blockquote>
<blockquote>
<p>fgetc()：一次获取一个字符</p>
</blockquote>
<blockquote>
<p>fgets()：一次获取一个字符串（默认一行）</p>
</blockquote>
<blockquote>
<p>file()：读取整个文件，类似于<code>file_get_contents</code>,区别是file()是按行读取，返回一个数字</p>
</blockquote>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>从服务器将文件通过http协议传输到浏览器，浏览器不解析保存成相应的文件。</p>
<p>下载方式：</p>
<p><strong>a标签</strong>：&lt;a href &#x3D; “#”&gt;&lt;&#x2F;a&gt;</p>
<ol>
<li>a标签能够让浏览器自动下载的内容有限，浏览器解析不了的内容才会开启下载</li>
<li>a标签下载的我呢见存储路径需要通过href属性写出来，会暴露服务器存储数据位置</li>
</ol>
<p><strong>php下载</strong>：读取问的内容，以文件流的形式传递给浏览器；在响应头中告知浏览器不需要解析</p>
<blockquote>
<p>1、指定浏览器解析字符集</p>
</blockquote>
<pre><code class="php">header(&quot;Content-type:text/html;charset = utf-8&quot;);
</code></pre>
<blockquote>
<p>2、设定响应头</p>
<p>​	a、设定文件返回类型：image&#x2F;jpg	||	application&#x2F;octem-stream</p>
<p>​	b、设定返回文件计算方式：Accept-ranges:bytes</p>
<p>​	c、设定下载提示：Content-disposition:attachment;filename&#x3D;”文件名”</p>
<p>​	d、设定文件大小：Accept-lenght:文件大小（字节）</p>
</blockquote>
<pre><code class="php">&lt;?php
//设置解析字符
header(&quot;Content-type:text/html;charset = utf-8&quot;);

$filename = &#39;Test.php&#39;;
/* 如果文件名是中文，则需要转码，
$filename = iconv(&#39;GBK&#39;,&#39;utf-8&#39;,$filename); */

//设置下载响应头
header(&#39;Content-type:application/octem-stream&#39;);        //以文件流形式传输数据给浏览器
header(&#39;Accept-ranges:bytes&#39;);                             //以字节方式计算
header(&#39;Content-disposition:attachent;filename=&#39;.$filename);      //附件下载，指定命名
header(&#39;Accept-lenght:&#39;.filesize($filename));

echo file_get_contents(&#39;test.php&#39;);  // 输出文件

</code></pre>
<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p><strong>介绍</strong>：HTTP协议的特点是无状态&#x2F;无连接，当一个浏览器连续多次请求同一个web服务器时，服务器是无法区分多个操作是否来自于同一个浏览器（用户）。会话技术就是通过HTTP协议想办法服务器能够识别来自于同一个浏览器的多次请求，从而方便浏览器（用户）在访问同一个网站的多次操作中，能够持续进行而不需要额外的在身份验证。</p>
<p>Cookie技术</p>
<p>Session技术：依赖于cookie技术</p>
<h3 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h3><p>cookie技术：服务器将数据通过HTTP响应存储到浏览器上，浏览器可以在以后携带相对应的cookie数据访问服务器。</p>
<p><img src="/../img/php/cookie1.png"></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><code>支持面向对象的语言其核心思想一样</code></p>
<p><strong>基本语法</strong></p>
<blockquote>
<p>​	1、PHP类结构有三种成员：属性、方法、常量</p>
</blockquote>
<blockquote>
<p>​	2、类结构中只能有三种成员，不限数量，其他代码需要写到方法里面，否则报错</p>
</blockquote>
<blockquote>
<p>​	3、类中属性和方法访问方式都是通过对象来调用：$对象-&gt;属性名&#x2F;方法名();注意属性名不带$符号</p>
</blockquote>
<blockquote>
<p>​	4、类中定义属性不能直接属性名，要跟上修饰限定符号<code>public</code> <code>protected</code> <code>private</code> ，定义方法时可以不写，默认是public</p>
</blockquote>
<blockquote>
<p>​	5、常量定义必须赋初始值，访问方式为类名::常量名。因为常量本质上是类的，不能由对象访问（实际上可以，但不建议）</p>
</blockquote>
<blockquote>
<p>​	6、实例化对象后可以添加原来类中没有的成员变量</p>
</blockquote>
<blockquote>
<p>​	7、可以使用unset()删除成员变量</p>
</blockquote>
<pre><code class="php">&lt;?php
class Studennt&#123;
    public $name; //可以赋初始值
    protected $class;
    private $age; 
    
       const sex = &quot;男&quot;; //类中常量的定义方式
    
    public function display()&#123;
        echo __FUNCTION__;
    &#125;
</code></pre>
<p><strong>实例化对象</strong></p>
<pre><code class="php">&lt;?php
$a = new Student(); //实例化对象
</code></pre>
<p><strong>增加成员变量</strong></p>
<pre><code class="php">&lt;?php
$a-&gt;id = 2022; //增加成员变量
var_dump($a);
</code></pre>
<p><strong>删除成员变量</strong></p>
<pre><code class="php">&lt;?php
unset($a-&gt;id);//删除
var_dump($a);
</code></pre>
<p><strong>访问成员变量</strong></p>
<pre><code class="php">&lt;?php
$a-&gt;name = &quot;小明&quot;;  //赋值
echo $a-&gt;name; //打印
</code></pre>
<p><strong>执行方法</strong></p>
<pre><code class="php">&lt;?php
$a-&gt;display(); //执行方法
</code></pre>
<p><strong>访问常量</strong></p>
<pre><code class="php">&lt;?php
echo Studnet::sex; //常量的访问方式，也是静态方法或者属性的访问方式
</code></pre>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="$this关键字"></a>$this关键字</h3><p>在类内部访问成员变量两种方法</p>
<p><strong>法一</strong></p>
<p>定义一个全局变量，在实例化该类对象时，赋值给该变量。</p>
<pre><code class="php">&lt;?php
class Student&#123;
    public $name = &quot;xiaoming&quot;;
    private $age = 22;
    
    function diaplay()&#123;
        global $a;
        echo $a-&gt;name,$a-&gt;age; //内部访问
    &#125;
&#125;

$a = new Student();
$a-&gt;display();
</code></pre>
<p><strong>法二</strong></p>
<p>使用$this关键字，类似于JAVA中的this关键字，代指对象本身，以方便在类内部使用成员变量</p>
<pre><code class="php">&lt;?php
class Student&#123;
    public $name = &quot;xiaoming&quot;;
    private $age = 22;
    
    function display()&#123;
        echo $this-&gt;name,$this-&gt;age,&quot;&lt;br&gt;&quot;; //这里的$this就是$a
        var_dump($this); //进行输出,与$a的输出一致。
    &#125;
&#125;

$a = new Student();
$a-&gt;display();
echo &quot;&lt;br&gt;&quot;;
var_dump($a);
</code></pre>
<p><strong>PHP中的GET、SET方法</strong></p>
<pre><code class="php">&lt;?php
class Student&#123;
    private $name;
    private $age;
   
    function getName()&#123;
        return $this-&gt;name;
    &#125;
    
    function setName($name)&#123;
        $this-&gt;name = $name;
    &#125;
   
    
    function getAge()&#123;
        return $this-&gt;age;
    &#125;
    
    function setAge($age)&#123;
        $this-&gt;age = $age;
    &#125;
&#125;


$a = new Student();
$a-&gt;setName(&quot;xiaoming&quot;);
echo $a-&gt;getName();

$a-&gt;setAge(22);
echo $a-&gt;getAge();
</code></pre>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>__construct()</code>用来初始化对象的。类似Python中的<code>__init__()</code></p>
<blockquote>
<p>构造方法的实现：在类中增加一个方法<code>__construct()</code>即可</p>
</blockquote>
<pre><code class="php">&lt;?php
class Student&#123;
    public $name;
    public $age;
    
    function __construct($name,$age)&#123;
        $this-&gt;name = $name;
        $this-&gt;age = $age;
    &#125;
&#125;

$a = new Student(&#39;xiaoming&#39;,22);
echo $a-&gt;name;
</code></pre>
<h3 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h3><blockquote>
<p>定义：析构方法<code>__destruct()</code>,也是一种类结构中特殊的方法，与构造方法一样，也是系统规定好的,只需要开发人员抄一遍即可，对象被销毁时自动调用。类似Python中的<code>__del__()</code>.</p>
</blockquote>
<pre><code class="php">&lt;?php
class Student&#123;
    function __destruct()&#123;
        echo __FUNCTION__;
    &#125;
&#125;
$a = new Student();
unset($a);
</code></pre>
<h3 id="对象传值"><a href="#对象传值" class="headerlink" title="对象传值"></a>对象传值</h3><pre><code class="php">&lt;?php
class Student&#123;&#125;
$a = new Student();

$b = $a;	//此时传递的是地址实际都是一个对象，引用传递 
</code></pre>
<h3 id="范围解析操作符"><a href="#范围解析操作符" class="headerlink" title="范围解析操作符"></a>范围解析操作符</h3><blockquote>
<p>定义：范围解析操作符<code>::</code>，有两个冒号组成，专门用于类实现类成员操作的，可以实现类直接访问类成员</p>
</blockquote>
<p><strong>访问常量</strong></p>
<p>对象也可以访问常量</p>
<pre><code class="php">&lt;?php
class Student&#123;
    const num = 22;
&#125;
echo Student::num;
$a = new Student();
//使用对象访问
echo $a::num;
</code></pre>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><blockquote>
<p>1、定义：使用<code>static</code>修饰的成员变量、方法为静态变量和方法,是类所有的</p>
</blockquote>
<blockquote>
<p>2、类是可以访问普通成员方法，但是不可以访问成员变量</p>
</blockquote>
<blockquote>
<p>3、对象也可以访问静态方法和静态变量，使用<code>::</code></p>
</blockquote>
<pre><code class="php">&lt;?php
class Student&#123;
    public static $name = &quot;xiaoming&quot;;
    public $age = 22;
    static function display()&#123;
        echo __FUNCTION__;
    &#125;
    function cou()&#123;
        echo __FUNCTION__;
    &#125;

&#125;
echo Student::$name; //访问静态变量
Student::display();
Student::cou();
</code></pre>
<p><strong>注意</strong>：静态方法本质是给类访问，所以不允许再静态方内部使用<code>$this</code></p>
<pre><code class="php">&lt;?php
class Student&#123;
    static function display()&#123;
     var_dump($this);
    &#125;
&#125;
Student::dispaly(); //会输出NULL
</code></pre>
<h3 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h3><blockquote>
<p>1、self是一种在类的内部用来当代替类名的关键字</p>
</blockquote>
<blockquote>
<p>2、self可以用来在类内部访问静态成员（类常量也可以）</p>
</blockquote>
<blockquote>
<p>3、self 也可以再类内部用来实例化对象（代替类名：<code>new self()</code>）</p>
</blockquote>
<pre><code class="php">&lt;?php
class Student&#123;
    public static $num = 000;
    public static function display_self()&#123;
        echo self::$num;
    &#125;
&#125;
Student::display_self();
</code></pre>
<blockquote>
<p>self也可以在类的内部方便实例化对象：例如构造方法私有化之后，在内部进行实例化对象</p>
</blockquote>
<pre><code class="php">&lt;?php
class Student&#123;
    public static $num = 100;
    private function __construct()&#123;&#125;

    public static function getInsetance()&#123;
        return new self();
    &#125;
&#125;
$a = Student::getInsetance(); //获取对象
</code></pre>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p><strong>定义：</strong>所谓类的加载，本质上是因为类的访问必须保证类在内存中已经存在，所以需要在用类之前将所在类的PHP文件加载到内存。</p>
<blockquote>
<p>1、手动加载：访问某个类之前，使用文件包含将类所在的文件加载进来</p>
</blockquote>
<pre><code class="php">类文件:
&lt;?php
class Student&#123;
    function __construct()&#123;
        echo __METHOD__;
    &#125;
&#125;
?&gt;
加载文件：
&lt;?php
include_once &#39;Student.php&#39;;
$a = new Student();
?&gt;
</code></pre>
<blockquote>
<p>2、加载文件是一种消耗资源的方式，所以有的时候不确定类是否在内存中，可以用<code>class_exists()</code>函数来判定是否存在</p>
</blockquote>
<pre><code class="php">类文件:
&lt;?php
class Student&#123;
    function __construct()&#123;
        echo __METHOD__;
    &#125;
&#125;
?&gt;
加载文件：
&lt;?php
//判断Student是否存在
if(!class_exists(&#39;Student&#39;))&#123;
    include_once &#39;Student.php&#39;;
&#125;
$a = new Student();
?&gt;
</code></pre>
<blockquote>
<p>3、自动加载：定义一个<code>__autoload()</code>,然后当系统需要使用类，而内存中又不存在时，系统会自动调用<code>__autoload()</code>函数来加载文件</p>
</blockquote>
<pre><code class="php">&lt;?php
function __autoload($className)&#123;
    include_once $className.&quot;.php&quot;;
&#125;
//系统没有发现内存中有Student类，会自动调用__autoload()函数
$a = new Student();
</code></pre>
<blockquote>
<p>4、一个系统里，可能类文件会放到不同的路径下。因此一个完整的自动加载函数，应该要进行文件判定即加载功能</p>
<p><code>file_exists()</code>判断文件是否存在</p>
</blockquote>
<pre><code class="php">&lt;?php

function __autoload($className)&#123;
    $file_b = &#39;b/&#39;.$className.&#39;.php&#39;;  //b文件夹下
    if(file_exists($file_b))&#123;
        include_once $file_b;
        return;
    &#125;

    $file_m = &#39;m/&#39;.$className.&#39;.php&#39;;  //m文件夹下
    if(file_exists($file_m))&#123;
        include_once $file_m;
        return;
    &#125;
&#125;
$a = new Student();
</code></pre>
<blockquote>
<p>5 、随着php版本的提升，在7以后，不怎么建议直接使用<code>__autoload()</code> 函数，而是<code>采用一种注册机制，将用户自定义函数放到系统内部</code>，使用<code>spl_autoload_register(自定义的函数)</code>。本质上于<code>__autoload()</code>一样</p>
</blockquote>
<pre><code class="php">&lt;?php
function b__autoload($className)&#123;
    $file_b = &#39;b/&#39;.$className.&#39;.php&#39;;  //b文件夹下
    if(file_exists($file_b))&#123;
        include_once $file_b;
        return;
    &#125;
&#125;

function c__autoload($className)&#123;
    $file_m = &#39;m/&#39;.$className.&#39;.php&#39;;  //m文件夹下
    if(file_exists($file_m))&#123;
        include_once $file_m;
        return;
    &#125;
&#125;
//将函数注册到系统内部，可以注册多个函数
spl_autoload_register(&#39;b__autoload&#39;);
spl_autoload_register(&#39;c__autoload&#39;);

$a = new Student();
var_dump($a);
</code></pre>
<blockquote>
<p>6、<code>spl_autoload_register</code>也可以加载类，通过数组的方式</p>
</blockquote>
<pre><code class="php">&lt;?php
class Autoload&#123;
    public static function m_load($className)&#123;
        $m_file = &#39;m/&#39;.$className.&#39;.php&#39;;
        if(file_exists($m_file))&#123;
            include_once $m_file;
        &#125;
    &#125;

    public function b_load($className)&#123;
        $m_file = &#39;b/&#39;.$className.&#39;.php&#39;;
        if(file_exists($b_file))&#123;
            include_once $b_file;
        &#125;
    &#125;


&#125;
//用数组的方式，静态方法用类名加方法名
spl_autoload_register(array(&#39;Autoload&#39;,&#39;m_load&#39;));
spl_autoload_register(array(&#39;Autoload&#39;,&#39;b_load&#39;));
/*
如果是对象调用的普通方法，就new一个对象即可
spl_autoload_register(array(new Autoload(),&#39;m_load&#39;));
*/
$a = new Student();
var_dump($a);
</code></pre>
<h3 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h3><blockquote>
<p>定义：克隆对象clone，即通过已有的对象赋值一个新的同样的对象，但是两者之间并非同一个对象</p>
<p>可以私有<code>__clone()</code>来禁止外部克隆</p>
</blockquote>
<p>1、通过clone关键字来实现</p>
<pre><code class="php">&lt;?php
class Student&#123;
    public $name;
    private $age;

&#125;

$a = new Student();
$a -&gt;name = &quot;php&quot;;
$b = clone $a;
var_dump($a,$b); //可以发现克隆得到的对象$b，内容和$a一样，但是在内存中的地址不一样。
</code></pre>
<p>2、对象在实例化的时侯会自动调用存在的构造方法<code>__construct()</code>，同样的，在类内部，PHP允许定义一个<code>__clone()</code>方法，在对象被克隆后，新克隆出来的对象会自动调用</p>
<pre><code class="php">&lt;?php
class Student&#123;
    public $name;
    private $age;
    public function __clone()&#123;
        var_dump($this);
    &#125;

&#125;
$a = new Student();
$b = clone $a; 
</code></pre>
<h3 id="封装数据库类"><a href="#封装数据库类" class="headerlink" title="封装数据库类"></a>封装数据库类</h3><p>1、创建一个类，声明需要的变量</p>
<pre><code class="php">&lt;?php

class Sql&#123;
    public $host;
    public $post;
    public $user;
    public $passwd;
    public $dbname;
    public $chartset;
    public $sql_link;
</code></pre>
<p>2、使用构造方法，初始化变量</p>
<pre><code class="php">&lt;?php

class Sql&#123;
    public $host;
    public $post;
    public $user;
    public $passwd;
    public $dbname;
    public $chartset;
    public $sql_link;

    //构造方法初始化数据，参数较多，应使用数组的方式传递数据
    public function __construct(array $info = array())&#123;
        //确保用户传递了参数，否则使用默认值;
        $this -&gt;host = $info[&#39;host&#39;]??&#39;localhost&#39;;
        $this -&gt;post = $info[&#39;post&#39;]??&#39;3306&#39;;  //PHP7新增的NULL合并运算符，用于执行isset()检测的三元运算符的快捷方式
        $this -&gt;user = $info[&#39;user&#39;]??&#39;root&#39;;
        $this -&gt;passwd = $info[&#39;passwd&#39;]??&#39;root&#39;;
        $this -&gt;dbname = $info[&#39;dbname&#39;]??&#39;security&#39;;
        $this -&gt;chartset = $info[&#39;chartset&#39;]??&#39;utf-8&#39;;

        

/*         $this -&gt;host = isset($info[&#39;host&#39;])?$info[&#39;host&#39;]:&#39;localhost&#39;;
        $this -&gt;post = isset($info[&#39;post&#39;])?$info[&#39;post&#39;]:&#39;3306&#39;;
        $this -&gt;user = isset($info[&#39;user&#39;])?$info[&#39;user&#39;]:&#39;root&#39;;
        $this -&gt;passwd = isset($info[&#39;passwd&#39;])?$info[&#39;passwd&#39;]:&#39;root&#39;;
        $this -&gt;dbname = isset($info[&#39;dbname&#39;])?$info[&#39;dbname&#39;]:&#39;security&#39;;
        $this -&gt;chartset = isset($info[&#39;chartset&#39;])?$info[&#39;chartset&#39;]:&#39;utf-8&#39;; */
    &#125;&#125;
</code></pre>
<p>3、创建一个方法，进行数据库的连接，在构造方法中调用</p>
<pre><code class="php"> public function mysql_link()&#123;
        $this-&gt;$sql_link = @new mysqli($this-&gt;host,$this-&gt;user,$this-&gt;passwd,$this-&gt;dbname,$this-&gt;port);
        //判定是否连接成功
        if($this-&gt;$sql_link-&gt;connect_error)&#123;
            //mysqli对象有两个属性：connect_errno表示错误编号，connect_error表示错误信息：发生错误后终止脚本执行
            die(&#39;Connect Error(&#39;.$sql_link-&gt;connect_erron.&#39;.):&#39;.$sql_link-&gt;connect_error);
        &#125;

    &#125;
</code></pre>
<p>4、 定义一个方法，用来处理数据库错误</p>
<pre><code class="php">    public function sql_error($res)&#123;
        if(!$res)&#123;
            //mysqli对象有两个属性：errno表示错误编号，error表示错误信息：发生错误后终止脚本执行
            die(&#39;Error(&#39;.$this-&gt;sql_link-&gt;errno.&#39;.):&#39;.$this-&gt;sql_link-&gt;error);
        &#125;
    &#125;
</code></pre>
<p>5、定义一个设置字符集的方法，在构造方法中调用</p>
<blockquote>
<p>query()：失败返回false，通过mysqli_query()成功执行select、show、desc、explain查询会返回一个<code>mysqli_result对象</code>，其他查询寻返回true</p>
</blockquote>
<pre><code class="php">    public function mysql_charset()&#123;
        $sql = &quot;set names  &#123;$this-&gt;charset&#125;&quot;;
        $res = @$this-&gt;sql_link-&gt;query($sql); 
        $this-&gt;sql_error($res);
    &#125;
</code></pre>
<p>6、数据库的初始化操作已经完成，此时要考虑的事情是为了干什么？为了执行sql指令，也就是怎删改查。在mysqli所有的sql执行都是通过mysqli::query()方法执行，但是我们可以根据需求封装两个还能输：写方法和查方法；</p>
<pre><code class="php">    //定义一个写方法，由外部传入sql指令
    public function sql_exec($sql)&#123;
        $res =$this-&gt;sql_link-&gt;query($sql); //执行成功返回的是一个对象
        $this-&gt;sql_error($res);
        return $res; //本质就是一个true
    &#125;
</code></pre>
<pre><code class="php">    //定义一个读方法
    public function sql_read($sql,$all=false)&#123;
        //$all代表是否获取多条数据，默认false获取一条
        $res = $this-&gt;sql_link-&gt;query($sql);//执行成功返回的是一个对象
        $this-&gt;sql_error($res);

        //判断是否获取多条数据
        if($all)&#123;
            //获取全部：mysqli_result::fetch_all(MYSQLI_ASSOC)表示返回关联数组，默认是索引数组
            return $res-&gt;fetch_all(MYSQLI_ASSOC);
        &#125;else&#123;
            //获取一条：mysql_result::fetch_assoc()
            return $res-&gt;fetch_ASSOC();
        &#125;
    &#125;
</code></pre>
<p>7、上述已经完成了数据库类要实现的基本功能；实现sql指令的执行和结果的返回。但是从功能细节的角度出发还需要进行完善：插入操作后需要获取自增长id，更新和删除操作受影响的行数，查询操作中记录数量。这种使用可以通过设置方法来实现获取（自增长id），也可以通过增加属性来实现（属性简单）。</p>
<p>增加属性：受影响的行数、自增长id、查询记录数。</p>
<blockquote>
<p>在sql类中追加属性</p>
</blockquote>
<pre><code class="php">public $affected_rows;	//受影响行数（上次操作）。mysqli的属性
public $num_rows;	//查询结果记录数（上次操作）。mysqli::result的属性
</code></pre>
<pre><code class="php">public $affected_rows;
public function sql_exec($sql)&#123;
        $res =$this-&gt;sql_link-&gt;query($sql); //执行成功返回的是一个对象
        $this-&gt;sql_error($res);
    
        $this-&gt;affected_rows = $this-&gt;sql_link-&gt;num_rows;
    
        return $res; //本质就是一个true
    &#125;
</code></pre>
<pre><code class="php">    public $num_rows;
    public function sql_read($sql,$all=false)&#123;
        //$all代表是否获取多条数据，默认false获取一条
        $res = $this-&gt;sql_link-&gt;query($sql);//执行成功返回的是一个对象
        $this-&gt;sql_error($res);
        
        $this-&gt;num_rows = $res-&gt;num_rows;
        
        //判断是否获取多条数据
        if($all)&#123;
            //获取全部：mysqli_result::fetch_all(MYSQLI_ASSOC)表示返回关联数组，默认是索引数组
            return $res-&gt;fetch_all(MYSQLI_ASSOC);
        &#125;else&#123;
            //获取一条：mysql_result::fetch_assoc()
            return $res-&gt;fetch_ASSOC();
        &#125;
        
        
    &#125;
</code></pre>
<blockquote>
<p>自增长的id</p>
</blockquote>
<pre><code class="php">//定义一个方法，获取自增长id
    //定义一个方法，获取自增长id
    public function sql_insert_id()&#123;
        return $this-&gt;sql_link-&gt;insert_id;
    &#125;
</code></pre>
<p><strong>整个代码</strong></p>
<pre><code class="php">&lt;?php

class Sql&#123;
    public $host;
    public $post;
    public $user;
    public $passwd;
    public $dbname;
    public $charset;
    public $sql_link;

    //构造方法初始化数据，参数较多，应使用数组的方式传递数据
    public function __construct(array $info = array())&#123;
        //确保用户传递了参数，否则使用默认值;
        $this -&gt;host = $info[&#39;host&#39;]??&#39;localhost&#39;;
        $this -&gt;post = $info[&#39;post&#39;]??&#39;3306&#39;;  //PHP7新增的NULL合并运算符，用于执行isset()检测的三元运算符的快捷方式
        $this -&gt;user = $info[&#39;user&#39;]??&#39;root&#39;;
        $this -&gt;passwd = $info[&#39;passwd&#39;]??&#39;root&#39;;
        $this -&gt;dbname = $info[&#39;dbname&#39;]??&#39;security&#39;;
        $this -&gt;charset = $info[&#39;chartset&#39;]??&#39;utf8&#39;;

        

/*         $this -&gt;host = isset($info[&#39;host&#39;])?$info[&#39;host&#39;]:&#39;localhost&#39;;
        $this -&gt;post = isset($info[&#39;post&#39;])?$info[&#39;post&#39;]:&#39;3306&#39;;
        $this -&gt;user = isset($info[&#39;user&#39;])?$info[&#39;user&#39;]:&#39;root&#39;;
        $this -&gt;passwd = isset($info[&#39;passwd&#39;])?$info[&#39;passwd&#39;]:&#39;root&#39;;
        $this -&gt;dbname = isset($info[&#39;dbname&#39;])?$info[&#39;dbname&#39;]:&#39;security&#39;;
        $this -&gt;chartset = isset($info[&#39;chartset&#39;])?$info[&#39;chartset&#39;]:&#39;utf8&#39;; */

        $this-&gt;mysql_link();
        $this-&gt;mysql_charset();

        



    &#125;
    //定义一个方法，使用mysqli面向对象的方法，来进行数据库的连接，构造方法参数分别为：主机、用户名、密码、数据库、端口；利用@抑制可能出现的错误
    public function mysql_link()&#123;
        $this-&gt;sql_link = @new mysqli($this-&gt;host,$this-&gt;user,$this-&gt;passwd,$this-&gt;dbname,$this-&gt;port);
        //判定是否连接成功
        if($this-&gt;sql_link-&gt;connect_error)&#123;
            //mysqli对象有两个属性：connect_errno表示错误编号，connect_error表示错误信息：发生错误后终止脚本执行
            die(&#39;Connect Error(&#39;.$this-&gt;sql_link-&gt;connect_errno.&#39;.):&#39;.$this-&gt;sql_link-&gt;connect_error);
        &#125;

    &#125;

    //设置字符集
    public function mysql_charset()&#123;
        $sql = &quot;set names  &#123;$this-&gt;charset&#125;&quot;;
        $res = @$this-&gt;sql_link-&gt;query($sql);
        // var_dump($res);
        $this-&gt;sql_error($res);

    &#125;

    //定一个处理错误的方法，方便调用
    public function sql_error($res)&#123;
        if(!$res)&#123;
            //mysqli对象有两个属性：errno表示错误编号，error表示错误信息：发生错误后终止脚本执行
            die(&#39;Error(&#39;.$this-&gt;sql_link-&gt;errno.&#39;.):&#39;.$this-&gt;sql_link-&gt;error);
        &#125;
    &#125;
    
    public $affected_rows;
    //定义一个写方法，由外部传入sql指令
    public function sql_exec($sql)&#123;
        $res =$this-&gt;sql_link-&gt;query($sql); //执行成功返回的是一个对象
        $this-&gt;sql_error($res);
        $this-&gt;affected_rows = $this-&gt;sql_link-&gt;num_rows;
        return $res; //本质就是一个true
    &#125;

    public $num_rows;
    //定义一个读方法
    public function sql_read($sql,$all=false)&#123;
        //$all代表是否获取多条数据，默认false获取一条
        $res = $this-&gt;sql_link-&gt;query($sql);//执行成功返回的是一个对象
        $this-&gt;sql_error($res);
        $this-&gt;num_rows = $res-&gt;num_rows;

        //判断是否获取多条数据
        if($all)&#123;
            //获取全部：mysqli_result::fetch_all(MYSQLI_ASSOC)表示返回关联数组，默认是索引数组
            return $res-&gt;fetch_all(MYSQLI_ASSOC);
        &#125;else&#123;
            //获取一条：mysql_result::fetch_assoc()
            return $res-&gt;fetch_ASSOC();
        &#125;
    &#125;

    //定义一个方法，获取自增长id
    public function sql_insert_id()&#123;
        return $this-&gt;sql_link-&gt;insert_id;
    &#125;




&#125;

$s = new Sql();

</code></pre>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>此类只产生一个实例对象，windows的任务管理器就是单例模式</p>
<p>1、私有构造器</p>
<pre><code class="php">&lt;?php

class Test&#123;
    private function __construct()&#123;
        
    &#125;
&#125;
</code></pre>
<p>2、定义一个静态方法产生对象</p>
<pre><code class="php">    public static function getInstace()&#123;
        new $self();
    &#125;
</code></pre>
<p>3、每次调用getInstace()都会产生一个新对象，定义一个静态变量接受对象</p>
<pre><code class="php">&lt;?php

class Test&#123;
    private static $prom = null;
    
    private function __construct()&#123;&#125;
    
    public static function getInstance()&#123;
        //判断静态属性是否是当前对象
        if(!self::$prom instanceof self)&#123;
            self::$prom = new self();
        &#125;
        return self::$prom;
    &#125;

&#125;

$a = Test::getInstance();
var_dump($a);
</code></pre>
<p>4、通过clone仍会得到另一个对象，所以私有clone()方法</p>
<pre><code class="php">private function __clone()&#123;&#125;
</code></pre>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>降低后期维护成本</p>
<pre><code class="php">&lt;?php

class Man&#123;
    public function display()&#123;
        echo &quot;我是男人&quot;,&quot;&lt;br&gt;&quot;;
    &#125;
&#125;

class WoMan&#123;
    public function display()&#123;
        echo &quot;我是女人&quot;,&quot;&lt;br&gt;&quot;;
    &#125;
&#125;

//工厂，在此工厂内实例化对象，后期修改类名，只需要修改定义类处、工厂对象内部
class HumanFactory&#123;
    public static function getInstance($classname)&#123;
        switch($classname)&#123;
            case &#39;w&#39;:
                return new Man();
            case &#39;wm&#39;:
                return new WoMan();
            default:
                 return  null;

        &#125;        
    &#125;

&#125;
$m = HumanFactory::getInstance(&#39;w&#39;);
$m-&gt;display();

$wm = HumanFactory::getInstance(&#39;wm&#39;);
$wm-&gt;display();
</code></pre>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>定义</strong>：在面向对象思想中，<code>封装</code>指将数据和对数据的操作捆绑到一起，形成对外界的隐蔽，同时对外界提供可操作的接口。（类似javabean）</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h1 id="PHP-exit-exit-die的区别"><a href="#PHP-exit-exit-die的区别" class="headerlink" title="PHP  exit ,exit(),die的区别"></a>PHP  exit ,exit(),die的区别</h1><p>1、die()</p>
<blockquote>
<p>是遇到错误才停止，停止程序运行，输出内容(是程序级别的)</p>
</blockquote>
<p>2、exit，exit():是一个函数，<code>停止程序的运行</code>。前者不输出内容；后这可以输出内容(是程序级别的)</p>
<blockquote>
<p>exit(0)：正常运行程序并退出程序；</p>
<p>exit(1)：非正常运行导致退出程序；</p>
</blockquote>
<p>3、return:只是一个关键字</p>
<blockquote>
<p>return是返回值，跳出函数，但不停止程序运行。</p>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
